import * as _hey_api_client_fetch from '@hey-api/client-fetch';
import { Client, TDataShape, Options as Options$1, createConfig, RequestResult } from '@hey-api/client-fetch';
import Keyv, { KeyvStoreAdapter } from 'keyv';
import TypedEventEmitter from 'typed-emitter';

declare class VRChatError extends Error {
    request: Request;
    response: Response;
    get statusCode(): number;
    get unauthorized(): boolean;
    private constructor();
    toResponseError(): {
        error: {
            message: string;
            status_code: number;
        };
    };
}

/**
 * UserExists
 * Status object representing if a queried user by username or userId exists or not. This model is primarily used by the `/auth/exists` endpoint, which in turn is used during registration. Please see the documentation on that endpoint for more information on usage.
 */
type UserExists = {
    /**
     * Status if a user exist with that username or userId.
     */
    userExists: boolean;
    /**
     * Is the username valid?
     */
    nameOk?: boolean;
};
/**
 * Response
 */
type Response$1 = {
    message?: string;
    status_code: number;
};
type _Error = VRChatError;
/**
 * AccountDeletionLog
 */
type AccountDeletionLog = {
    /**
     * Typically "Deletion requested" or "Deletion canceled". Other messages like "Deletion completed" may exist, but are these are not possible to see as a regular user.
     */
    message?: string;
    /**
     * When the deletion is scheduled to happen, standard is 14 days after the request.
     */
    deletionScheduled?: Date | null;
    /**
     * Date and time of the deletion request.
     */
    dateTime?: Date;
};
/**
 * UserID
 * A users unique ID, usually in the form of `usr_c1644b5b-3ca4-45b4-97c6-a2a0de70d469`. Legacy players can have old IDs in the form of `8JoV9XEdpo`. The ID can never be changed.
 */
type UserId = string;
/**
 * AgeVerificationStatus
 * `verified` is obsolete.
 *
 * User who have verified and are 18+ can switch to `plus18` status.
 *
 */
type AgeVerificationStatus = 'hidden' | 'verified' | '18+';
/**
 * AgeVerified
 * `true` if, user is age verified (not 18+).
 */
type AgeVerified = boolean;
/**
 * BadgeID
 */
type BadgeId = string;
/**
 * Badge
 */
type Badge = {
    /**
     * only present in CurrentUser badges
     */
    assignedAt?: Date | null;
    badgeDescription: string;
    badgeId: BadgeId;
    /**
     * direct url to image
     */
    badgeImageUrl: string;
    badgeName: string;
    /**
     * only present in CurrentUser badges
     */
    hidden?: boolean | null;
    showcased: boolean;
    /**
     * only present in CurrentUser badges
     */
    updatedAt?: Date | null;
};
/**
 * Tag
 * Tags are a way to grant various access, assign restrictions or other kinds of metadata to various to objects such as worlds, users and avatars.
 *
 * System tags starting with `system_` are granted automatically by the system, while admin tags with `admin_` are granted manually. More prefixes such as `language_ ` (to indicate that a player can speak the tagged language), and `author_tag_` (provided by a world author for search and sorting) exist as well.
 */
type Tag = string;
/**
 * AvatarID
 */
type AvatarId = string;
/**
 * CurrentAvatarImageUrl
 * When profilePicOverride is not empty, use it instead.
 */
type CurrentAvatarImageUrl = string;
/**
 * CurrentAvatarThumbnailImageUrl
 * When profilePicOverride is not empty, use it instead.
 */
type CurrentAvatarThumbnailImageUrl = string;
/**
 * DeveloperType
 * "none" User is a normal user
 * "trusted" Unknown
 * "internal" Is a VRChat Developer
 * "moderator" Is a VRChat Moderator
 *
 * Staff can hide their developerType at will.
 */
type DeveloperType = 'none' | 'trusted' | 'internal' | 'moderator';
/**
 * DiscordID
 * https://discord.com/developers/docs/reference#snowflakes
 */
type DiscordId = string;
/**
 * DiscordDetails
 */
type DiscordDetails = {
    global_name?: string;
    id?: DiscordId;
};
/**
 * WorldID
 * WorldID be "offline" on User profiles if you are not friends with that user.
 */
type WorldId = string;
/**
 * Platform
 * This can be `standalonewindows` or `android`, but can also pretty much be any random Unity verison such as `2019.2.4-801-Release` or `2019.2.2-772-Release` or even `unknownplatform`.
 */
type Platform = string;
/**
 * PastDisplayName
 */
type PastDisplayName = {
    displayName: string;
    updated_at: Date;
};
/**
 * GroupID
 */
type GroupId = string;
/**
 * LocationID
 * Represents a unique location, consisting of a world identifier and an instance identifier, or "offline" if the user is not on your friends list.
 */
type LocationId = string;
/**
 * CurrentUserPresence
 */
type CurrentUserPresence = {
    avatarThumbnail?: string | null;
    currentAvatarTags?: string;
    displayName?: string;
    debugflag?: string;
    groups?: Array<GroupId> | null;
    id?: UserId;
    instance?: string | null;
    /**
     * either an InstanceType or an empty string
     */
    instanceType?: string | null;
    isRejoining?: string | null;
    /**
     * either a Platform or an empty string
     */
    platform?: string | null;
    profilePicOverride?: string | null;
    /**
     * either a UserStatus or empty string
     */
    status?: string | null;
    travelingToInstance?: string | null;
    travelingToWorld?: LocationId;
    userIcon?: string | null;
    world?: WorldId;
};
/**
 * UserState
 * * "online" User is online in VRChat
 * * "active" User is online, but not in VRChat
 * * "offline" User is offline
 *
 * Always offline when returned through `getCurrentUser` (/auth/user).
 */
type UserState = 'offline' | 'active' | 'online';
/**
 * UserStatus
 * Defines the User's current status, for example "ask me", "join me" or "offline. This status is a combined indicator of their online activity and privacy preference.
 */
type UserStatus = 'active' | 'join me' | 'ask me' | 'busy' | 'offline';
/**
 * CurrentUser
 */
type CurrentUser = {
    acceptedTOSVersion: number;
    acceptedPrivacyVersion?: number;
    accountDeletionDate?: Date | null;
    /**
     *
     */
    accountDeletionLog?: Array<AccountDeletionLog> | null;
    /**
     *
     */
    activeFriends?: Array<UserId>;
    ageVerificationStatus: AgeVerificationStatus;
    ageVerified: AgeVerified;
    allowAvatarCopying: boolean;
    /**
     * The auth token for NEWLY REGISTERED ACCOUNTS ONLY (/auth/register)
     */
    authToken?: string;
    /**
     *
     */
    badges?: Array<Badge>;
    bio: string;
    /**
     *
     */
    bioLinks: Array<string>;
    /**
     * These tags begin with `content_` and control content gating
     */
    contentFilters?: Array<Tag>;
    currentAvatar: AvatarId;
    currentAvatarImageUrl: CurrentAvatarImageUrl;
    currentAvatarThumbnailImageUrl: CurrentAvatarThumbnailImageUrl;
    currentAvatarTags: Array<Tag>;
    date_joined: Date;
    developerType: DeveloperType;
    discordDetails?: DiscordDetails;
    discordId?: DiscordId;
    displayName: string;
    emailVerified: boolean;
    fallbackAvatar?: AvatarId;
    /**
     * Always empty array.
     * @deprecated
     */
    friendGroupNames: Array<string>;
    friendKey: string;
    friends: Array<UserId>;
    hasBirthday: boolean;
    hideContentFilterSettings?: boolean;
    userLanguage?: string | null;
    userLanguageCode?: string | null;
    hasEmail: boolean;
    hasLoggedInFromClient: boolean;
    hasPendingEmail: boolean;
    homeLocation: WorldId;
    id: UserId;
    isAdult: boolean;
    isBoopingEnabled?: boolean;
    isFriend: boolean;
    last_activity?: Date;
    last_login: Date;
    last_mobile: Date | null;
    last_platform: Platform;
    obfuscatedEmail: string;
    obfuscatedPendingEmail: string;
    oculusId: string;
    googleId?: string;
    googleDetails?: {
        [key: string]: unknown;
    };
    picoId?: string;
    viveId?: string;
    offlineFriends?: Array<UserId>;
    onlineFriends?: Array<UserId>;
    /**
     *
     */
    pastDisplayNames: Array<PastDisplayName>;
    presence?: CurrentUserPresence;
    platform_history?: Array<{
        isMobile?: boolean;
        platform?: string | null;
        recorded?: Date;
    }>;
    profilePicOverride: string;
    profilePicOverrideThumbnail: string;
    pronouns: string;
    pronounsHistory: Array<string>;
    queuedInstance?: string | null;
    receiveMobileInvitations?: boolean;
    state: UserState;
    status: UserStatus;
    statusDescription: string;
    statusFirstTime: boolean;
    statusHistory: Array<string>;
    steamDetails: {
        [key: string]: unknown;
    };
    steamId: string;
    tags: Array<Tag>;
    twoFactorAuthEnabled: boolean;
    twoFactorAuthEnabledDate?: Date | null;
    unsubscribe: boolean;
    updated_at?: Date;
    userIcon: string;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @deprecated
     */
    username?: string;
};
/**
 * Disable2FAResult
 */
type Disable2FaResult = {
    removed: boolean;
};
/**
 * TwoFactorAuthCode
 */
type TwoFactorAuthCode = {
    code: string;
};
/**
 * Verify2FAResult
 */
type Verify2FaResult = {
    verified: boolean;
    enabled?: boolean;
};
/**
 * Pending2FAResult
 */
type Pending2FaResult = {
    qrCodeDataUrl: string;
    secret: string;
};
/**
 * TwoFactorRecoveryCodes
 */
type TwoFactorRecoveryCodes = {
    requiresTwoFactorAuth?: Array<string>;
    otp?: Array<{
        code: string;
        used: boolean;
    }>;
};
/**
 * TwoFactorEmailCode
 */
type TwoFactorEmailCode = {
    code: string;
};
/**
 * Verify2FAEmailCodeResult
 */
type Verify2FaEmailCodeResult = {
    verified: boolean;
};
/**
 * VerifyAuthTokenResult
 */
type VerifyAuthTokenResult = {
    ok: boolean;
    token: string;
};
/**
 * Success
 */
type Success = {
    success?: Response$1;
};
/**
 * RegisterUserAccountRequest
 */
type RegisterUserAccountRequest = {
    /**
     * Display Name / Username (Username is a sanitized version)
     */
    username: string;
    /**
     * Password
     */
    password: string;
    /**
     * Email address
     */
    email: string;
    /**
     * Birth year
     */
    year: string;
    /**
     * Birth month of year
     */
    month: string;
    /**
     * Birth day of month
     */
    day: string;
    /**
     * Captcha code
     */
    captchaCode: string;
    /**
     * Whether to recieve promotional emails
     */
    subscribe: boolean;
    /**
     * The most recent version of the TOS
     */
    acceptedTOSVersion: number;
};
/**
 * AvatarModerationType
 */
type AvatarModerationType = 'block';
/**
 * AvatarModeration
 */
type AvatarModeration = {
    avatarModerationType: AvatarModerationType;
    created: Date;
    targetAvatarId: AvatarId;
};
/**
 * ReleaseStatus
 */
type ReleaseStatus = 'public' | 'private' | 'hidden' | 'all';
/**
 * UnityPackageID
 */
type UnityPackageId = string;
/**
 * PerformanceRatings
 * Avatar Performance ratings.
 */
type PerformanceRatings = 'None' | 'Excellent' | 'Good' | 'Medium' | 'Poor' | 'VeryPoor';
/**
 * UnityPackage
 */
type UnityPackage = {
    id: UnityPackageId;
    assetUrl?: string | null;
    assetUrlObject?: {
        [key: string]: unknown;
    };
    assetVersion: number;
    created_at?: Date;
    impostorizerVersion?: string;
    performanceRating?: PerformanceRatings;
    platform: Platform;
    pluginUrl?: string;
    pluginUrlObject?: {
        [key: string]: unknown;
    };
    unitySortNumber?: bigint;
    unityVersion: string;
    worldSignature?: string | null;
    impostorUrl?: string | null;
    scanStatus?: string;
    variant?: string;
};
/**
 * Avatar
 */
type Avatar = {
    acknowledgements?: string;
    /**
     * Not present from general search `/avatars`, only on specific requests `/avatars/{avatarId}`.
     */
    assetUrl?: string;
    /**
     * Not present from general search `/avatars`, only on specific requests `/avatars/{avatarId}`.
     * **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead.
     */
    assetUrlObject?: {
        [key: string]: unknown;
    };
    authorId: UserId;
    authorName: string;
    created_at: Date;
    description: string;
    featured: boolean;
    highestPrice?: number;
    id: AvatarId;
    imageUrl: string;
    listingDate: string | null;
    lock?: boolean;
    lowestPrice?: number;
    name: string;
    performance: {
        android?: string;
        'android-sort'?: number;
        ios?: string;
        'ios-sort'?: number;
        standalonewindows?: string;
        'standalonewindows-sort'?: number;
    };
    productId?: string;
    publishedListings?: Array<{
        description?: string;
        displayName?: string;
        imageId?: string;
        listingId?: string;
        listingType?: string;
        priceTokens?: number;
    }>;
    releaseStatus: ReleaseStatus;
    searchable?: boolean;
    styles: {
        primary?: string | null;
        secondary?: string | null;
        supplementary?: Array<string>;
    };
    /**
     *
     */
    tags: Array<Tag>;
    thumbnailImageUrl: string;
    unityPackageUrl: string;
    /**
     * **Deprecation:** `Object` has unknown usage/fields, and is always empty. Use normal `Url` field instead.
     * @deprecated
     */
    unityPackageUrlObject: {
        unityPackageUrl?: string;
    };
    unityPackages: Array<UnityPackage>;
    updated_at: Date;
    version: number;
};
/**
 * SortOption
 */
type SortOption = 'popularity' | 'heat' | 'trust' | 'shuffle' | 'random' | 'favorites' | 'reportScore' | 'reportCount' | 'publicationDate' | 'labsPublicationDate' | 'created' | '_created_at' | 'updated' | '_updated_at' | 'order' | 'relevance' | 'magic' | 'name';
/**
 * OrderOption
 */
type OrderOption = 'ascending' | 'descending';
/**
 * LocalDateTime
 * A date and time of the pattern `M/d/yyyy h:mm:ss tt` (see C Sharp `System.DateTime`)
 */
type LocalDateTime = string;
/**
 * CreateAvatarRequest
 */
type CreateAvatarRequest = {
    assetUrl?: string;
    assetVersion?: string;
    platform?: Platform;
    created_at?: LocalDateTime;
    updated_at?: LocalDateTime;
    id?: AvatarId;
    name: string;
    description?: string;
    /**
     *
     */
    tags?: Array<Tag>;
    imageUrl: string;
    thumbnailImageUrl?: string;
    releaseStatus?: ReleaseStatus;
    version?: number;
    /**
     * Enabling featured tag requires Admin Credentials.
     */
    featured?: boolean;
    unityPackageUrl?: string;
    unityVersion?: string;
};
/**
 * AvatarStyleID
 */
type AvatarStyleId = string;
/**
 * AvatarStyle
 */
type AvatarStyle = {
    id: AvatarStyleId;
    styleName: string;
};
/**
 * UpdateAvatarRequest
 */
type UpdateAvatarRequest = {
    assetUrl?: string;
    id?: AvatarId;
    name?: string;
    description?: string;
    /**
     *
     */
    tags?: Array<Tag>;
    imageUrl?: string;
    releaseStatus?: ReleaseStatus;
    version?: number;
    /**
     * Enabling featured tag requires Admin Credentials.
     */
    featured?: boolean;
    unityPackageUrl?: string;
    unityVersion?: string;
};
/**
 * ServiceStatus
 * Status information for a service request
 */
type ServiceStatus = {
    created_at: Date;
    /**
     * The id of this service, NOT the id of the thing this service was requested for.
     */
    id: string;
    progress: Array<{
        [key: string]: unknown;
    }>;
    requesterUserId: UserId;
    state: string;
    /**
     * The id of the thing this service was requested for.
     */
    subjectId: string;
    /**
     * The kind of the thing this service was requested for.
     */
    subjectType: string;
    /**
     * The kind of service that was requested.
     */
    type: string;
    updated_at: Date;
};
/**
 * ServiceQueueStats
 * Statistics about the user's currently queued service request
 */
type ServiceQueueStats = {
    estimatedServiceDurationSeconds: number;
};
/**
 * CalendarID
 */
type CalendarId = string;
/**
 * FileID
 */
type FileId = string;
/**
 * GroupRoleID
 */
type GroupRoleId = string;
/**
 * CalendarEvent
 */
type CalendarEvent = {
    accessType: string;
    category: string;
    closeInstanceAfterEndMinutes?: number;
    createdAt?: Date;
    deletedAt?: Date | null;
    description: string;
    endsAt: Date;
    featured?: boolean;
    guestEarlyJoinMinutes?: number;
    hostEarlyJoinMinutes?: number;
    id: CalendarId;
    imageId?: FileId;
    imageUrl?: string | null;
    interestedUserCount?: number;
    isDraft?: boolean;
    /**
     *
     */
    languages?: Array<string>;
    ownerId?: GroupId;
    /**
     *
     */
    platforms?: Array<string>;
    /**
     *
     */
    roleIds?: Array<GroupRoleId> | null;
    startsAt: Date;
    /**
     *
     */
    tags?: Array<Tag>;
    title: string;
    type?: string;
    updatedAt?: Date;
    usesInstanceOverflow?: boolean;
    userInterest?: {
        createdAt?: Date;
        isFollowing?: boolean;
        updatedAt?: Date;
    };
};
/**
 * PaginatedCalendarEventList
 */
type PaginatedCalendarEventList = {
    /**
     *
     */
    results?: Array<CalendarEvent>;
    /**
     * The total number of results that the query would return if there were no pagination.
     */
    totalCount?: number;
    /**
     * Whether there are more results after this page.
     */
    hasNext?: boolean;
};
/**
 * CreateCalendarEventRequest
 */
type CreateCalendarEventRequest = {
    /**
     * Event title
     */
    title: string;
    /**
     * Time the event starts at
     */
    startsAt: Date;
    description: string;
    /**
     * Time the event ends at
     */
    endsAt: Date;
    category: string;
    tags?: Array<string>;
    isDraft?: boolean;
    imageId?: FileId;
    roleIds?: Array<string>;
    parentId?: string;
    platforms?: Array<string>;
    languages?: Array<string>;
    /**
     * Send notification to group members.
     */
    sendCreationNotification: boolean;
    featured?: boolean;
    hostEarlyJoinMinutes?: number;
    guestEarlyJoinMinutes?: number;
    closeInstanceAfterEndMinutes?: number;
    usesInstanceOverflow?: boolean;
    accessType: 'public' | 'group';
};
/**
 * UpdateCalendarEventRequest
 */
type UpdateCalendarEventRequest = {
    /**
     * Event title
     */
    title?: string;
    /**
     * Time the vent starts at
     */
    startsAt?: Date;
    description?: string;
    /**
     * Time the vent starts at
     */
    endsAt?: Date;
    category?: string;
    tags?: Array<string>;
    isDraft?: boolean;
    imageId?: FileId;
    roleIds?: Array<string>;
    parentId?: string;
    platforms?: Array<string>;
    languages?: Array<string>;
    /**
     * Send notification to group members.
     */
    sendCreationNotification?: boolean;
    featured?: boolean;
    hostEarlyJoinMinutes?: number;
    guestEarlyJoinMinutes?: number;
    closeInstanceAfterEndMinutes?: number;
    usesInstanceOverflow?: boolean;
};
/**
 * FollowCalendarEventRequest
 */
type FollowCalendarEventRequest = {
    isFollowing: boolean;
};
/**
 * TransactionID
 */
type TransactionId = string;
/**
 * TransactionStatus
 */
type TransactionStatus = 'active' | 'failed' | 'expired' | 'chargeback';
/**
 * SubscriptionPeriod
 */
type SubscriptionPeriod = 'hour' | 'day' | 'week' | 'month' | 'year';
/**
 * Subscription
 */
type Subscription = {
    id: string;
    steamItemId: string;
    oculusSku?: string;
    googleProductId?: string;
    googlePlanId?: string;
    picoSku?: string;
    appleProductId?: string;
    amount: number;
    description: string;
    period: SubscriptionPeriod;
    tier: number;
};
/**
 * TransactionSteamWalletInfo
 */
type TransactionSteamWalletInfo = {
    state: string;
    country: string;
    currency: string;
    status: string;
};
/**
 * TransactionSteamInfo
 */
type TransactionSteamInfo = {
    walletInfo: TransactionSteamWalletInfo;
    /**
     * Steam User ID
     */
    steamId: string;
    /**
     * Steam Order ID
     */
    orderId: string;
    /**
     * Empty
     */
    steamUrl: string;
    /**
     * Steam Transaction ID, NOT the same as VRChat TransactionID
     */
    transId: string;
};
/**
 * TransactionAgreement
 * Represents a single Transaction, which is likely between VRChat and Steam.
 */
type TransactionAgreement = {
    agreementId: string;
    itemId: number;
    agreement: string;
    /**
     * This is NOT TransactionStatus, but whatever Steam return.
     */
    status: string;
    period: string;
    frequency: number;
    billingType: string;
    startDate: string;
    endDate: string;
    recurringAmt: number;
    currency: string;
    timeCreated: string;
    nextPayment: string;
    lastPayment: string;
    lastAmount: number;
    lastAmountVat: number;
    outstanding: number;
    failedAttempts: number;
};
/**
 * Transaction
 */
type Transaction = {
    id: TransactionId;
    userId?: UserId;
    userDisplayName?: string;
    status: TransactionStatus;
    subscription: Subscription;
    sandbox: boolean;
    created_at: Date;
    updated_at: Date;
    steam?: TransactionSteamInfo;
    agreement?: TransactionAgreement;
    error: string | null;
    isGift?: boolean;
    isTokens?: boolean;
};
/**
 * LicenseGroupID
 */
type LicenseGroupId = string;
/**
 * UserSubscription
 */
type UserSubscription = {
    id: string;
    transactionId: TransactionId;
    /**
     * Which "Store" it came from. Right now only Stores are "Steam" and "Admin".
     */
    store: string;
    steamItemId?: string;
    amount: number;
    description: string;
    period: SubscriptionPeriod;
    tier: number;
    active: boolean;
    status: TransactionStatus;
    starts?: string;
    expires: Date;
    created_at: Date;
    updated_at: Date;
    licenseGroups: Array<LicenseGroupId>;
    isGift: boolean;
    isBulkGift: boolean;
};
/**
 * UserSubscriptionEligible
 */
type UserSubscriptionEligible = {
    activeCancelledSubscription: boolean;
    giftEligible: boolean;
    nonExtendVendorWillLoseGiftTime: boolean;
    purchaseEligible: boolean;
    subscriptionEligible: boolean;
    subscriptionOnAltAccount: boolean;
};
/**
 * LicenseType
 */
type LicenseType = 'avatar' | 'licenseGroup' | 'permission' | 'product';
/**
 * LicenseAction
 */
type LicenseAction = 'wear' | 'have';
/**
 * License
 */
type License = {
    /**
     * Either a AvatarID, LicenseGroupID, PermissionID or ProductID. This depends on the `forType` field.
     */
    forId: string;
    forType: LicenseType;
    forName: string;
    forAction: LicenseAction;
};
/**
 * LicenseGroup
 */
type LicenseGroup = {
    id: LicenseGroupId;
    name: string;
    description: string;
    licenses: Array<License>;
};
/**
 * ProductID
 */
type ProductId = string;
/**
 * ProductType
 */
type ProductType = 'listing' | 'role' | 'udon';
/**
 * Product
 */
type Product = {
    archived: boolean;
    created: Date;
    description: string;
    displayName: string;
    groupAccess?: boolean;
    groupAccessRemove?: boolean;
    groupId?: GroupId;
    groupRoleId?: GroupRoleId;
    id: ProductId;
    imageId: FileId;
    parentListings: Array<ProductId>;
    productType: ProductType;
    sellerDisplayName: string;
    sellerId: string;
    tags: Array<Tag>;
    updated: Date | null;
    useForSubscriberList?: boolean;
};
/**
 * ProductListingType
 */
type ProductListingType = 'subscription';
/**
 * ProductListingVariantID
 */
type ProductListingVariantId = string;
/**
 * ProductListingVariant
 */
type ProductListingVariant = {
    effectiveFrom?: Date;
    listingVariantId: ProductListingVariantId;
    nonRefundable: boolean;
    quantity: number;
    sellerVariant: boolean;
    unitPriceTokens: number;
};
/**
 * Listing
 */
type ProductListing = {
    active: boolean;
    buyerRefundable: boolean;
    description: string;
    displayName: string;
    duration?: number | null;
    durationType?: string | null;
    groupIcon?: FileId;
    groupId?: GroupId;
    groupName?: string | null;
    hasAvatar: boolean;
    hasUdon: boolean;
    hydratedProducts?: Array<Product>;
    id: ProductId;
    imageId?: FileId;
    imageUrl?: string | null;
    listingType: ProductListingType;
    listingVariants?: Array<ProductListingVariant>;
    permanent?: boolean;
    priceTokens: number;
    productIds: Array<ProductId>;
    productType: ProductType;
    products: Array<{
        [key: string]: unknown;
    }>;
    quantifiable?: boolean;
    recurrable: boolean;
    refundable: boolean;
    sellerDisplayName: string;
    sellerId: string;
    stackable: boolean;
    storeIds: Array<string>;
    tags?: Array<Tag>;
};
/**
 * TokenBundle
 */
type TokenBundle = {
    id: string;
    appleProductId: string;
    steamItemId: string;
    oculusSku: string;
    googleProductId?: string;
    /**
     * price of the bundle
     */
    amount: number;
    description: string;
    /**
     * number of tokens received
     */
    tokens: number;
    /**
     * direct url to image
     */
    imageUrl: string;
};
/**
 * TiliaStatus
 */
type TiliaStatus = {
    economyOnline: boolean;
    economyState?: number;
    plannedOfflineWindowStart?: Date;
    plannedOfflineWindowEnd?: Date;
};
/**
 * TiliaTOS
 */
type TiliaTos = {
    signed_tos: boolean;
};
/**
 * Balance
 */
type Balance = {
    balance: number;
    noTransactions?: boolean;
    tiliaResponse?: boolean;
};
/**
 * EconomyAccount
 */
type EconomyAccount = {
    accountActivatedOn: Date | null;
    accountId: string | null;
    blocked: boolean;
    canSpend: boolean;
    source: string;
    userId: UserId;
};
/**
 * StoreID
 */
type StoreId = string;
/**
 * StoreType
 */
type StoreType = 'house' | 'world' | 'group';
/**
 * StoreShelfID
 */
type StoreShelfId = string;
/**
 * StoreShelf
 */
type StoreShelf = {
    id: StoreShelfId;
    listingIds: Array<ProductId>;
    listings?: Array<ProductListing>;
    shelfDescription: string;
    shelfLayout: string;
    shelfTitle: string;
    updatedAt: string;
};
/**
 * Store
 */
type Store = {
    description: string;
    displayName: string;
    id: StoreId;
    sellerDisplayName: string;
    sellerId: UserId;
    storeId: StoreId;
    storeType: StoreType;
    tags: Array<Tag>;
    /**
     * Only for store type world and group
     */
    listingIds?: Array<ProductId>;
    /**
     * Only for store type world and group
     */
    listings?: Array<ProductListing>;
    worldId?: WorldId;
    groupId?: GroupId;
    /**
     * Only for store type house
     */
    shelfIds?: Array<StoreShelfId>;
    /**
     * Only for store type house
     */
    shelves?: Array<StoreShelf>;
};
/**
 * StoreView
 */
type StoreView = 'all' | 'publicPreview' | 'public' | 'preview' | 'draft';
/**
 * FavoriteID
 */
type FavoriteId = string;
/**
 * FavoriteType
 */
type FavoriteType = 'world' | 'friend' | 'avatar';
/**
 * Favorite
 */
type Favorite = {
    /**
     * MUST be either AvatarID, UserID or WorldID.
     */
    favoriteId: string;
    id: FavoriteId;
    /**
     *
     */
    tags: Array<Tag>;
    type: FavoriteType;
};
/**
 * AddFavoriteRequest
 */
type AddFavoriteRequest = {
    type: FavoriteType;
    /**
     * Must be either AvatarID, WorldID or UserID.
     */
    favoriteId: string;
    /**
     * Tags indicate which group this favorite belongs to. Adding multiple groups makes it show up in all. Removing it from one in that case removes it from all.
     */
    tags: Array<Tag>;
};
/**
 * FavoriteGroupID
 */
type FavoriteGroupId = string;
/**
 * FavoriteGroupVisibility
 */
type FavoriteGroupVisibility = 'private' | 'friends' | 'public';
/**
 * FavoriteGroup
 */
type FavoriteGroup = {
    displayName: string;
    id: FavoriteGroupId;
    name: string;
    ownerDisplayName: string;
    ownerId: UserId;
    /**
     *
     */
    tags: Array<Tag>;
    type: FavoriteType;
    visibility: FavoriteGroupVisibility;
};
/**
 * UpdateFavoriteGroupRequest
 */
type UpdateFavoriteGroupRequest = {
    displayName?: string;
    visibility?: FavoriteGroupVisibility;
    /**
     * Tags on FavoriteGroups are believed to do nothing.
     */
    tags?: Array<Tag>;
};
/**
 * FavoriteGroupLimits
 */
type FavoriteGroupLimits = {
    avatar: number;
    friend: number;
    world: number;
};
/**
 * FavoriteLimits
 */
type FavoriteLimits = {
    defaultMaxFavoriteGroups: number;
    defaultMaxFavoritesPerGroup: number;
    maxFavoriteGroups: FavoriteGroupLimits;
    maxFavoritesPerGroup: FavoriteGroupLimits;
};
/**
 * MIMEType
 */
type MimeType = 'image/jpeg' | 'image/jpg' | 'image/png' | 'image/webp' | 'image/gif' | 'image/bmp' | 'image/svgï¼‹xml' | 'image/tiff' | 'application/x-avatar' | 'application/x-world' | 'application/gzip' | 'application/x-rsync-signature' | 'application/x-rsync-delta' | 'application/octet-stream';
/**
 * FileStatus
 */
type FileStatus = 'waiting' | 'complete' | 'none' | 'queued';
/**
 * FileData
 */
type FileData = {
    category: 'multipart' | 'queued' | 'simple';
    fileName: string;
    md5?: string;
    sizeInBytes: number;
    status: FileStatus;
    uploadId: string;
    url: string;
};
/**
 * FileVersion
 */
type FileVersion = {
    created_at: Date;
    /**
     * Usually only present if `true`
     */
    deleted?: boolean;
    delta?: FileData;
    file?: FileData;
    signature?: FileData;
    status: FileStatus;
    /**
     * Incremental version counter, can only be increased.
     */
    version: number;
};
/**
 * File
 */
type File = {
    animationStyle?: string;
    maskTag?: string;
    extension: string;
    id: FileId;
    mimeType: MimeType;
    name: string;
    ownerId: UserId;
    /**
     *
     */
    tags: Array<Tag>;
    /**
     *
     */
    versions: Array<FileVersion>;
};
/**
 * CreateFileRequest
 */
type CreateFileRequest = {
    name: string;
    mimeType: MimeType;
    extension: string;
    /**
     *
     */
    tags?: Array<Tag>;
};
/**
 * CreateFileVersionRequest
 */
type CreateFileVersionRequest = {
    signatureMd5: string;
    signatureSizeInBytes: number;
    fileMd5?: string;
    fileSizeInBytes?: number;
};
/**
 * FinishFileDataUploadRequest
 */
type FinishFileDataUploadRequest = {
    /**
     * Array of ETags uploaded.
     */
    etags?: Array<string>;
    /**
     * Always a zero in string form, despite how many parts uploaded.
     * @deprecated
     */
    nextPartNumber: string;
    /**
     * Always a zero in string form, despite how many parts uploaded.
     * @deprecated
     */
    maxParts: string;
};
/**
 * FileUploadURL
 */
type FileUploadUrl = {
    url: string;
};
/**
 * FileVersionUploadStatus
 */
type FileVersionUploadStatus = {
    uploadId: string;
    fileName: string;
    nextPartNumber: number;
    maxParts: number;
    parts: Array<{
        [key: string]: unknown;
    }>;
    /**
     * Unknown
     */
    etags: Array<{
        [key: string]: unknown;
    }>;
};
/**
 * FileAnalysisAvatarStats
 */
type FileAnalysisAvatarStats = {
    animatorCount: number;
    audioSourceCount: number;
    blendShapeCount: number;
    boneCount: number;
    bounds: Array<number>;
    cameraCount?: number;
    clothCount: number;
    constraintCount: number;
    constraintDepth: number;
    contactCount: number;
    customExpressions: boolean;
    customizeAnimationLayers: boolean;
    enableEyeLook: boolean;
    lightCount: number;
    lineRendererCount: number;
    lipSync: number;
    materialCount: number;
    materialSlotsUsed: number;
    meshCount: number;
    meshIndices: number;
    meshParticleMaxPolygons: number;
    meshPolygons: number;
    meshVertices: number;
    particleCollisionEnabled: boolean;
    particleSystemCount: number;
    particleTrailsEnabled: boolean;
    physBoneColliderCount: number;
    physBoneCollisionCheckCount: number;
    physBoneComponentCount: number;
    physBoneTransformCount: number;
    physicsColliders: number;
    physicsRigidbodies: number;
    skinnedMeshCount: number;
    skinnedMeshIndices: number;
    skinnedMeshPolygons: number;
    skinnedMeshVertices: number;
    totalClothVertices: number;
    totalIndices: number;
    totalMaxParticles: number;
    totalPolygons: number;
    totalTextureUsage: number;
    totalVertices: number;
    trailRendererCount: number;
    writeDefaultsUsed: boolean;
};
/**
 * FileAnalysis
 */
type FileAnalysis = {
    avatarStats: FileAnalysisAvatarStats;
    created_at?: Date;
    encryptionKey?: string;
    fileSize: number;
    performanceRating?: string;
    success: boolean;
    uncompressedSize: number;
};
/**
 * AdminUnityPackage
 */
type AdminUnityPackage = {
    assetUrl: string;
    assetVersion: number;
    platform: Platform;
    unityVersion: string;
    variant: string;
};
/**
 * AdminAssetBundle
 */
type AdminAssetBundle = {
    _created_at: Date;
    _updated_at: Date;
    assetType: string;
    authorId: UserId;
    authorName: string;
    description: string;
    imageUrl: string;
    name: string;
    releaseStatus: ReleaseStatus;
    tags: Array<Tag>;
    thumbnailImageUrl: string;
    unityPackageUrl: string | null;
    unityPackages: Array<AdminUnityPackage>;
};
/**
 * LimitedUserFriend
 * User object received when querying your friends list
 */
type LimitedUserFriend = {
    bio?: string;
    /**
     *
     */
    bioLinks?: Array<string>;
    currentAvatarImageUrl?: CurrentAvatarImageUrl;
    currentAvatarThumbnailImageUrl?: CurrentAvatarThumbnailImageUrl;
    currentAvatarTags?: Array<Tag>;
    developerType: DeveloperType;
    displayName: string;
    friendKey: string;
    id: UserId;
    isFriend: boolean;
    imageUrl: string;
    last_platform: Platform;
    location: string;
    last_login: Date | null;
    last_activity: Date | null;
    last_mobile: Date | null;
    platform: string;
    profilePicOverride?: string;
    profilePicOverrideThumbnail?: string;
    status: UserStatus;
    statusDescription: string;
    /**
     * <- Always empty.
     */
    tags: Array<Tag>;
    userIcon?: string;
};
/**
 * NotificationType
 */
type NotificationType = 'friendRequest' | 'invite' | 'inviteResponse' | 'message' | 'requestInvite' | 'requestInviteResponse' | 'votetokick';
/**
 * Notification
 */
type Notification = {
    created_at: Date;
    /**
     * **NOTICE:** This is not a JSON object when received from the REST API, but it is when received from the Websocket API. When received from the REST API, this is a json **encoded** object, meaning you have to json-de-encode to get the NotificationDetail object depending on the NotificationType.
     */
    details: string;
    id: string;
    message: string;
    /**
     * Not included in notification objects received from the Websocket API
     */
    seen?: boolean;
    receiverUserId?: UserId;
    senderUserId: UserId;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @deprecated
     */
    senderUsername?: string;
    type: NotificationType;
};
/**
 * FriendStatus
 */
type FriendStatus = {
    incomingRequest: boolean;
    isFriend: boolean;
    outgoingRequest: boolean;
};
/**
 * GroupShortCode
 */
type GroupShortCode = string;
/**
 * GroupDiscriminator
 */
type GroupDiscriminator = string;
type GroupMemberStatus = 'inactive' | 'member' | 'requested' | 'invited' | 'banned' | 'userblocked';
/**
 * GroupGalleryID
 */
type GroupGalleryId = string;
/**
 * GroupMember
 */
type GroupGallery = {
    id?: GroupGalleryId;
    /**
     * Name of the gallery.
     */
    name?: string;
    /**
     * Description of the gallery.
     */
    description?: string;
    /**
     * Whether the gallery is members only.
     */
    membersOnly?: boolean;
    /**
     *
     */
    roleIdsToView?: Array<GroupRoleId> | null;
    /**
     *
     */
    roleIdsToSubmit?: Array<GroupRoleId> | null;
    /**
     *
     */
    roleIdsToAutoApprove?: Array<GroupRoleId> | null;
    /**
     *
     */
    roleIdsToManage?: Array<GroupRoleId> | null;
    createdAt?: Date;
    updatedAt?: Date;
};
/**
 * LimitedGroup
 */
type LimitedGroup = {
    id?: GroupId;
    name?: string;
    shortCode?: GroupShortCode;
    discriminator?: GroupDiscriminator;
    description?: string;
    iconUrl?: string | null;
    bannerUrl?: string | null;
    ownerId?: UserId;
    rules?: string | null;
    iconId?: string | null;
    bannerId?: string | null;
    memberCount?: number;
    /**
     *
     */
    tags?: Array<Tag>;
    createdAt?: Date;
    membershipStatus?: GroupMemberStatus;
    isSearchable?: boolean;
    /**
     *
     */
    galleries?: Array<GroupGallery>;
};
/**
 * GroupJoinState
 */
type GroupJoinState = 'closed' | 'invite' | 'request' | 'open';
/**
 * GroupPrivacy
 */
type GroupPrivacy = 'default' | 'private';
/**
 * GroupRoleTemplate
 */
type GroupRoleTemplate = 'default' | 'managedFree' | 'managedInvite' | 'managedRequest';
/**
 * CreateGroupRequest
 */
type CreateGroupRequest = {
    name: string;
    shortCode: string;
    description?: string;
    joinState?: GroupJoinState;
    iconId?: string | null;
    bannerId?: string | null;
    privacy?: GroupPrivacy;
    roleTemplate: GroupRoleTemplate;
};
/**
 * GroupMemberID
 */
type GroupMemberId = string;
/**
 * GroupPermissions
 */
type GroupPermissions = '*' | 'group-announcement-manage' | 'group-audit-view' | 'group-bans-manage' | 'group-data-manage' | 'group-default-role-manage' | 'group-galleries-manage' | 'group-instance-age-gated-create' | 'group-instance-join' | 'group-instance-manage' | 'group-instance-moderate' | 'group-instance-open-create' | 'group-instance-plus-create' | 'group-instance-plus-portal' | 'group-instance-plus-portal-unlocked' | 'group-instance-public-create' | 'group-instance-queue-priority' | 'group-instance-restricted-create' | 'group-invites-manage' | 'group-members-manage' | 'group-members-remove' | 'group-members-viewall' | 'group-roles-assign' | 'group-roles-manage' | 'group-calendar-manage' | 'group-instance-calendar-link';
/**
 * GroupMyMember
 */
type GroupMyMember = {
    id?: GroupMemberId;
    groupId?: GroupId;
    userId?: UserId;
    roleIds?: Array<GroupRoleId>;
    acceptedByDisplayName?: string | null;
    acceptedById?: string | null;
    createdAt?: Date;
    managerNotes?: string;
    membershipStatus?: string;
    isSubscribedToAnnouncements?: boolean;
    isSubscribedToEventAnnouncements?: boolean;
    visibility?: string;
    isRepresenting?: boolean;
    joinedAt?: Date;
    bannedAt?: string | null;
    has2FA?: boolean;
    hasJoinedFromPurchase?: boolean;
    lastPostReadAt?: Date | null;
    mRoleIds?: Array<string>;
    permissions?: Array<GroupPermissions>;
};
/**
 * GroupRole
 */
type GroupRole = {
    id?: GroupRoleId;
    groupId?: GroupId;
    name?: string;
    description?: string;
    isSelfAssignable?: boolean;
    permissions?: Array<GroupPermissions>;
    isManagementRole?: boolean;
    requiresTwoFactor?: boolean;
    requiresPurchase?: boolean;
    order?: number;
    createdAt?: Date;
    updatedAt?: Date;
};
/**
 * Group
 */
type Group = {
    ageVerificationSlotsAvailable?: boolean;
    ageVerificationBetaCode?: string;
    ageVerificationBetaSlots?: number;
    badges?: Array<string>;
    id?: GroupId;
    name?: string;
    shortCode?: GroupShortCode;
    discriminator?: GroupDiscriminator;
    description?: string;
    iconUrl?: string | null;
    bannerUrl?: string | null;
    privacy?: GroupPrivacy;
    ownerId?: UserId;
    rules?: string | null;
    links?: Array<string>;
    languages?: Array<string>;
    iconId?: string | null;
    bannerId?: string | null;
    memberCount?: number;
    memberCountSyncedAt?: Date;
    isVerified?: boolean;
    joinState?: GroupJoinState;
    tags?: Array<Tag>;
    transferTargetId?: UserId;
    galleries?: Array<GroupGallery>;
    createdAt?: Date;
    updatedAt?: Date;
    lastPostCreatedAt?: Date | null;
    onlineMemberCount?: number;
    membershipStatus?: GroupMemberStatus;
    myMember?: GroupMyMember;
    /**
     * Only returned if ?includeRoles=true is specified.
     */
    roles?: Array<GroupRole> | null;
};
/**
 * GroupRoleTemplateValues
 */
type GroupRoleTemplateValues = {
    basePermissions: Array<GroupPermissions>;
    description: string;
    name: string;
    roles: {
        description?: string;
        name?: string;
        basePermissions?: Array<GroupPermissions>;
        isAddedOnJoin?: boolean;
    };
};
/**
 * UpdateGroupRequest
 */
type UpdateGroupRequest = {
    name?: string;
    shortCode?: string;
    description?: string;
    joinState?: GroupJoinState;
    iconId?: string | null;
    bannerId?: string | null;
    /**
     * 3 letter language code
     */
    languages?: Array<string>;
    links?: Array<string>;
    rules?: string;
    /**
     *
     */
    tags?: Array<Tag>;
};
/**
 * GroupAnnouncementID
 */
type GroupAnnouncementId = string;
/**
 * GroupAnnouncement
 */
type GroupAnnouncement = {
    id?: GroupAnnouncementId;
    groupId?: GroupId;
    authorId?: UserId;
    title?: string | null;
    text?: string | null;
    imageId?: FileId;
    imageUrl?: string | null;
    createdAt?: Date | null;
    updatedAt?: Date | null;
};
/**
 * CreateGroupAnnouncementRequest
 */
type CreateGroupAnnouncementRequest = {
    /**
     * Announcement title
     */
    title: string;
    /**
     * Announcement text
     */
    text?: string;
    imageId?: FileId;
    /**
     * Send notification to group members.
     */
    sendNotification?: boolean;
};
/**
 * GroupAuditLogID
 */
type GroupAuditLogId = string;
/**
 * GroupAuditLogEntry
 */
type GroupAuditLogEntry = {
    id?: GroupAuditLogId;
    created_at?: Date;
    groupId?: GroupId;
    actorId?: UserId;
    actorDisplayName?: string;
    /**
     * Typically a UserID, GroupID, GroupRoleID, or Location, but could be other types of IDs.
     */
    targetId?: string;
    /**
     * The type of event that occurred. This is a string that is prefixed with the type of object that the event occurred on. For example, a group role update event would be prefixed with `group.role`.
     */
    eventType?: string;
    /**
     * A human-readable description of the event.
     */
    description?: string;
    /**
     * The data associated with the event. The format of this data is dependent on the event type.
     */
    data?: {
        [key: string]: unknown;
    };
};
/**
 * PaginatedGroupAuditLogEntryList
 */
type PaginatedGroupAuditLogEntryList = {
    /**
     *
     */
    results?: Array<GroupAuditLogEntry>;
    /**
     * The total number of results that the query would return if there were no pagination.
     */
    totalCount?: number;
    /**
     * Whether there are more results after this page.
     */
    hasNext?: boolean;
};
/**
 * GroupMemberLimitedUser
 * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
 */
type GroupMemberLimitedUser = {
    id?: UserId;
    displayName?: string;
    thumbnailUrl?: string | null;
    iconUrl?: string;
    profilePicOverride?: string;
    currentAvatarThumbnailImageUrl?: string | null;
    currentAvatarTags?: Array<Tag>;
};
/**
 * GroupMember
 */
type GroupMember = {
    acceptedByDisplayName?: string | null;
    acceptedById?: string | null;
    id?: GroupMemberId;
    groupId?: GroupId;
    userId?: UserId;
    /**
     * Whether the user is representing the group. This makes the group show up above the name tag in-game.
     */
    isRepresenting?: boolean;
    user?: GroupMemberLimitedUser;
    roleIds?: Array<GroupRoleId>;
    mRoleIds?: Array<GroupRoleId>;
    joinedAt?: Date | null;
    membershipStatus?: GroupMemberStatus;
    visibility?: string;
    isSubscribedToAnnouncements?: boolean;
    isSubscribedToEventAnnouncements?: boolean;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    createdAt?: Date | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    bannedAt?: Date | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    managerNotes?: string | null;
    lastPostReadAt?: Date | null;
    hasJoinedFromPurchase?: boolean;
};
/**
 * BanGroupMemberRequest
 */
type BanGroupMemberRequest = {
    userId: UserId;
};
/**
 * CreateGroupGalleryRequest
 */
type CreateGroupGalleryRequest = {
    /**
     * Name of the gallery.
     */
    name: string;
    /**
     * Description of the gallery.
     */
    description?: string;
    /**
     * Whether the gallery is members only.
     */
    membersOnly?: boolean;
    /**
     *
     */
    roleIdsToView?: Array<GroupRoleId> | null;
    /**
     *
     */
    roleIdsToSubmit?: Array<GroupRoleId> | null;
    /**
     *
     */
    roleIdsToAutoApprove?: Array<GroupRoleId> | null;
    /**
     *
     */
    roleIdsToManage?: Array<GroupRoleId> | null;
};
/**
 * GroupGalleryImageID
 */
type GroupGalleryImageId = string;
/**
 * GroupGalleryImage
 */
type GroupGalleryImage = {
    id?: GroupGalleryImageId;
    groupId?: GroupId;
    galleryId?: GroupGalleryId;
    fileId?: FileId;
    imageUrl?: string;
    createdAt?: Date;
    submittedByUserId?: UserId;
    approved?: boolean;
    approvedByUserId?: UserId;
    approvedAt?: Date;
};
/**
 * UpdateGroupGalleryRequest
 */
type UpdateGroupGalleryRequest = {
    /**
     * Name of the gallery.
     */
    name?: string;
    /**
     * Description of the gallery.
     */
    description?: string;
    /**
     * Whether the gallery is members only.
     */
    membersOnly?: boolean;
    /**
     *
     */
    roleIdsToView?: Array<GroupRoleId> | null;
    /**
     *
     */
    roleIdsToSubmit?: Array<GroupRoleId> | null;
    /**
     *
     */
    roleIdsToAutoApprove?: Array<GroupRoleId> | null;
    /**
     *
     */
    roleIdsToManage?: Array<GroupRoleId> | null;
};
/**
 * AddGroupGalleryImageRequest
 */
type AddGroupGalleryImageRequest = {
    fileId: FileId;
};
/**
 * InstanceID
 * InstanceID can be "offline" on User profiles if you are not friends with that user and "private" if you are friends and user is in private instance.
 */
type InstanceId = string;
/**
 * InstanceContentSettings
 * Types of dynamic user content permitted in an instance
 */
type InstanceContentSettings = {
    drones?: boolean;
    emoji?: boolean;
    pedestals?: boolean;
    prints?: boolean;
    stickers?: boolean;
    props?: boolean;
};
/**
 * UdonProductId
 * A unique ID of a Udon Product
 */
type UdonProductId = string;
/**
 * World
 */
type World = {
    authorId: UserId;
    authorName: string;
    capacity: number;
    recommendedCapacity: number;
    created_at: Date;
    defaultContentSettings?: InstanceContentSettings;
    description: string;
    favorites?: number;
    featured: boolean;
    heat: number;
    id: WorldId;
    imageUrl: string;
    /**
     * Will always be an empty list when unauthenticated.
     */
    instances?: Array<[
        unknown,
        unknown
    ]>;
    labsPublicationDate: string;
    name: string;
    namespace?: string;
    /**
     * Will always be `0` when unauthenticated.
     */
    occupants?: number;
    organization: string;
    popularity: number;
    previewYoutubeId?: string | null;
    /**
     * Will always be `0` when unauthenticated.
     */
    privateOccupants?: number;
    /**
     * Will always be `0` when unauthenticated.
     */
    publicOccupants?: number;
    publicationDate: string;
    releaseStatus: ReleaseStatus;
    storeId?: StoreId;
    /**
     *
     */
    tags: Array<Tag>;
    thumbnailImageUrl: string;
    /**
     * Empty if unauthenticated.
     */
    unityPackages?: Array<UnityPackage>;
    updated_at: Date;
    urlList?: Array<string>;
    version: number;
    visits: number;
    udonProducts?: Array<UdonProductId>;
};
/**
 * GroupInstance
 */
type GroupInstance = {
    instanceId: InstanceId;
    location: LocationId;
    world: World;
    memberCount: number;
};
/**
 * CreateGroupInviteRequest
 */
type CreateGroupInviteRequest = {
    userId: UserId;
    confirmOverrideBlock?: boolean;
};
/**
 * GroupSearchSort
 */
type GroupSearchSort = 'joinedAt:asc' | 'joinedAt:desc';
/**
 * GroupLimitedMember
 */
type GroupLimitedMember = {
    id?: GroupMemberId;
    groupId?: GroupId;
    userId?: UserId;
    /**
     * Whether the user is representing the group. This makes the group show up above the name tag in-game.
     */
    isRepresenting?: boolean;
    roleIds?: Array<GroupRoleId>;
    mRoleIds?: Array<GroupRoleId>;
    joinedAt?: Date | null;
    membershipStatus?: GroupMemberStatus;
    visibility?: string;
    isSubscribedToAnnouncements?: boolean;
    isSubscribedToEventAnnouncements?: boolean;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    createdAt?: Date | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    bannedAt?: Date | null;
    /**
     * Only visible via the /groups/:groupId/members endpoint, **not** when fetching a specific user.
     */
    managerNotes?: string | null;
    lastPostReadAt?: Date | null;
    hasJoinedFromPurchase?: boolean;
};
/**
 * GroupUserVisibility
 */
type GroupUserVisibility = 'visible' | 'hidden' | 'friends';
/**
 * UpdateGroupMemberRequest
 */
type UpdateGroupMemberRequest = {
    visibility?: GroupUserVisibility;
    isSubscribedToAnnouncements?: boolean;
    isSubscribedToEventAnnouncements?: boolean;
    managerNotes?: string;
};
/**
 * GroupRoleIDList
 *
 */
type GroupRoleIdList = Array<GroupRoleId>;
/**
 * GroupPermission
 * A permission that can be granted to a role in a group.
 */
type GroupPermission = {
    /**
     * The name of the permission.
     */
    name?: string;
    /**
     * The display name of the permission.
     */
    displayName?: string;
    /**
     * Human-readable description of the permission.
     */
    help?: string;
    /**
     * Whether this permission is a "management" permission.
     */
    isManagementPermission?: boolean;
    /**
     * Whether the user is allowed to add this permission to a role.
     */
    allowedToAdd?: boolean;
};
/**
 * NotificationID
 */
type NotificationId = string;
/**
 * GroupPostVisibility
 */
type GroupPostVisibility = 'group' | 'public';
/**
 * GroupPost
 */
type GroupPost = {
    id?: NotificationId;
    groupId?: GroupId;
    authorId?: UserId;
    editorId?: UserId;
    visibility?: GroupPostVisibility;
    roleId?: GroupRoleIdList;
    title?: string;
    text?: string;
    imageId?: FileId;
    imageUrl?: string | null;
    createdAt?: Date;
    updatedAt?: Date;
};
/**
 * CreateGroupPostRequest
 */
type CreateGroupPostRequest = {
    /**
     * Post title
     */
    title: string;
    /**
     * Post text
     */
    text: string;
    imageId?: FileId;
    /**
     * Send notification to group members.
     */
    sendNotification: boolean;
    roleIds?: GroupRoleIdList;
    visibility: GroupPostVisibility;
};
/**
 * GroupJoinRequestAction
 */
type GroupJoinRequestAction = 'accept' | 'reject';
/**
 * RespondGroupJoinRequest
 */
type RespondGroupJoinRequest = {
    action: GroupJoinRequestAction;
    /**
     * Whether to block the user from requesting again
     */
    block?: boolean;
};
/**
 * CreateGroupRequest
 */
type CreateGroupRoleRequest = {
    id?: string;
    name?: string;
    description?: string;
    isSelfAssignable?: boolean;
    permissions?: Array<GroupPermissions>;
};
/**
 * UpdateGroupRoleRequest
 */
type UpdateGroupRoleRequest = {
    name?: string;
    description?: string;
    isSelfAssignable?: boolean;
    permissions?: Array<GroupPermissions>;
    order?: number;
};
/**
 * InventoryItemType
 */
type InventoryItemType = 'bundle' | 'prop' | 'emoji' | 'sticker';
/**
 * InventoryFlag
 */
type InventoryFlag = 'instantiatable' | 'archivable' | 'consumable' | 'trashable' | 'cloneable' | 'ugc';
/**
 * InventoryItemID
 */
type InventoryItemId = string;
/**
 * InventoryTemplateID
 */
type InventoryTemplateId = string;
/**
 * PropID
 */
type PropId = string;
/**
 * InventoryMetadata
 */
type InventoryMetadata = {
    /**
     * Only in bundles
     */
    inventoryItemsToInstantiate?: Array<InventoryTemplateId>;
    animated?: boolean;
    animationStyle?: string;
    assetBundleId?: string;
    fileId?: string;
    imageUrl?: string;
    maskTag?: string;
    propId?: PropId;
};
/**
 * InventoryItem
 */
type InventoryItem = {
    collections: Array<string>;
    created_at: Date;
    description: string;
    expiryDate: Date | null;
    flags: Array<string>;
    holderId: UserId;
    id: InventoryItemId;
    imageUrl: string;
    isArchived: boolean;
    isSeen: boolean;
    itemType: InventoryItemType;
    itemTypeLabel: string;
    metadata: InventoryMetadata;
    name: string;
    tags: Array<Tag>;
    templateId: InventoryTemplateId;
    template_created_at: Date;
    template_updated_at: Date;
    updated_at: Date;
};
/**
 * Inventory
 */
type Inventory = {
    data: Array<InventoryItem>;
    totalCount: number;
};
/**
 * UpdateInventoryItemRequest
 */
type UpdateInventoryItemRequest = {
    isArchived?: boolean;
};
/**
 * InventoryDropID
 */
type InventoryDropId = string;
/**
 * InventoryNotificationDetails
 */
type InventoryNotificationDetails = {
    body: string;
    imageUrl: string;
    title: string;
};
/**
 * InventoryDrop
 */
type InventoryDrop = {
    authorId: UserId;
    created_at: Date;
    dropExpiryDate: Date | null;
    endDropDate: Date;
    id: InventoryDropId;
    name: string;
    notificationDetails: InventoryNotificationDetails;
    startDropDate: Date;
    status: string;
    tags: Array<Tag>;
    targetGroup: string;
    templateIds: Array<InventoryTemplateId>;
    updated_at: Date;
};
/**
 * InventoryTemplate
 */
type InventoryTemplate = {
    authorId: UserId;
    collections: Array<string>;
    created_at: Date;
    description: string;
    flags: Array<string>;
    id: InventoryTemplateId;
    imageUrl: string;
    itemType: InventoryItemType;
    itemTypeLabel: string;
    metadata?: InventoryMetadata;
    name: string;
    notificationDetails?: InventoryNotificationDetails;
    status: string;
    tags: Array<Tag>;
    updated_at: Date;
};
/**
 * InventorySpawn
 */
type InventorySpawn = {
    token: string;
    version: number;
};
/**
 * ShareInventoryItemDirectRequest
 */
type ShareInventoryItemDirectRequest = {
    itemId: InventoryItemId;
    users: Array<UserId>;
};
/**
 * OkStatus
 * A status response consisting of solely a string description of whether the result of an operation was ok.
 */
type OkStatus = {
    /**
     * The actual status itself
     */
    ok: string;
};
/**
 * InviteRequest
 */
type InviteRequest = {
    instanceId: InstanceId;
    messageSlot?: number;
};
/**
 * SentNotification
 */
type SentNotification = {
    created_at: Date;
    details: {
        [key: string]: unknown;
    };
    id: string;
    message: string;
    receiverUserId: UserId;
    senderUserId: UserId;
    /**
     * -| **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @deprecated
     */
    senderUsername?: string;
    type: NotificationType;
};
/**
 * RequestInviteRequest
 */
type RequestInviteRequest = {
    requestSlot?: number;
};
/**
 * InviteResponse
 */
type InviteResponse = {
    responseSlot: number;
};
/**
 * InviteMessageType
 */
type InviteMessageType = 'message' | 'response' | 'request' | 'requestResponse';
/**
 * InviteMessageID
 */
type InviteMessageId = string;
/**
 * InviteMessage
 */
type InviteMessage = {
    canBeUpdated: boolean;
    id: InviteMessageId;
    message: string;
    messageType: InviteMessageType;
    /**
     * Changes to 60 when updated, although probably server-side configurable.
     */
    remainingCooldownMinutes: number;
    slot: number;
    updatedAt: Date;
};
/**
 * UpdateInviteMessageRequest
 */
type UpdateInviteMessageRequest = {
    message: string;
};
/**
 * InstanceType
 */
type InstanceType = 'public' | 'hidden' | 'friends' | 'private' | 'group';
/**
 * InstanceRegion
 * Instance region
 */
type InstanceRegion = 'us' | 'use' | 'eu' | 'jp' | 'unknown';
/**
 * InstanceOwnerId
 * A groupId if the instance type is "group", null if instance type is public, or a userId otherwise
 */
type InstanceOwnerId = string | null;
/**
 * GroupAccessType
 * Group access type when the instance type is "group"
 */
type GroupAccessType = 'public' | 'plus' | 'members';
/**
 * CreateInstanceRequest
 */
type CreateInstanceRequest = {
    worldId: WorldId;
    type: InstanceType;
    region: InstanceRegion;
    ownerId?: InstanceOwnerId;
    /**
     * Group roleIds that are allowed to join if the type is "group" and groupAccessType is "member"
     */
    roleIds?: Array<GroupRoleId>;
    groupAccessType?: GroupAccessType;
    queueEnabled?: boolean;
    /**
     * The time after which users won't be allowed to join the instance. This doesn't work for public instances.
     */
    closedAt?: Date;
    /**
     * Only applies to invite type instances to make them invite+
     */
    canRequestInvite?: boolean;
    /**
     * Currently unused, but will eventually be a flag to set if the closing of the instance should kick people.
     */
    hardClose?: boolean;
    inviteOnly?: boolean;
    ageGate?: boolean;
    instancePersistenceEnabled?: boolean | null;
    displayName?: string | null;
    contentSettings?: InstanceContentSettings;
};
/**
 * Region
 * API/Photon region.
 */
type Region = 'us' | 'use' | 'usw' | 'usx' | 'eu' | 'jp' | 'unknown';
/**
 * InstancePlatforms
 */
type InstancePlatforms = {
    android: number;
    ios?: number;
    standalonewindows: number;
};
/**
 * LimitedUserInstance
 * User object received when querying your own instance
 */
type LimitedUserInstance = {
    ageVerificationStatus: AgeVerificationStatus;
    ageVerified: AgeVerified;
    allowAvatarCopying: boolean;
    bio?: string;
    /**
     *
     */
    bioLinks?: Array<string>;
    currentAvatarImageUrl: CurrentAvatarImageUrl;
    currentAvatarThumbnailImageUrl: CurrentAvatarThumbnailImageUrl;
    currentAvatarTags: Array<Tag>;
    date_joined: Date | null;
    developerType: DeveloperType;
    displayName: string;
    friendKey: string;
    id: UserId;
    isFriend: boolean;
    imageUrl?: string;
    last_platform: Platform;
    last_activity: Date | null;
    last_mobile: Date | null;
    platform?: string;
    profilePicOverride?: string;
    profilePicOverrideThumbnail?: string;
    pronouns: string;
    state: UserState;
    status: UserStatus;
    statusDescription: string;
    tags: Array<Tag>;
    userIcon?: string;
};
/**
 * Instance
 * * `hidden` field is only present if InstanceType is `hidden` aka "Friends+", and is instance creator.
 * * `friends` field is only present if InstanceType is `friends` aka "Friends", and is instance creator.
 * * `private` field is only present if InstanceType is `private` aka "Invite" or "Invite+", and is instance creator.
 */
type Instance = {
    active: boolean;
    ageGate?: boolean | null;
    canRequestInvite: boolean;
    capacity: number;
    /**
     * Always returns "unknown".
     * @deprecated
     */
    clientNumber: string;
    contentSettings?: InstanceContentSettings;
    displayName?: string | null;
    full: boolean;
    gameServerVersion?: number;
    id: InstanceId;
    instanceId: InstanceId;
    instancePersistenceEnabled?: string | null;
    location: LocationId;
    n_users: number;
    name: string;
    ownerId?: InstanceOwnerId;
    permanent: boolean;
    photonRegion: Region;
    platforms: InstancePlatforms;
    playerPersistenceEnabled?: boolean | null;
    region: InstanceRegion;
    secureName: string;
    shortName?: string | null;
    /**
     * The tags array on Instances usually contain the language tags of the people in the instance.
     */
    tags: Array<Tag>;
    type: InstanceType;
    worldId: WorldId;
    hidden?: UserId;
    friends?: UserId;
    private?: UserId;
    queueEnabled: boolean;
    queueSize: number;
    recommendedCapacity: number;
    roleRestricted?: boolean;
    strict: boolean;
    userCount: number;
    world: World;
    /**
     * The users field is present on instances created by the requesting user.
     */
    users?: Array<LimitedUserInstance>;
    groupAccessType?: GroupAccessType;
    hasCapacityForYou?: boolean;
    nonce?: string;
    closedAt?: Date | null;
    hardClose?: boolean | null;
};
/**
 * InstanceShortNameResponse
 */
type InstanceShortNameResponse = {
    secureName: string;
    shortName?: string | null;
};
/**
 * PlayerModerationType
 */
type PlayerModerationType = 'block' | 'mute' | 'muteChat' | 'unmute' | 'unmuteChat' | 'hideAvatar' | 'showAvatar' | 'interactOn' | 'interactOff';
/**
 * PlayerModerationID
 */
type PlayerModerationId = string;
/**
 * PlayerModeration
 */
type PlayerModeration = {
    created: Date;
    id: PlayerModerationId;
    sourceDisplayName: string;
    sourceUserId: UserId;
    targetDisplayName: string;
    targetUserId: UserId;
    type: PlayerModerationType;
};
/**
 * ModerateUserRequest
 */
type ModerateUserRequest = {
    moderated: UserId;
    type: PlayerModerationType;
};
/**
 * PrintID
 */
type PrintId = string;
/**
 * Print
 * Info about a print
 */
type Print = {
    authorId: UserId;
    authorName: string;
    createdAt: Date;
    files: {
        fileId?: FileId;
        /**
         * Link to file, e.g. https://api.vrchat.cloud/api/1/file/file_66fe782d-f2bd-4462-9761-1d766d7b2b26/1/file
         */
        image?: string;
    };
    id: PrintId;
    note: string;
    ownerId?: UserId;
    timestamp: Date;
    worldId: WorldId;
    worldName: string;
};
/**
 * PropUnityPackage
 */
type PropUnityPackage = {
    assetUrl: string;
    assetVersion: number;
    propSignature: string;
    platform: Platform;
    unityVersion: string;
    variant: string;
};
/**
 * Prop
 */
type Prop = {
    _created_at: Date;
    _updated_at: Date;
    authorId: UserId;
    authorName: string;
    description: string;
    id: PropId;
    imageUrl: string;
    maxCountPerUser: number;
    name: string;
    releaseStatus: ReleaseStatus;
    spawnType: number;
    tags: Array<Tag>;
    thumbnailImageUrl: string;
    unityPackageUrl: string | null;
    unityPackages: Array<PropUnityPackage>;
    worldPlacementMask: number;
};
/**
 * Jam
 */
type Jam = {
    description: string;
    id: string;
    isVisible: boolean;
    moreInfo: string;
    /**
     * One of:
     * - submissions_open
     * - closed
     */
    state: string;
    stateChangeDates: {
        closed?: Date | null;
        submissionsClosed?: Date | null;
        submissionsOpened?: Date | null;
        winnersSelected?: Date | null;
    };
    submissionContentGateDate: Date | null;
    submissionContentGated: boolean;
    title: string;
    updated_at: Date;
};
/**
 * Submission
 */
type Submission = {
    /**
     * Either world ID or avatar ID
     */
    contentId: string;
    created_at: Date;
    description: string;
    id: string;
    jamId: string;
    ratingScore?: number;
    submitterId: UserId;
};
/**
 * LimitedUserSearch
 * User object received when searching
 */
type LimitedUserSearch = {
    bio?: string;
    /**
     *
     */
    bioLinks?: Array<string>;
    currentAvatarImageUrl: CurrentAvatarImageUrl;
    currentAvatarThumbnailImageUrl: CurrentAvatarThumbnailImageUrl;
    currentAvatarTags: Array<Tag>;
    developerType: DeveloperType;
    displayName: string;
    id: UserId;
    isFriend: boolean;
    last_platform: Platform;
    profilePicOverride?: string;
    pronouns?: string;
    status: UserStatus;
    statusDescription: string;
    /**
     * <- Always empty.
     */
    tags: Array<Tag>;
    userIcon?: string;
};
/**
 * User
 */
type User = {
    ageVerificationStatus: AgeVerificationStatus;
    ageVerified: AgeVerified;
    allowAvatarCopying: boolean;
    /**
     *
     */
    badges?: Array<Badge>;
    bio: string;
    bioLinks: Array<string>;
    currentAvatarImageUrl: CurrentAvatarImageUrl;
    currentAvatarThumbnailImageUrl: CurrentAvatarThumbnailImageUrl;
    currentAvatarTags: Array<Tag>;
    date_joined: Date;
    developerType: DeveloperType;
    /**
     * A users visual display name. This is what shows up in-game, and can different from their `username`. Changing display name is restricted to a cooldown period.
     */
    displayName: string;
    friendKey: string;
    friendRequestStatus?: string;
    id: UserId;
    instanceId?: InstanceId;
    /**
     * Either their `friendKey`, or empty string if you are not friends. Unknown usage.
     */
    isFriend: boolean;
    /**
     * Either a date-time or empty string.
     */
    last_activity: string;
    /**
     * Either a date-time or empty string.
     */
    last_login: string;
    last_mobile?: string | null;
    last_platform: Platform;
    location?: LocationId;
    note?: string;
    platform?: string;
    profilePicOverride: string;
    profilePicOverrideThumbnail: string;
    pronouns: string;
    state: UserState;
    status: UserStatus;
    statusDescription: string;
    /**
     *
     */
    tags: Array<Tag>;
    travelingToInstance?: string;
    travelingToLocation?: string;
    travelingToWorld?: string;
    userIcon: string;
    /**
     * -| A users unique name, used during login. This is different from `displayName` which is what shows up in-game. A users `username` can never be changed.'
     * **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * @deprecated
     */
    username?: string;
    worldId?: WorldId;
};
/**
 * UpdateUserRequest
 */
type UpdateUserRequest = {
    email?: string;
    unsubscribe?: boolean;
    birthday?: Date;
    acceptedTOSVersion?: number;
    /**
     *
     */
    tags?: Array<Tag>;
    status?: UserStatus;
    statusDescription?: string;
    bio?: string;
    bioLinks?: Array<string>;
    pronouns?: string;
    isBoopingEnabled?: boolean;
    /**
     * MUST be a valid VRChat /file/ url.
     */
    userIcon?: string;
    /**
     * These tags begin with `content_` and control content gating
     */
    contentFilters?: Array<Tag>;
    /**
     * MUST specify currentPassword as well to change display name
     */
    displayName?: string;
    /**
     * MUST specify currentPassword as well to revert display name
     */
    revertDisplayName?: boolean;
    /**
     * MUST specify currentPassword as well to change password
     */
    password?: string;
    currentPassword?: string;
};
/**
 * LimitedUserGroups
 */
type LimitedUserGroups = {
    id?: GroupMemberId;
    name?: string;
    shortCode?: GroupShortCode;
    discriminator?: GroupDiscriminator;
    description?: string;
    iconId?: string | null;
    iconUrl?: string | null;
    bannerId?: string | null;
    bannerUrl?: string | null;
    privacy?: string;
    lastPostCreatedAt?: Date | null;
    ownerId?: UserId;
    memberCount?: number;
    groupId?: GroupId;
    memberVisibility?: string;
    isRepresenting?: boolean;
    mutualGroup?: boolean;
    lastPostReadAt?: Date | null;
};
/**
 * RepresentedGroup
 */
type RepresentedGroup = {
    name?: string;
    shortCode?: GroupShortCode;
    discriminator?: GroupDiscriminator;
    description?: string;
    iconId?: string | null;
    iconUrl?: string | null;
    bannerId?: string | null;
    bannerUrl?: string | null;
    privacy?: GroupPrivacy;
    ownerId?: UserId;
    memberCount?: number;
    groupId?: GroupId;
    memberVisibility?: GroupUserVisibility;
    isRepresenting?: boolean;
};
/**
 * FeedbackID
 */
type FeedbackId = string;
/**
 * Feedback
 */
type Feedback = {
    commenterId: UserId;
    commenterName: string;
    contentAuthorId: UserId;
    contentAuthorName: string | null;
    contentId: string;
    contentName?: string;
    contentType: string;
    contentVersion: number | null;
    description?: string | null;
    id: FeedbackId;
    reason: string;
    tags: Array<Tag>;
    type: string;
};
/**
 * UserNoteID
 */
type UserNoteId = string;
/**
 * UserNote
 */
type UserNote = {
    createdAt: Date;
    id: UserNoteId;
    note: string;
    targetUser?: {
        currentAvatarTags?: Array<Tag>;
        currentAvatarThumbnailImageUrl?: CurrentAvatarThumbnailImageUrl;
        displayName?: string;
        id?: UserNoteId;
        profilePicOverride?: string | null;
        userIcon?: string;
    };
    targetUserId: UserId;
    userId: UserId;
};
/**
 * UpdateUserNoteRequest
 */
type UpdateUserNoteRequest = {
    targetUserId: UserId;
    note: string;
};
/**
 * ChangeUserTagsRequest
 */
type ChangeUserTagsRequest = {
    /**
     * The tags being added or removed.
     */
    tags: Array<Tag>;
};
/**
 * UpdateUserBadgeRequest
 */
type UpdateUserBadgeRequest = {
    hidden?: boolean;
    showcased?: boolean;
};
/**
 * LimitedUnityPackage
 */
type LimitedUnityPackage = {
    created_at: Date | null;
    platform: Platform;
    unityVersion: string;
};
/**
 * LimitedWorld
 */
type LimitedWorld = {
    authorId: UserId;
    authorName: string;
    capacity: number;
    recommendedCapacity?: number;
    created_at: Date;
    defaultContentSettings?: InstanceContentSettings;
    favorites: number;
    visits?: number;
    heat: number;
    id: WorldId;
    imageUrl: string;
    labsPublicationDate: string;
    name: string;
    occupants: number;
    organization: string;
    popularity: number;
    previewYoutubeId?: string | null;
    publicationDate: string;
    releaseStatus: ReleaseStatus;
    storeId?: StoreId;
    /**
     *
     */
    tags: Array<Tag>;
    thumbnailImageUrl: string;
    /**
     *
     */
    unityPackages: Array<LimitedUnityPackage>;
    updated_at: Date;
    udonProducts?: Array<UdonProductId>;
};
/**
 * CreateWorldRequest
 */
type CreateWorldRequest = {
    assetUrl: string;
    assetVersion?: number;
    authorId?: UserId;
    authorName?: string;
    capacity?: number;
    description?: string;
    id?: WorldId;
    imageUrl: string;
    name: string;
    platform?: Platform;
    releaseStatus?: ReleaseStatus;
    /**
     *
     */
    tags?: Array<Tag>;
    unityPackageUrl?: string;
    unityVersion?: string;
};
/**
 * FavoritedWorld
 */
type FavoritedWorld = {
    authorId?: UserId;
    authorName: string;
    capacity: number;
    description: string;
    recommendedCapacity?: number;
    created_at: Date;
    defaultContentSettings?: InstanceContentSettings;
    favorites: number;
    favoriteGroup: string;
    favoriteId: FavoriteId;
    featured: boolean;
    visits?: number;
    heat: number;
    id: WorldId;
    imageUrl: string;
    labsPublicationDate: string;
    name: string;
    occupants: number;
    organization: string;
    popularity: number;
    previewYoutubeId?: string | null;
    publicationDate: string;
    releaseStatus: ReleaseStatus;
    /**
     *
     */
    tags: Array<Tag>;
    thumbnailImageUrl: string;
    /**
     *
     */
    unityPackages: Array<UnityPackage>;
    updated_at: Date;
    urlList: Array<string>;
    udonProducts?: Array<UdonProductId>;
    version: number;
};
/**
 * UpdateWorldRequest
 */
type UpdateWorldRequest = {
    assetUrl?: string;
    assetVersion?: string;
    authorId?: UserId;
    authorName?: string;
    capacity?: number;
    description?: string;
    imageUrl?: string;
    name?: string;
    platform?: Platform;
    releaseStatus?: ReleaseStatus;
    /**
     *
     */
    tags?: Array<Tag>;
    unityPackageUrl?: string;
    unityVersion?: string;
};
/**
 * WorldMetadata
 */
type WorldMetadata = {
    id: WorldId;
    metadata: {
        [key: string]: unknown;
    };
};
/**
 * WorldPublishStatus
 */
type WorldPublishStatus = {
    canPublish: boolean;
};
/**
 * APIConfigAnnouncement
 * Public Announcement
 * @deprecated
 */
type ApiConfigAnnouncement = {
    /**
     * Announcement name
     */
    name: string;
    /**
     * Announcement text
     */
    text: string;
};
/**
 * PerformanceLimiterInfo
 * Info about the performance limits on a platform
 */
type PerformanceLimiterInfo = {
    /**
     * Maximum amount of seats. -1 means no limit.
     */
    maxSeats: number;
};
/**
 * APIConfigConstants
 * Constants
 */
type ApiConfigConstants = {
    /**
     * Group-related constants
     */
    GROUPS: {
        /**
         * Maximum group capacity
         */
        CAPACITY?: number;
        /**
         * Requirements for transferring group ownership
         */
        GROUP_TRANSFER_REQUIREMENTS?: Array<string>;
        /**
         * Maximum number of invite requests
         */
        MAX_INVITES_REQUESTS?: number;
        /**
         * Maximum number of joined groups
         */
        MAX_JOINED?: number;
        /**
         * Maximum number of joined groups for VRChat Plus members
         */
        MAX_JOINED_PLUS?: number;
        /**
         * Maximum number of supported languages
         */
        MAX_LANGUAGES?: number;
        /**
         * Maximum number of group links
         */
        MAX_LINKS?: number;
        /**
         * Maximum number of management roles in a group
         */
        MAX_MANAGEMENT_ROLES?: number;
        /**
         * Maximum number of groups a user can own
         */
        MAX_OWNED?: number;
        /**
         * Maximum number of roles in a group
         */
        MAX_ROLES?: number;
    };
    /**
     * Instance-related constants
     */
    INSTANCE: {
        /**
         * Population brackets based on instance population
         */
        POPULATION_BRACKETS?: {
            /**
             * Crowded population range
             */
            CROWDED?: {
                /**
                 * Maximum population for a crowded instance
                 */
                max?: number;
                /**
                 * Minimum population for a crowded instance
                 */
                min?: number;
            };
            /**
             * Few population range
             */
            FEW?: {
                /**
                 * Maximum population for a few instance
                 */
                max?: number;
                /**
                 * Minimum population for a few instance
                 */
                min?: number;
            };
            /**
             * Many population range
             */
            MANY?: {
                /**
                 * Maximum population for a many instance
                 */
                max?: number;
                /**
                 * Minimum population for a many instance
                 */
                min?: number;
            };
        };
    };
    /**
     * Language-related constants
     */
    LANGUAGE: {
        /**
         * Supported spoken language options
         */
        SPOKEN_LANGUAGE_OPTIONS?: {
            [key: string]: string;
        };
    };
};
/**
 * APIConfigDownloadURLList
 * Download links for various development assets.
 */
type ApiConfigDownloadUrlList = {
    /**
     * Download link for legacy SDK2
     * @deprecated
     */
    sdk2: string;
    /**
     * Download link for SDK3 for Avatars
     */
    'sdk3-avatars': string;
    /**
     * Download link for SDK3 for Worlds
     */
    'sdk3-worlds': string;
    /**
     * Download link for the Creator Companion
     */
    vcc: string;
    /**
     * Download link for ???
     */
    bootstrap: string;
};
/**
 * DynamicContentRow
 */
type DynamicContentRow = {
    index?: number;
    name: string;
    /**
     * Usually "ThisPlatformSupported", but can also be other values such as "all" or platform specific identifiers.
     */
    platform: string;
    sortHeading: string;
    sortOrder: string;
    sortOwnership: string;
    /**
     * Tag to filter content for this row.
     */
    tag?: string;
    /**
     * Type is not present if it is a world.
     */
    type?: string;
};
/**
 * APIConfigEvents
 */
type ApiConfigEvents = {
    /**
     * Unknown
     */
    distanceClose: number;
    /**
     * Unknown
     */
    distanceFactor: number;
    /**
     * Unknown
     */
    distanceFar: number;
    /**
     * Unknown
     */
    groupDistance: number;
    /**
     * Unknown
     */
    maximumBunchSize: number;
    /**
     * Unknown
     */
    notVisibleFactor: number;
    /**
     * Unknown
     */
    playerOrderBucketSize: number;
    /**
     * Unknown
     */
    playerOrderFactor: number;
    /**
     * Unknown
     */
    slowUpdateFactorThreshold: number;
    /**
     * Unknown
     */
    viewSegmentLength: number;
};
/**
 * PlatformBuildInfo
 * Build information for a platform
 */
type PlatformBuildInfo = {
    /**
     * Minimum build number required for the platform
     */
    minBuildNumber: number;
    /**
     * Redirection URL for updating the app
     */
    redirectionAddress?: string;
};
/**
 * ReportCategory
 * A category used for reporting content
 */
type ReportCategory = {
    /**
     * The description of the report category
     */
    description?: string;
    /**
     * The title of the report category
     */
    title?: string;
    /**
     * The label of the report category
     */
    text: string;
    /**
     * The tooltip that describes the category
     */
    tooltip: string;
};
/**
 * ReportReason
 * A reason used for reporting users
 */
type ReportReason = {
    /**
     * The label or name of the report reason
     */
    text: string;
    /**
     * A brief explanation of what this reason entails
     */
    tooltip: string;
};
/**
 * APIConfig
 */
type ApiConfig = {
    /**
     * Unknown, probably voice optimization testing
     */
    VoiceEnableDegradation: boolean;
    /**
     * Unknown, probably voice optimization testing
     */
    VoiceEnableReceiverLimiting: boolean;
    accessLogsUrls: {
        Default?: string;
        Pico?: string;
        Quest?: string;
        XRElite?: string;
    };
    /**
     * VRChat's office address
     */
    address: string;
    ageVerificationInviteVisible: boolean;
    ageVerificationP: boolean;
    ageVerificationStatusVisible: boolean;
    /**
     * Max retries for avatar analysis requests
     */
    analysisMaxRetries: number;
    /**
     * Interval between retries for avatar analysis requests
     */
    analysisRetryInterval: number;
    /**
     * Public Announcements
     */
    announcements: Array<ApiConfigAnnouncement>;
    /**
     * Unknown
     */
    analyticsSegment_NewUI_PctOfUsers: number;
    /**
     * Unknown
     */
    analyticsSegment_NewUI_Salt: string;
    /**
     * List of supported Languages
     */
    availableLanguageCodes: Array<string>;
    /**
     * List of supported Languages
     */
    availableLanguages: Array<string>;
    avatarPerfLimiter: {
        AndroidMobile: PerformanceLimiterInfo;
        PC: PerformanceLimiterInfo;
        Pico: PerformanceLimiterInfo;
        Quest: PerformanceLimiterInfo;
        XRElite: PerformanceLimiterInfo;
        iOSMobile: PerformanceLimiterInfo;
    };
    /**
     * Unknown
     */
    chatboxLogBufferSeconds: number;
    /**
     * apiKey to be used for all other requests
     */
    clientApiKey: string;
    /**
     * Unknown
     */
    clientBPSCeiling: number;
    /**
     * Unknown
     */
    clientDisconnectTimeout: number;
    /**
     * Unknown
     */
    clientNetDispatchThread?: boolean;
    /**
     * Unknown
     */
    clientNetDispatchThreadMobile: boolean;
    /**
     * Unknown
     */
    clientNetInThread?: boolean;
    /**
     * Unknown
     */
    clientNetInThread2?: boolean;
    /**
     * Unknown
     */
    clientNetInThreadMobile?: boolean;
    /**
     * Unknown
     */
    clientNetInThreadMobile2?: boolean;
    /**
     * Unknown
     */
    clientNetOutThread?: boolean;
    /**
     * Unknown
     */
    clientNetOutThread2?: boolean;
    /**
     * Unknown
     */
    clientNetOutThreadMobile?: boolean;
    /**
     * Unknown
     */
    clientNetOutThreadMobile2?: boolean;
    /**
     * Unknown
     */
    clientQR?: number;
    /**
     * Unknown
     */
    clientReservedPlayerBPS: number;
    /**
     * Unknown
     */
    clientSentCountAllowance: number;
    constants: ApiConfigConstants;
    /**
     * VRChat's contact email
     */
    contactEmail: string;
    /**
     * VRChat's copyright-issues-related email
     */
    copyrightEmail: string;
    /**
     * Current version number of the Privacy Agreement
     */
    currentPrivacyVersion?: number;
    /**
     * Current version number of the Terms of Service
     */
    currentTOSVersion: number;
    defaultAvatar: AvatarId;
    defaultStickerSet: string;
    /**
     * Unknown
     */
    devLanguageCodes?: Array<string>;
    /**
     * Link to download the development SDK, use downloadUrls instead
     * @deprecated
     */
    devSdkUrl: string;
    /**
     * Version of the development SDK
     * @deprecated
     */
    devSdkVersion: string;
    /**
     * Unknown, "dis" maybe for disconnect?
     */
    'dis-countdown': Date;
    /**
     * Unknown
     */
    disableAVProInProton?: boolean;
    /**
     * Toggles if copying avatars should be disabled
     */
    disableAvatarCopying: boolean;
    /**
     * Toggles if avatar gating should be disabled. Avatar gating restricts uploading of avatars to people with the `system_avatar_access` Tag or `admin_avatar_access` Tag
     */
    disableAvatarGating: boolean;
    /**
     * Toggles if the Community Labs should be disabled
     */
    disableCommunityLabs: boolean;
    /**
     * Toggles if promotion out of Community Labs should be disabled
     */
    disableCommunityLabsPromotion: boolean;
    /**
     * Unknown
     */
    disableEmail: boolean;
    /**
     * Unknown
     */
    disableCaptcha?: boolean;
    /**
     * Toggles if Analytics should be disabled.
     */
    disableEventStream: boolean;
    /**
     * Toggles if feedback gating should be disabled. Feedback gating restricts submission of feedback (reporting a World or User) to people with the `system_feedback_access` Tag.
     */
    disableFeedbackGating: boolean;
    /**
     * Unknown, probably toggles compilation of frontend web builds? So internal flag?
     */
    disableFrontendBuilds: boolean;
    /**
     * Toggles if gift drops should be disabled
     */
    disableGiftDrops: boolean;
    /**
     * Unknown
     */
    disableHello: boolean;
    /**
     * Toggles if signing up for Subscriptions in Oculus is disabled or not.
     */
    disableOculusSubs: boolean;
    /**
     * Toggles if new user account registration should be disabled.
     */
    disableRegistration: boolean;
    /**
     * Toggles if Steam Networking should be disabled. VRChat these days uses Photon Unity Networking (PUN) instead.
     */
    disableSteamNetworking: boolean;
    /**
     * Toggles if 2FA should be disabled.
     * @deprecated
     */
    disableTwoFactorAuth: boolean;
    /**
     * Toggles if Udon should be universally disabled in-game.
     */
    disableUdon: boolean;
    /**
     * Toggles if account upgrading "linking with Steam/Oculus" should be disabled.
     */
    disableUpgradeAccount: boolean;
    /**
     * Download link for game on the Oculus Rift website.
     */
    downloadLinkWindows: string;
    downloadUrls: ApiConfigDownloadUrlList;
    /**
     * Array of DynamicWorldRow objects, used by the game to display the list of world rows
     */
    dynamicWorldRows: Array<DynamicContentRow>;
    /**
     * Unknown
     */
    economyPauseEnd?: string;
    /**
     * Unknown
     */
    economyPauseStart?: string;
    /**
     * Unknown
     */
    economyState?: number;
    events: ApiConfigEvents;
    /**
     * Unknown
     */
    forceUseLatestWorld: boolean;
    /**
     * Display type of gifts
     */
    giftDisplayType: string;
    /**
     * Unknown
     */
    googleApiClientId: string;
    homeWorldId: WorldId;
    /**
     * Redirect target if you try to open the base API domain in your browser
     */
    homepageRedirectTarget: string;
    hubWorldId: WorldId;
    /**
     * A list of explicitly allowed origins that worlds can request images from via the Udon's [VRCImageDownloader#DownloadImage](https://creators.vrchat.com/worlds/udon/image-loading/#downloadimage).
     */
    imageHostUrlList: Array<string>;
    /**
     * VRChat's job application email
     */
    jobsEmail: string;
    /**
     * Minimum supported client build number for various platforms
     */
    minSupportedClientBuildNumber: {
        AppStore: PlatformBuildInfo;
        Default: PlatformBuildInfo;
        Firebase: PlatformBuildInfo;
        FirebaseiOS: PlatformBuildInfo;
        GooglePlay: PlatformBuildInfo;
        PC: PlatformBuildInfo;
        PicoStore: PlatformBuildInfo;
        QuestAppLab: PlatformBuildInfo;
        QuestStore: PlatformBuildInfo;
        TestFlight: PlatformBuildInfo;
        XRElite: PlatformBuildInfo;
    };
    /**
     * Minimum Unity version required for uploading assets
     */
    minimumUnityVersionForUploads: string;
    /**
     * VRChat's moderation related email
     */
    moderationEmail: string;
    /**
     * Used in-game to notify a user they aren't allowed to select avatars in private worlds
     */
    notAllowedToSelectAvatarInPrivateWorldMessage: string;
    /**
     * Whether to allow offline analysis
     */
    offlineAnalysis: {
        /**
         * Whether to allow offline analysis
         */
        android?: boolean;
        /**
         * Whether to allow offline analysis
         */
        standalonewindows?: boolean;
    };
    /**
     * Unknown
     */
    photonNameserverOverrides: Array<string>;
    /**
     * Unknown
     */
    photonPublicKeys: Array<string>;
    /**
     * Categories available for reporting objectionable content
     */
    reportCategories: {
        avatar: ReportCategory;
        avatarpage?: ReportCategory;
        behavior: ReportCategory;
        chat: ReportCategory;
        emoji?: ReportCategory;
        environment: ReportCategory;
        groupstore: ReportCategory;
        image: ReportCategory;
        text: ReportCategory;
        sticker?: ReportCategory;
        warnings: ReportCategory;
        worldimage: ReportCategory;
        worldstore: ReportCategory;
    };
    /**
     * URL to the report form
     */
    reportFormUrl: string;
    /**
     * Options for reporting content
     */
    reportOptions: {
        avatar?: {
            avatar?: Array<string>;
            avatarpage?: Array<string>;
            warnings?: Array<string>;
        };
        group?: {
            groupstore?: Array<string>;
            image?: Array<string>;
            text?: Array<string>;
        };
        user?: {
            behavior?: Array<string>;
            chat?: Array<string>;
            emoji?: Array<string>;
            image?: Array<string>;
            sticker?: Array<string>;
            text?: Array<string>;
        };
        world?: {
            environment?: Array<string>;
            text?: Array<string>;
            warnings?: Array<string>;
            worldimage?: Array<string>;
            worldstore?: Array<string>;
        };
    };
    /**
     * Reasons available for reporting users
     */
    reportReasons: {
        billing: ReportReason;
        botting: ReportReason;
        cancellation: ReportReason;
        copyright?: ReportReason;
        fraud?: ReportReason;
        gore: ReportReason;
        hacking: ReportReason;
        harassing: ReportReason;
        hateful: ReportReason;
        impersonation: ReportReason;
        inappropriate: ReportReason;
        leaking: ReportReason;
        malicious: ReportReason;
        missing: ReportReason;
        nudity: ReportReason;
        renewal: ReportReason;
        security: ReportReason;
        service: ReportReason;
        sexual: ReportReason;
        technical?: ReportReason;
        threatening: ReportReason;
        visuals: ReportReason;
    };
    requireAgeVerificationBetaTag: boolean;
    /**
     * Link to the developer FAQ
     */
    sdkDeveloperFaqUrl: string;
    /**
     * Link to the official VRChat Discord
     */
    sdkDiscordUrl: string;
    /**
     * Used in the SDK to notify a user they aren't allowed to upload avatars/worlds yet
     */
    sdkNotAllowedToPublishMessage: string;
    /**
     * Unity version supported by the SDK
     */
    sdkUnityVersion: string;
    /**
     * A list of explicitly allowed origins that worlds can request strings from via the Udon's [VRCStringDownloader.LoadUrl](https://creators.vrchat.com/worlds/udon/string-loading/#ivrcstringdownload).
     */
    stringHostUrlList: Array<string>;
    /**
     * VRChat's support email
     */
    supportEmail: string;
    /**
     * VRChat's support form
     */
    supportFormUrl: string;
    /**
     * Unknown
     */
    timekeeping: boolean;
    timeOutWorldId: WorldId;
    tutorialWorldId: WorldId;
    /**
     * Unknown
     */
    updateRateMsMaximum: number;
    /**
     * Unknown
     */
    updateRateMsMinimum: number;
    /**
     * Unknown
     */
    updateRateMsNormal: number;
    /**
     * Unknown
     */
    updateRateMsUdonManual: number;
    /**
     * Unknown
     */
    uploadAnalysisPercent: number;
    /**
     * List of allowed URLs that bypass the "Allow untrusted URL's" setting in-game
     */
    urlList: Array<string>;
    /**
     * Unknown
     */
    useReliableUdpForVoice: boolean;
    /**
     * Download link for game on the Steam website.
     */
    viveWindowsUrl: string;
    /**
     * List of allowed URLs that are allowed to host avatar assets
     */
    whiteListedAssetUrls: Array<string>;
    /**
     * Currently used youtube-dl.exe version
     */
    'player-url-resolver-version': string;
    /**
     * Currently used youtube-dl.exe hash in SHA1-delimited format
     */
    'player-url-resolver-sha1': string;
    /**
     * Public key, hex encoded
     */
    publicKey: string;
    /**
     * Unknown
     */
    websocketMaxFriendsRefreshDelay: number;
    /**
     * Unknown
     */
    websocketQuickReconnectTime: number;
    /**
     * Unknown
     */
    websocketReconnectMaxDelay: number;
};
/**
 * InfoPushDataClickable
 */
type InfoPushDataClickable = {
    command: 'OpenURL' | 'OpenVRCPlusMenu' | 'OpenSafetyMenu' | 'CannedWorldSearch';
    /**
     * In case of OpenURL, this would contain the link.
     */
    parameters?: Array<string>;
};
/**
 * InfoPushDataArticleContent
 */
type InfoPushDataArticleContent = {
    text?: string;
    imageUrl?: string;
    onPressed?: InfoPushDataClickable;
};
/**
 * InfoPushDataArticle
 */
type InfoPushDataArticle = {
    content?: InfoPushDataArticleContent;
};
/**
 * InfoPushData
 */
type InfoPushData = {
    contentList?: DynamicContentRow;
    description?: string;
    imageUrl?: string;
    name?: string;
    onPressed?: InfoPushDataClickable;
    template?: string;
    version?: string;
    article?: InfoPushDataArticle;
};
/**
 * InfoPush
 */
type InfoPush = {
    id: string;
    isEnabled: boolean;
    releaseStatus: ReleaseStatus;
    priority: number;
    /**
     *
     */
    tags: Array<Tag>;
    data: InfoPushData;
    /**
     * Unknown usage, MD5
     */
    hash: string;
    createdAt: Date;
    updatedAt: Date;
    startDate?: Date;
    endDate?: Date;
};
/**
 * APIHealth
 */
type ApiHealth = {
    ok: boolean;
    serverName: string;
    buildVersionTag: string;
};
/**
 * PermissionID
 */
type PermissionId = string;
/**
 * Permission
 */
type Permission = {
    displayName?: string;
    description?: string;
    id: PermissionId;
    ownerDisplayName: string;
    name: string;
    ownerId: UserId;
    type?: string;
    data?: {
        [key: string]: unknown;
    };
};
/**
 * NotificationDetailInvite
 */
type NotificationDetailInvite = {
    inviteMessage?: string;
    worldId: LocationId;
    worldName: string;
};
/**
 * NotificationDetailInviteResponse
 */
type NotificationDetailInviteResponse = {
    inResponseTo: NotificationId;
    responseMessage: string;
};
/**
 * NotificationDetailRequestInvite
 */
type NotificationDetailRequestInvite = {
    /**
     * TODO: Does this still exist?
     */
    platform?: string;
    /**
     * Used when using InviteMessage Slot.
     */
    requestMessage?: string;
};
/**
 * NotificationDetailRequestInviteResponse
 */
type NotificationDetailRequestInviteResponse = {
    inResponseTo: NotificationId;
    /**
     * Used when using InviteMessage Slot.
     */
    requestMessage?: string;
};
/**
 * NotificationDetailVoteToKick
 */
type NotificationDetailVoteToKick = {
    initiatorUserId: UserId;
    userToKickId: UserId;
};
/**
 * Filter by email.
 */
type Email = string;
/**
 * Filter by displayName.
 */
type DisplayName = string;
/**
 * Filter by Username.
 */
type UsernameQuery = string;
/**
 * Exclude by UserID.
 */
type ExcludeUserId = string;
/**
 * Must be a valid user ID.
 */
type UserId2 = string;
/**
 * Target user for which to verify email.
 */
type ConfirmEmailUserId = string;
/**
 * Token to verify email.
 */
type ConfirmEmailToken = string;
/**
 * Filter by UserID.
 */
type UserIdQuery = string;
/**
 * Token to verify login attempt.
 */
type VerifyLoginPlaceToken = string;
/**
 * Filters on featured results.
 */
type Featured = boolean;
/**
 * The sort order of the results.
 */
type Sort = SortOption;
/**
 * The number of objects to return.
 */
type Number = number;
/**
 * Result ordering
 */
type Order = OrderOption;
/**
 * A zero-based offset from the default object sorting from where search results start.
 */
type Offset = number;
/**
 * Tags to include (comma-separated). Any of the tags needs to be present.
 */
type Tag2 = string;
/**
 * Tags to exclude (comma-separated).
 */
type Notag = string;
/**
 * Filter by ReleaseStatus.
 */
type ReleaseStatus2 = ReleaseStatus;
/**
 * The maximum Unity version supported by the asset.
 */
type MaxUnityVersion = string;
/**
 * The minimum Unity version supported by the asset.
 */
type MinUnityVersion = string;
/**
 * The platform the asset supports.
 */
type Platform2 = string;
/**
 * Must be a valid avatar ID.
 */
type AvatarId2 = string;
/**
 * Filters by world name.
 */
type Search = string;
/**
 * Target user to see information on, admin-only.
 */
type UserIdAdmin = string;
/**
 * The month to search in.
 */
type MonthDate = Date;
/**
 * Search term for calendar events.
 */
type CalendarSearchTerm = string;
/**
 * The offset from UTC in hours of the client or authenticated user.
 */
type UtcOffset = number;
/**
 * Must be a valid group ID.
 */
type GroupId2 = string;
/**
 * Must be a valid calendar ID.
 */
type CalendarId2 = string;
/**
 * Must be a valid transaction ID.
 */
type TransactionId2 = string;
/**
 * The Steam ID of the user.
 */
type SteamId = string;
/**
 * Must be a valid license group ID.
 */
type LicenseGroupId2 = string;
/**
 * Must be a valid product ID.
 */
type ProductId2 = string;
/**
 * Populates some fields and changes types of others for certain objects.
 */
type Hydrate = boolean;
/**
 * Must be a valid group ID.
 */
type GroupIdFilter = string;
/**
 * Filter for users' listings and inventory bundles.
 */
type Active = boolean;
type StoreId2 = StoreId;
/**
 * Listings fields will be populated.
 */
type HydrateListings = boolean;
/**
 * Products fields will be populated.
 */
type HydrateProducts = boolean;
type StoreView2 = StoreView;
/**
 * Must be a valid favorite ID.
 */
type FavoriteId2 = string;
/**
 * The type of group to fetch, must be a valid FavoriteType.
 */
type FavoriteGroupType = 'world' | 'friend' | 'avatar';
/**
 * The name of the group to fetch, must be a name of a FavoriteGroup.
 */
type FavoriteGroupName = string;
/**
 * Must be a valid file ID.
 */
type FileId2 = string;
/**
 * Version ID of the asset.
 */
type VersionId = number;
/**
 * Type of file.
 */
type FileType = 'file' | 'signature' | 'delta';
/**
 * Must be a valid admin asset bundle ID.
 */
type AdminAssetBundleId = string;
/**
 * Returns *only* offline users if true, returns only online and active users if false
 */
type Offline = boolean;
/**
 * The start date of the search range.
 */
type StartDate = Date;
/**
 * The end date of the search range.
 */
type EndDate = Date;
/**
 * The comma-separated actor ids to search for.
 */
type ActorIds = string;
/**
 * The comma-separated event types to search for.
 */
type EventTypes = string;
/**
 * The comma-separated target ids to search for.
 */
type TargetIds = string;
/**
 * Must be a valid group gallery ID.
 */
type GroupGalleryId2 = string;
/**
 * Must be a valid group gallery image ID.
 */
type GroupGalleryImageId2 = string;
/**
 * The sort order of Group Member results
 */
type GroupMemberSort = GroupSearchSort;
/**
 * Only returns members with a specific groupRoleId
 */
type GroupMemberRoleFilter = GroupRoleId;
/**
 * Must be a valid group role ID.
 */
type GroupRoleId2 = string;
/**
 * Must be a valid notification ID.
 */
type NotificationId2 = string;
/**
 * Sort order for inventory retrieval.
 */
type InventorySortOrder = 'newest' | 'newest_created' | 'oldest' | 'oldest_created';
/**
 * Filter tags for inventory retrieval (comma-separated).
 */
type InventoryItemTags = Tag;
/**
 * Filter for inventory retrieval.
 */
type InventoryItemTypes = InventoryItemType;
/**
 * Filter flags for inventory retrieval (comma-separated).
 */
type InventoryItemFlags = InventoryFlag;
/**
 * Filter out types for inventory retrieval (comma-separated).
 */
type InventoryItemNotTypes = InventoryItemType;
/**
 * Filter out flags for inventory retrieval (comma-separated).
 */
type InventoryItemNotFlags = InventoryFlag;
/**
 * Filter archived status for inventory retrieval.
 */
type InventoryItemArchived = boolean;
/**
 * Must be a valid inventory item ID.
 */
type InventoryItemId2 = string;
/**
 * Must be a valid inventory template ID.
 */
type InventoryTemplateId2 = string;
/**
 * Id for inventory item spawning.
 */
type InventorySpawnItemId = InventoryItemId;
/**
 * Id for inventory item sharing.
 */
type InventoryPedestalItemId = InventoryItemId;
/**
 * The duration before the sharing pedestal despawns.
 */
type InventoryPedestalDuration = number;
/**
 * Must be a valid world ID.
 */
type WorldId2 = string;
/**
 * Must be a valid instance ID.
 */
type InstanceId2 = string;
/**
 * The type of message to fetch, must be a valid InviteMessageType.
 */
type MessageType = InviteMessageType;
/**
 * The message slot to fetch of a given message type.
 */
type Slot = number;
/**
 * Print ID.
 */
type PrintId2 = string;
/**
 * Prop ID.
 */
type PropId2 = string;
/**
 * Must be a valid query ID.
 */
type JamId = string;
/**
 * Filter for users' previously submitted feedback, e.g., a groupId, userId, avatarId, etc.
 */
type ContentId = boolean;
/**
 * Must be a valid user note ID.
 */
type UserNoteId2 = string;
/**
 * Must be a valid badge ID.
 */
type BadgeId2 = string;
type Fuzzy = boolean;
/**
 * Tags to include (comma-separated). All of the tags needs to be present.
 */
type Require = string;
/**
 * Tags to include (comma-separated). Any of the tags needs to be present.
 */
type Include = string;
/**
 * Specifies which `variant` of the site. Public is the end-user site, while `internal` is the staff-only site with special pages for moderation and management.
 */
type Variant = 'public' | 'internal';
/**
 * Specifies which git branch the site should load frontend source code from.
 */
type Branch = string;
/**
 * Must be a valid permission ID.
 */
type PermissionId2 = string;
type CheckUserExistsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter by email.
         */
        email?: string;
        /**
         * Filter by displayName.
         */
        displayName?: string;
        /**
         * Filter by Username.
         */
        username?: string;
        /**
         * Exclude by UserID.
         */
        excludeUserId?: string;
    };
    url: '/auth/exists';
};
type CheckUserExistsErrors = {
    /**
     * Error response when missing at least 1 of the required parameters.
     */
    400: _Error;
};
type CheckUserExistsError = CheckUserExistsErrors[keyof CheckUserExistsErrors];
type CheckUserExistsResponses = {
    /**
     * Returns a response if a user exists or not.
     */
    200: UserExists;
};
type CheckUserExistsResponse = CheckUserExistsResponses[keyof CheckUserExistsResponses];
type GetCurrentUserData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/user';
};
type GetCurrentUserErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetCurrentUserError = GetCurrentUserErrors[keyof GetCurrentUserErrors];
type GetCurrentUserResponses = {
    /**
     * OK
     */
    200: CurrentUser;
};
type GetCurrentUserResponse = GetCurrentUserResponses[keyof GetCurrentUserResponses];
type Disable2FaData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/twofactorauth';
};
type Disable2FaErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type Disable2FaError = Disable2FaErrors[keyof Disable2FaErrors];
type Disable2FaResponses = {
    /**
     * OK
     */
    200: Disable2FaResult;
};
type Disable2FaResponse = Disable2FaResponses[keyof Disable2FaResponses];
type Verify2FaData = {
    body: TwoFactorAuthCode;
    path?: never;
    query?: never;
    url: '/auth/twofactorauth/totp/verify';
};
type Verify2FaErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type Verify2FaError = Verify2FaErrors[keyof Verify2FaErrors];
type Verify2FaResponses = {
    /**
     * OK
     */
    200: Verify2FaResult;
};
type Verify2FaResponse = Verify2FaResponses[keyof Verify2FaResponses];
type CancelPending2FaData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/twofactorauth/totp/pending';
};
type CancelPending2FaErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type CancelPending2FaError = CancelPending2FaErrors[keyof CancelPending2FaErrors];
type CancelPending2FaResponses = {
    /**
     * OK
     */
    200: Disable2FaResult;
};
type CancelPending2FaResponse = CancelPending2FaResponses[keyof CancelPending2FaResponses];
type Enable2FaData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/twofactorauth/totp/pending';
};
type Enable2FaErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type Enable2FaError = Enable2FaErrors[keyof Enable2FaErrors];
type Enable2FaResponses = {
    /**
     * OK
     */
    200: Pending2FaResult;
};
type Enable2FaResponse = Enable2FaResponses[keyof Enable2FaResponses];
type VerifyPending2FaData = {
    body: TwoFactorAuthCode;
    path?: never;
    query?: never;
    url: '/auth/twofactorauth/totp/pending/verify';
};
type VerifyPending2FaErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type VerifyPending2FaError = VerifyPending2FaErrors[keyof VerifyPending2FaErrors];
type VerifyPending2FaResponses = {
    /**
     * OK
     */
    200: Verify2FaResult;
};
type VerifyPending2FaResponse = VerifyPending2FaResponses[keyof VerifyPending2FaResponses];
type GetRecoveryCodesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/user/twofactorauth/otp';
};
type GetRecoveryCodesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetRecoveryCodesError = GetRecoveryCodesErrors[keyof GetRecoveryCodesErrors];
type GetRecoveryCodesResponses = {
    /**
     * Returns the two factor recovery codes
     */
    200: TwoFactorRecoveryCodes;
};
type GetRecoveryCodesResponse = GetRecoveryCodesResponses[keyof GetRecoveryCodesResponses];
type VerifyRecoveryCodeData = {
    body: TwoFactorAuthCode;
    path?: never;
    query?: never;
    url: '/auth/twofactorauth/otp/verify';
};
type VerifyRecoveryCodeErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type VerifyRecoveryCodeError = VerifyRecoveryCodeErrors[keyof VerifyRecoveryCodeErrors];
type VerifyRecoveryCodeResponses = {
    /**
     * OK
     */
    200: Verify2FaResult;
};
type VerifyRecoveryCodeResponse = VerifyRecoveryCodeResponses[keyof VerifyRecoveryCodeResponses];
type Verify2FaEmailCodeData = {
    body: TwoFactorEmailCode;
    path?: never;
    query?: never;
    url: '/auth/twofactorauth/emailotp/verify';
};
type Verify2FaEmailCodeErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type Verify2FaEmailCodeError = Verify2FaEmailCodeErrors[keyof Verify2FaEmailCodeErrors];
type Verify2FaEmailCodeResponses = {
    /**
     * OK
     */
    200: Verify2FaEmailCodeResult;
};
type Verify2FaEmailCodeResponse = Verify2FaEmailCodeResponses[keyof Verify2FaEmailCodeResponses];
type VerifyAuthTokenData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth';
};
type VerifyAuthTokenErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type VerifyAuthTokenError = VerifyAuthTokenErrors[keyof VerifyAuthTokenErrors];
type VerifyAuthTokenResponses = {
    /**
     * Returns wether a provided auth token is valid or not.
     */
    200: VerifyAuthTokenResult;
};
type VerifyAuthTokenResponse = VerifyAuthTokenResponses[keyof VerifyAuthTokenResponses];
type LogoutData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/logout';
};
type LogoutErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type LogoutError = LogoutErrors[keyof LogoutErrors];
type LogoutResponses = {
    /**
     * OK
     */
    200: Success;
};
type LogoutResponse = LogoutResponses[keyof LogoutResponses];
type DeleteUserData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/users/{userId}/delete';
};
type DeleteUserErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type DeleteUserError = DeleteUserErrors[keyof DeleteUserErrors];
type DeleteUserResponses = {
    /**
     * OK
     */
    200: CurrentUser;
};
type DeleteUserResponse = DeleteUserResponses[keyof DeleteUserResponses];
type RegisterUserAccountData = {
    body: RegisterUserAccountRequest;
    path?: never;
    query?: never;
    url: '/auth/register';
};
type RegisterUserAccountErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type RegisterUserAccountError = RegisterUserAccountErrors[keyof RegisterUserAccountErrors];
type RegisterUserAccountResponses = {
    /**
     * OK
     */
    200: CurrentUser;
};
type RegisterUserAccountResponse = RegisterUserAccountResponses[keyof RegisterUserAccountResponses];
type ResendEmailConfirmationData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/user/resendEmail';
};
type ResendEmailConfirmationErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type ResendEmailConfirmationError = ResendEmailConfirmationErrors[keyof ResendEmailConfirmationErrors];
type ResendEmailConfirmationResponses = {
    /**
     * OK
     */
    200: Success;
};
type ResendEmailConfirmationResponse = ResendEmailConfirmationResponses[keyof ResendEmailConfirmationResponses];
type ConfirmEmailData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Target user for which to verify email.
         */
        id: string;
        /**
         * Token to verify email.
         */
        verify_email: string;
    };
    url: '/auth/confirmEmail';
};
type VerifyLoginPlaceData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Filter by UserID.
         */
        userId?: string;
        /**
         * Token to verify login attempt.
         */
        token: string;
    };
    url: '/auth/verifyLoginPlace';
};
type GetGlobalAvatarModerationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/user/avatarmoderations';
};
type GetGlobalAvatarModerationsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetGlobalAvatarModerationsError = GetGlobalAvatarModerationsErrors[keyof GetGlobalAvatarModerationsErrors];
type GetGlobalAvatarModerationsResponses = {
    /**
     * Returns list of globally blocked avatars with timestamps
     */
    200: Array<AvatarModeration>;
};
type GetGlobalAvatarModerationsResponse = GetGlobalAvatarModerationsResponses[keyof GetGlobalAvatarModerationsResponses];
type GetOwnAvatarData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/users/{userId}/avatar';
};
type GetOwnAvatarErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to see another users current avatar without sufficient admin permissions.
     */
    403: _Error;
};
type GetOwnAvatarError = GetOwnAvatarErrors[keyof GetOwnAvatarErrors];
type GetOwnAvatarResponses = {
    /**
     * Returns a single Avatar object.
     */
    200: Avatar;
};
type GetOwnAvatarResponse = GetOwnAvatarResponses[keyof GetOwnAvatarResponses];
type SearchAvatarsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * Set to `me` for searching own avatars.
         */
        user?: 'me';
        /**
         * Filter by UserID.
         */
        userId?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The platform the asset supports.
         */
        platform?: string;
    };
    url: '/avatars';
};
type SearchAvatarsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type SearchAvatarsError = SearchAvatarsErrors[keyof SearchAvatarsErrors];
type SearchAvatarsResponses = {
    /**
     * Returns a list of Avatar objects.
     */
    200: Array<Avatar>;
};
type SearchAvatarsResponse = SearchAvatarsResponses[keyof SearchAvatarsResponses];
type CreateAvatarData = {
    body?: CreateAvatarRequest;
    path?: never;
    query?: never;
    url: '/avatars';
};
type CreateAvatarErrors = {
    /**
     * Error response due to missing permissions.
     */
    400: _Error;
    /**
     * Error response when set featured to true without being an admin.
     */
    401: _Error;
};
type CreateAvatarError = CreateAvatarErrors[keyof CreateAvatarErrors];
type CreateAvatarResponses = {
    /**
     * Returns a single Avatar object.
     */
    200: Avatar;
};
type CreateAvatarResponse = CreateAvatarResponses[keyof CreateAvatarResponses];
type GetAvatarStylesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/avatarStyles';
};
type GetAvatarStylesResponses = {
    /**
     * Returns a list of AvatarStyle objects.
     */
    200: Array<AvatarStyle>;
};
type GetAvatarStylesResponse = GetAvatarStylesResponses[keyof GetAvatarStylesResponses];
type DeleteAvatarData = {
    body?: never;
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
    query?: never;
    url: '/avatars/{avatarId}';
};
type DeleteAvatarErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent avatar.
     */
    404: _Error;
};
type DeleteAvatarError = DeleteAvatarErrors[keyof DeleteAvatarErrors];
type DeleteAvatarResponses = {
    /**
     * Returns a single Avatar object.
     */
    200: Avatar;
};
type DeleteAvatarResponse = DeleteAvatarResponses[keyof DeleteAvatarResponses];
type GetAvatarData = {
    body?: never;
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
    query?: never;
    url: '/avatars/{avatarId}';
};
type GetAvatarErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent avatar.
     */
    404: _Error;
};
type GetAvatarError = GetAvatarErrors[keyof GetAvatarErrors];
type GetAvatarResponses = {
    /**
     * Returns a single Avatar object.
     */
    200: Avatar;
};
type GetAvatarResponse = GetAvatarResponses[keyof GetAvatarResponses];
type UpdateAvatarData = {
    body?: UpdateAvatarRequest;
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
    query?: never;
    url: '/avatars/{avatarId}';
};
type UpdateAvatarErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent avatar.
     */
    404: _Error;
};
type UpdateAvatarError = UpdateAvatarErrors[keyof UpdateAvatarErrors];
type UpdateAvatarResponses = {
    /**
     * Returns a single Avatar object.
     */
    200: Avatar;
};
type UpdateAvatarResponse = UpdateAvatarResponses[keyof UpdateAvatarResponses];
type SelectAvatarData = {
    body?: never;
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
    query?: never;
    url: '/avatars/{avatarId}/select';
};
type SelectAvatarErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent avatar.
     */
    404: _Error;
};
type SelectAvatarError = SelectAvatarErrors[keyof SelectAvatarErrors];
type SelectAvatarResponses = {
    /**
     * Returns a single CurrentUser object.
     */
    200: CurrentUser;
};
type SelectAvatarResponse = SelectAvatarResponses[keyof SelectAvatarResponses];
type SelectFallbackAvatarData = {
    body?: never;
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
    query?: never;
    url: '/avatars/{avatarId}/selectFallback';
};
type SelectFallbackAvatarErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to select a fallback avatar that is missing the fallback tag.
     */
    403: _Error;
    /**
     * Error response when trying to show information about a non-existent avatar.
     */
    404: _Error;
};
type SelectFallbackAvatarError = SelectFallbackAvatarErrors[keyof SelectFallbackAvatarErrors];
type SelectFallbackAvatarResponses = {
    /**
     * Returns a single CurrentUser object.
     */
    200: CurrentUser;
};
type SelectFallbackAvatarResponse = SelectFallbackAvatarResponses[keyof SelectFallbackAvatarResponses];
type GetFavoritedAvatarsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Filters by world name.
         */
        search?: string;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The platform the asset supports.
         */
        platform?: string;
        /**
         * Target user to see information on, admin-only.
         */
        userId?: string;
    };
    url: '/avatars/favorites';
};
type GetFavoritedAvatarsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to see favourited avatars of another user without sufficient admin permissions.
     */
    403: _Error;
};
type GetFavoritedAvatarsError = GetFavoritedAvatarsErrors[keyof GetFavoritedAvatarsErrors];
type GetFavoritedAvatarsResponses = {
    /**
     * Returns a list of Avatar objects.
     */
    200: Array<Avatar>;
};
type GetFavoritedAvatarsResponse = GetFavoritedAvatarsResponses[keyof GetFavoritedAvatarsResponses];
type GetLicensedAvatarsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/avatars/licensed';
};
type GetLicensedAvatarsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetLicensedAvatarsError = GetLicensedAvatarsErrors[keyof GetLicensedAvatarsErrors];
type GetLicensedAvatarsResponses = {
    /**
     * Returns a list of Avatar objects.
     */
    200: Array<Avatar>;
};
type GetLicensedAvatarsResponse = GetLicensedAvatarsResponses[keyof GetLicensedAvatarsResponses];
type EnqueueImpostorData = {
    body?: never;
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
    query?: never;
    url: '/avatars/{avatarId}/impostor/enqueue';
};
type EnqueueImpostorErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent avatar.
     */
    404: _Error;
};
type EnqueueImpostorError = EnqueueImpostorErrors[keyof EnqueueImpostorErrors];
type EnqueueImpostorResponses = {
    /**
     * Returns a Service Status.
     */
    200: ServiceStatus;
};
type EnqueueImpostorResponse = EnqueueImpostorResponses[keyof EnqueueImpostorResponses];
type GetImpostorQueueStatsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/avatars/impostor/queue/stats';
};
type GetImpostorQueueStatsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetImpostorQueueStatsError = GetImpostorQueueStatsErrors[keyof GetImpostorQueueStatsErrors];
type GetImpostorQueueStatsResponses = {
    /**
     * Returns a Service Queue Stats.
     */
    200: ServiceQueueStats;
};
type GetImpostorQueueStatsResponse = GetImpostorQueueStatsResponses[keyof GetImpostorQueueStatsResponses];
type DeleteImpostorData = {
    body?: never;
    path: {
        /**
         * Must be a valid avatar ID.
         */
        avatarId: string;
    };
    query?: never;
    url: '/avatars/{avatarId}/impostor';
};
type DeleteImpostorErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent avatar.
     */
    404: _Error;
};
type DeleteImpostorError = DeleteImpostorErrors[keyof DeleteImpostorErrors];
type DeleteImpostorResponses = {
    /**
     * The Impostors generated for that avatar are deleted.
     */
    200: unknown;
};
type GetCalendarEventsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The month to search in.
         */
        date?: Date;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/calendar';
};
type GetCalendarEventsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetCalendarEventsError = GetCalendarEventsErrors[keyof GetCalendarEventsErrors];
type GetCalendarEventsResponses = {
    /**
     * Returns a list of CalendarEvent objects.
     */
    200: PaginatedCalendarEventList;
};
type GetCalendarEventsResponse = GetCalendarEventsResponses[keyof GetCalendarEventsResponses];
type GetFeaturedCalendarEventsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The month to search in.
         */
        date?: Date;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/calendar/featured';
};
type GetFeaturedCalendarEventsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetFeaturedCalendarEventsError = GetFeaturedCalendarEventsErrors[keyof GetFeaturedCalendarEventsErrors];
type GetFeaturedCalendarEventsResponses = {
    /**
     * Returns a list of CalendarEvent objects.
     */
    200: PaginatedCalendarEventList;
};
type GetFeaturedCalendarEventsResponse = GetFeaturedCalendarEventsResponses[keyof GetFeaturedCalendarEventsResponses];
type GetFollowedCalendarEventsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The month to search in.
         */
        date?: Date;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/calendar/following';
};
type GetFollowedCalendarEventsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetFollowedCalendarEventsError = GetFollowedCalendarEventsErrors[keyof GetFollowedCalendarEventsErrors];
type GetFollowedCalendarEventsResponses = {
    /**
     * Returns a list of CalendarEvent objects.
     */
    200: PaginatedCalendarEventList;
};
type GetFollowedCalendarEventsResponse = GetFollowedCalendarEventsResponses[keyof GetFollowedCalendarEventsResponses];
type SearchCalendarEventsData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Search term for calendar events.
         */
        searchTerm: string;
        /**
         * The offset from UTC in hours of the client or authenticated user.
         */
        utcOffset?: number;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/calendar/search';
};
type SearchCalendarEventsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type SearchCalendarEventsError = SearchCalendarEventsErrors[keyof SearchCalendarEventsErrors];
type SearchCalendarEventsResponses = {
    /**
     * Returns a list of CalendarEvent objects.
     */
    200: PaginatedCalendarEventList;
};
type SearchCalendarEventsResponse = SearchCalendarEventsResponses[keyof SearchCalendarEventsResponses];
type GetGroupCalendarEventsData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The month to search in.
         */
        date?: Date;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/calendar/{groupId}';
};
type GetGroupCalendarEventsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetGroupCalendarEventsError = GetGroupCalendarEventsErrors[keyof GetGroupCalendarEventsErrors];
type GetGroupCalendarEventsResponses = {
    /**
     * Returns a list of CalendarEvent objects.
     */
    200: PaginatedCalendarEventList;
};
type GetGroupCalendarEventsResponse = GetGroupCalendarEventsResponses[keyof GetGroupCalendarEventsResponses];
type CreateGroupCalendarEventData = {
    body: CreateCalendarEventRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/calendar/{groupId}/event';
};
type CreateGroupCalendarEventErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type CreateGroupCalendarEventError = CreateGroupCalendarEventErrors[keyof CreateGroupCalendarEventErrors];
type CreateGroupCalendarEventResponses = {
    /**
     * Returns a single CalendarEvent object.
     */
    200: CalendarEvent;
};
type CreateGroupCalendarEventResponse = CreateGroupCalendarEventResponses[keyof CreateGroupCalendarEventResponses];
type DeleteGroupCalendarEventData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid calendar ID.
         */
        calendarId: string;
    };
    query?: never;
    url: '/calendar/{groupId}/{calendarId}';
};
type DeleteGroupCalendarEventErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type DeleteGroupCalendarEventError = DeleteGroupCalendarEventErrors[keyof DeleteGroupCalendarEventErrors];
type DeleteGroupCalendarEventResponses = {
    /**
     * Successful response after deleting a calendar event.
     */
    200: Success;
};
type DeleteGroupCalendarEventResponse = DeleteGroupCalendarEventResponses[keyof DeleteGroupCalendarEventResponses];
type GetGroupCalendarEventData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid calendar ID.
         */
        calendarId: string;
    };
    query?: never;
    url: '/calendar/{groupId}/{calendarId}';
};
type GetGroupCalendarEventErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetGroupCalendarEventError = GetGroupCalendarEventErrors[keyof GetGroupCalendarEventErrors];
type GetGroupCalendarEventResponses = {
    /**
     * Returns a single CalendarEvent object.
     */
    200: CalendarEvent;
};
type GetGroupCalendarEventResponse = GetGroupCalendarEventResponses[keyof GetGroupCalendarEventResponses];
type GetGroupCalendarEventIcsData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid calendar ID.
         */
        calendarId: string;
    };
    query?: never;
    url: '/calendar/{groupId}/{calendarId}.ics';
};
type GetGroupCalendarEventIcsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to download ICS calendar of a non-existent calendar entry.
     */
    404: _Error;
};
type GetGroupCalendarEventIcsError = GetGroupCalendarEventIcsErrors[keyof GetGroupCalendarEventIcsErrors];
type GetGroupCalendarEventIcsResponses = {
    /**
     * iCalendar file download
     */
    200: Blob | File;
};
type GetGroupCalendarEventIcsResponse = GetGroupCalendarEventIcsResponses[keyof GetGroupCalendarEventIcsResponses];
type UpdateGroupCalendarEventData = {
    body: UpdateCalendarEventRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid calendar ID.
         */
        calendarId: string;
    };
    query?: never;
    url: '/calendar/{groupId}/{calendarId}/event';
};
type UpdateGroupCalendarEventErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type UpdateGroupCalendarEventError = UpdateGroupCalendarEventErrors[keyof UpdateGroupCalendarEventErrors];
type UpdateGroupCalendarEventResponses = {
    /**
     * Returns a single CalendarEvent object.
     */
    200: CalendarEvent;
};
type UpdateGroupCalendarEventResponse = UpdateGroupCalendarEventResponses[keyof UpdateGroupCalendarEventResponses];
type FollowGroupCalendarEventData = {
    body: FollowCalendarEventRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid calendar ID.
         */
        calendarId: string;
    };
    query?: never;
    url: '/calendar/{groupId}/{calendarId}/follow';
};
type FollowGroupCalendarEventErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type FollowGroupCalendarEventError = FollowGroupCalendarEventErrors[keyof FollowGroupCalendarEventErrors];
type FollowGroupCalendarEventResponses = {
    /**
     * Returns a single CalendarEvent object.
     */
    200: CalendarEvent;
};
type FollowGroupCalendarEventResponse = FollowGroupCalendarEventResponses[keyof FollowGroupCalendarEventResponses];
type GetSteamTransactionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Steam/transactions';
};
type GetSteamTransactionsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetSteamTransactionsError = GetSteamTransactionsErrors[keyof GetSteamTransactionsErrors];
type GetSteamTransactionsResponses = {
    /**
     * Returns a list of Transaction objects.
     */
    200: Array<Transaction>;
};
type GetSteamTransactionsResponse = GetSteamTransactionsResponses[keyof GetSteamTransactionsResponses];
type GetSteamTransactionData = {
    body?: never;
    path: {
        /**
         * Must be a valid transaction ID.
         */
        transactionId: string;
    };
    query?: never;
    url: '/Steam/transactions/{transactionId}';
};
type GetSteamTransactionErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetSteamTransactionError = GetSteamTransactionErrors[keyof GetSteamTransactionErrors];
type GetSteamTransactionResponses = {
    /**
     * Returns a single Transaction object.
     */
    200: Transaction;
};
type GetSteamTransactionResponse = GetSteamTransactionResponses[keyof GetSteamTransactionResponses];
type GetAdminTransactionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/Admin/transactions';
};
type GetAdminTransactionsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetAdminTransactionsError = GetAdminTransactionsErrors[keyof GetAdminTransactionsErrors];
type GetAdminTransactionsResponses = {
    /**
     * Returns a list of Transaction objects.
     */
    200: Array<Transaction>;
};
type GetAdminTransactionsResponse = GetAdminTransactionsResponses[keyof GetAdminTransactionsResponses];
type GetAdminTransactionData = {
    body?: never;
    path: {
        /**
         * Must be a valid transaction ID.
         */
        transactionId: string;
    };
    query?: never;
    url: '/Admin/transactions/{transactionId}';
};
type GetAdminTransactionErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetAdminTransactionError = GetAdminTransactionErrors[keyof GetAdminTransactionErrors];
type GetAdminTransactionResponses = {
    /**
     * Returns a single Transaction object.
     */
    200: Transaction;
};
type GetAdminTransactionResponse = GetAdminTransactionResponses[keyof GetAdminTransactionResponses];
type GetCurrentSubscriptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/user/subscription';
};
type GetCurrentSubscriptionsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetCurrentSubscriptionsError = GetCurrentSubscriptionsErrors[keyof GetCurrentSubscriptionsErrors];
type GetCurrentSubscriptionsResponses = {
    /**
     * Returns a list of UserSubscription objects.
     */
    200: Array<UserSubscription>;
};
type GetCurrentSubscriptionsResponse = GetCurrentSubscriptionsResponses[keyof GetCurrentSubscriptionsResponses];
type GetUserSubscriptionEligibleData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: {
        /**
         * The Steam ID of the user.
         */
        steamId?: string;
    };
    url: '/users/{userId}/subscription/eligible';
};
type GetUserSubscriptionEligibleErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetUserSubscriptionEligibleError = GetUserSubscriptionEligibleErrors[keyof GetUserSubscriptionEligibleErrors];
type GetUserSubscriptionEligibleResponses = {
    /**
     * Returns a single UserSubscriptionEligible object.
     */
    200: UserSubscriptionEligible;
};
type GetUserSubscriptionEligibleResponse = GetUserSubscriptionEligibleResponses[keyof GetUserSubscriptionEligibleResponses];
type GetSubscriptionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/subscriptions';
};
type GetSubscriptionsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetSubscriptionsError = GetSubscriptionsErrors[keyof GetSubscriptionsErrors];
type GetSubscriptionsResponses = {
    /**
     * Returns a list of Subscription objects.
     */
    200: Array<Subscription>;
};
type GetSubscriptionsResponse = GetSubscriptionsResponses[keyof GetSubscriptionsResponses];
type GetLicenseGroupData = {
    body?: never;
    path: {
        /**
         * Must be a valid license group ID.
         */
        licenseGroupId: string;
    };
    query?: never;
    url: '/licenseGroups/{licenseGroupId}';
};
type GetLicenseGroupErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetLicenseGroupError = GetLicenseGroupErrors[keyof GetLicenseGroupErrors];
type GetLicenseGroupResponses = {
    /**
     * Returns a single LicenseGroup object.
     */
    200: LicenseGroup;
};
type GetLicenseGroupResponse = GetLicenseGroupResponses[keyof GetLicenseGroupResponses];
type GetProductListingData = {
    body?: never;
    path: {
        /**
         * Must be a valid product ID.
         */
        productId: string;
    };
    query?: {
        /**
         * Populates some fields and changes types of others for certain objects.
         */
        hydrate?: boolean;
    };
    url: '/listing/{productId}';
};
type GetProductListingErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetProductListingError = GetProductListingErrors[keyof GetProductListingErrors];
type GetProductListingResponses = {
    /**
     * Returns a single ProductListing object.
     */
    200: ProductListing;
};
type GetProductListingResponse = GetProductListingResponses[keyof GetProductListingResponses];
type GetProductListingsData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Populates some fields and changes types of others for certain objects.
         */
        hydrate?: boolean;
        /**
         * Must be a valid group ID.
         */
        groupId?: string;
        /**
         * Filter for users' listings and inventory bundles.
         */
        active?: boolean;
    };
    url: '/user/{userId}/listings';
};
type GetProductListingsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetProductListingsError = GetProductListingsErrors[keyof GetProductListingsErrors];
type GetProductListingsResponses = {
    /**
     * Returns a list of ProductListing objects.
     */
    200: Array<ProductListing>;
};
type GetProductListingsResponse = GetProductListingsResponses[keyof GetProductListingsResponses];
type GetTokenBundlesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/tokenBundles';
};
type GetTokenBundlesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetTokenBundlesError = GetTokenBundlesErrors[keyof GetTokenBundlesErrors];
type GetTokenBundlesResponses = {
    /**
     * Returns a list of TokenBundle objects.
     */
    200: Array<TokenBundle>;
};
type GetTokenBundlesResponse = GetTokenBundlesResponses[keyof GetTokenBundlesResponses];
type GetTiliaStatusData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/tilia/status';
};
type GetTiliaStatusErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetTiliaStatusError = GetTiliaStatusErrors[keyof GetTiliaStatusErrors];
type GetTiliaStatusResponses = {
    /**
     * Returns a single TiliaStatus object.
     */
    200: TiliaStatus;
};
type GetTiliaStatusResponse = GetTiliaStatusResponses[keyof GetTiliaStatusResponses];
type GetTiliaTosData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/user/{userId}/tilia/tos';
};
type GetTiliaTosErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetTiliaTosError = GetTiliaTosErrors[keyof GetTiliaTosErrors];
type GetTiliaTosResponses = {
    /**
     * Returns a single TiliaTOS object.
     */
    200: TiliaTos;
};
type GetTiliaTosResponse = GetTiliaTosResponses[keyof GetTiliaTosResponses];
type GetBalanceData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/user/{userId}/balance';
};
type GetBalanceErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetBalanceError = GetBalanceErrors[keyof GetBalanceErrors];
type GetBalanceResponses = {
    /**
     * Returns a single Balance object.
     */
    200: Balance;
};
type GetBalanceResponse = GetBalanceResponses[keyof GetBalanceResponses];
type GetBalanceEarningsData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/user/{userId}/balance/earnings';
};
type GetBalanceEarningsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetBalanceEarningsError = GetBalanceEarningsErrors[keyof GetBalanceEarningsErrors];
type GetBalanceEarningsResponses = {
    /**
     * Returns a single Balance object.
     */
    200: Balance;
};
type GetBalanceEarningsResponse = GetBalanceEarningsResponses[keyof GetBalanceEarningsResponses];
type GetEconomyAccountData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/user/{userId}/economy/account';
};
type GetEconomyAccountErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetEconomyAccountError = GetEconomyAccountErrors[keyof GetEconomyAccountErrors];
type GetEconomyAccountResponses = {
    /**
     * Returns a single EconomyAccount object.
     */
    200: EconomyAccount;
};
type GetEconomyAccountResponse = GetEconomyAccountResponses[keyof GetEconomyAccountResponses];
type GetActiveLicensesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/economy/licenses/active';
};
type GetActiveLicensesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetActiveLicensesError = GetActiveLicensesErrors[keyof GetActiveLicensesErrors];
type GetActiveLicensesResponses = {
    /**
     * Returns a list of License objects.
     */
    200: Array<License>;
};
type GetActiveLicensesResponse = GetActiveLicensesResponses[keyof GetActiveLicensesResponses];
type GetStoreData = {
    body?: never;
    path?: never;
    query: {
        storeId: StoreId;
        /**
         * Listings fields will be populated.
         */
        hydrateListings?: boolean;
        /**
         * Products fields will be populated.
         */
        hydrateProducts?: boolean;
    };
    url: '/economy/store';
};
type GetStoreErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetStoreError = GetStoreErrors[keyof GetStoreErrors];
type GetStoreResponses = {
    /**
     * Returns a single Store object.
     */
    200: Store;
};
type GetStoreResponse = GetStoreResponses[keyof GetStoreResponses];
type GetStoreShelvesData = {
    body?: never;
    path?: never;
    query: {
        storeId: StoreId;
        /**
         * Listings fields will be populated.
         */
        hydrateListings?: boolean;
        fetch?: StoreView;
    };
    url: '/economy/store/shelves';
};
type GetStoreShelvesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetStoreShelvesError = GetStoreShelvesErrors[keyof GetStoreShelvesErrors];
type GetStoreShelvesResponses = {
    /**
     * Returns a list of StoreShelf objects.
     */
    200: Array<StoreShelf>;
};
type GetStoreShelvesResponse = GetStoreShelvesResponses[keyof GetStoreShelvesResponses];
type GetFavoritesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * The type of favorites to return, FavoriteType.
         */
        type?: string;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
    };
    url: '/favorites';
};
type GetFavoritesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetFavoritesError = GetFavoritesErrors[keyof GetFavoritesErrors];
type GetFavoritesResponses = {
    /**
     * Returns a list of Favorite objects.
     */
    200: Array<Favorite>;
};
type GetFavoritesResponse = GetFavoritesResponses[keyof GetFavoritesResponses];
type AddFavoriteData = {
    body?: AddFavoriteRequest;
    path?: never;
    query?: never;
    url: '/favorites';
};
type AddFavoriteErrors = {
    /**
     * Error response when trying favorite someone or something when already having it/them favorited.
     */
    400: _Error;
    /**
     * Error response when trying favorite someone whom you are not friends with.
     */
    403: _Error;
};
type AddFavoriteError = AddFavoriteErrors[keyof AddFavoriteErrors];
type AddFavoriteResponses = {
    /**
     * Returns a single Favorite object.
     */
    200: Favorite;
};
type AddFavoriteResponse = AddFavoriteResponses[keyof AddFavoriteResponses];
type RemoveFavoriteData = {
    body?: never;
    path: {
        /**
         * Must be a valid favorite ID.
         */
        favoriteId: string;
    };
    query?: never;
    url: '/favorites/{favoriteId}';
};
type RemoveFavoriteErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent favorite.
     */
    404: _Error;
};
type RemoveFavoriteError = RemoveFavoriteErrors[keyof RemoveFavoriteErrors];
type RemoveFavoriteResponses = {
    /**
     * Success response after removing a favorite.
     */
    200: Success;
};
type RemoveFavoriteResponse = RemoveFavoriteResponses[keyof RemoveFavoriteResponses];
type GetFavoriteGroupsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Target user to see information on, admin-only.
         */
        userId?: string;
        /**
         * The owner of whoms favorite groups to return. Must be a UserID.
         */
        ownerId?: string;
    };
    url: '/favorite/groups';
};
type GetFavoriteGroupsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetFavoriteGroupsError = GetFavoriteGroupsErrors[keyof GetFavoriteGroupsErrors];
type GetFavoriteGroupsResponses = {
    /**
     * Returns a list of FavoriteGroup objects.
     */
    200: Array<FavoriteGroup>;
};
type GetFavoriteGroupsResponse = GetFavoriteGroupsResponses[keyof GetFavoriteGroupsResponses];
type ClearFavoriteGroupData = {
    body?: never;
    path: {
        /**
         * The type of group to fetch, must be a valid FavoriteType.
         */
        favoriteGroupType: 'world' | 'friend' | 'avatar';
        /**
         * The name of the group to fetch, must be a name of a FavoriteGroup.
         */
        favoriteGroupName: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}';
};
type ClearFavoriteGroupResponses = {
    /**
     * Success response after clearing a favorite group.
     */
    200: Success;
};
type ClearFavoriteGroupResponse = ClearFavoriteGroupResponses[keyof ClearFavoriteGroupResponses];
type GetFavoriteGroupData = {
    body?: never;
    path: {
        /**
         * The type of group to fetch, must be a valid FavoriteType.
         */
        favoriteGroupType: 'world' | 'friend' | 'avatar';
        /**
         * The name of the group to fetch, must be a name of a FavoriteGroup.
         */
        favoriteGroupName: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}';
};
type GetFavoriteGroupResponses = {
    /**
     * Returns a single FavoriteGroup object.
     */
    200: FavoriteGroup;
};
type GetFavoriteGroupResponse = GetFavoriteGroupResponses[keyof GetFavoriteGroupResponses];
type UpdateFavoriteGroupData = {
    body?: UpdateFavoriteGroupRequest;
    path: {
        /**
         * The type of group to fetch, must be a valid FavoriteType.
         */
        favoriteGroupType: 'world' | 'friend' | 'avatar';
        /**
         * The name of the group to fetch, must be a name of a FavoriteGroup.
         */
        favoriteGroupName: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/favorite/group/{favoriteGroupType}/{favoriteGroupName}/{userId}';
};
type UpdateFavoriteGroupResponses = {
    /**
     * OK
     */
    200: unknown;
};
type GetFavoriteLimitsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/user/favoritelimits';
};
type GetFavoriteLimitsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetFavoriteLimitsError = GetFavoriteLimitsErrors[keyof GetFavoriteLimitsErrors];
type GetFavoriteLimitsResponses = {
    /**
     * Returns a single FavoriteLimits object.
     */
    200: FavoriteLimits;
};
type GetFavoriteLimitsResponse = GetFavoriteLimitsResponses[keyof GetFavoriteLimitsResponses];
type GetFilesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Tag, for example "icon" or "gallery", not included by default.
         */
        tag?: string;
        /**
         * UserID, will always generate a 500 permission error.
         * @deprecated
         */
        userId?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/files';
};
type GetFilesResponses = {
    /**
     * Returns a list of File objects.
     */
    200: Array<File>;
};
type GetFilesResponse = GetFilesResponses[keyof GetFilesResponses];
type CreateFileData = {
    body?: CreateFileRequest;
    path?: never;
    query?: never;
    url: '/file';
};
type CreateFileResponses = {
    /**
     * Returns a single File object.
     */
    200: File;
};
type CreateFileResponse = CreateFileResponses[keyof CreateFileResponses];
type DeleteFileData = {
    body?: never;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
    };
    query?: never;
    url: '/file/{fileId}';
};
type DeleteFileErrors = {
    /**
     * Error response when trying to delete a non-existent file.
     */
    404: _Error;
};
type DeleteFileError = DeleteFileErrors[keyof DeleteFileErrors];
type DeleteFileResponses = {
    /**
     * Returns a single File object.
     */
    200: File;
};
type DeleteFileResponse = DeleteFileResponses[keyof DeleteFileResponses];
type GetFileData = {
    body?: never;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
    };
    query?: never;
    url: '/file/{fileId}';
};
type GetFileErrors = {
    /**
     * Error response when trying to show information about a non-existent file.
     */
    404: _Error;
};
type GetFileError = GetFileErrors[keyof GetFileErrors];
type GetFileResponses = {
    /**
     * Returns a single File object.
     */
    200: File;
};
type GetFileResponse = GetFileResponses[keyof GetFileResponses];
type CreateFileVersionData = {
    body?: CreateFileVersionRequest;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
    };
    query?: never;
    url: '/file/{fileId}';
};
type CreateFileVersionResponses = {
    /**
     * Returns a single File object.
     */
    200: File;
};
type CreateFileVersionResponse = CreateFileVersionResponses[keyof CreateFileVersionResponses];
type DeleteFileVersionData = {
    body?: never;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Version ID of the asset.
         */
        versionId: number;
    };
    query?: never;
    url: '/file/{fileId}/{versionId}';
};
type DeleteFileVersionErrors = {
    /**
     * Error response when trying to delete the initial version of a file. Delete the main File object instead.
     */
    400: _Error;
    /**
     * Error response when trying to delete any version of a file that is not the last one.
     */
    500: _Error;
};
type DeleteFileVersionError = DeleteFileVersionErrors[keyof DeleteFileVersionErrors];
type DeleteFileVersionResponses = {
    /**
     * Returns a single File object.
     */
    200: File;
};
type DeleteFileVersionResponse = DeleteFileVersionResponses[keyof DeleteFileVersionResponses];
type DownloadFileVersionData = {
    body?: never;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Version ID of the asset.
         */
        versionId: number;
    };
    query?: never;
    url: '/file/{fileId}/{versionId}';
};
type DownloadFileVersionErrors = {
    /**
     * Error response when trying to show information about a non-existent file.
     */
    404: _Error;
};
type DownloadFileVersionError = DownloadFileVersionErrors[keyof DownloadFileVersionErrors];
type DownloadFileVersionResponses = {
    /**
     * Raw file
     */
    200: Blob | File;
};
type DownloadFileVersionResponse = DownloadFileVersionResponses[keyof DownloadFileVersionResponses];
type FinishFileDataUploadData = {
    /**
     * Please see documentation on ETag's:
     * [https://teppen.io/2018/06/23/aws_s3_etags/](https://teppen.io/2018/06/23/aws_s3_etags/)
     *
     * ETag's should NOT be present when uploading a `signature`.
     */
    body?: FinishFileDataUploadRequest;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Version ID of the asset.
         */
        versionId: number;
        /**
         * Type of file.
         */
        fileType: 'file' | 'signature' | 'delta';
    };
    query?: never;
    url: '/file/{fileId}/{versionId}/{fileType}/finish';
};
type FinishFileDataUploadResponses = {
    /**
     * Returns a single File object.
     */
    200: File;
};
type FinishFileDataUploadResponse = FinishFileDataUploadResponses[keyof FinishFileDataUploadResponses];
type StartFileDataUploadData = {
    body?: never;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Version ID of the asset.
         */
        versionId: number;
        /**
         * Type of file.
         */
        fileType: 'file' | 'signature' | 'delta';
    };
    query?: {
        /**
         * The part number to start uploading. If not provided, the first part will be started.
         * @deprecated
         */
        partNumber?: number;
    };
    url: '/file/{fileId}/{versionId}/{fileType}/start';
};
type StartFileDataUploadErrors = {
    /**
     * Error response when trying to start an upload against a FileVersion that is already marked as  `complete`.
     */
    400: _Error;
};
type StartFileDataUploadError = StartFileDataUploadErrors[keyof StartFileDataUploadErrors];
type StartFileDataUploadResponses = {
    /**
     * See [https://docs.aws.amazon.com/AmazonS3/latest/API/API_PutObject.html](AWS REST docs - PUT Object)
     */
    200: FileUploadUrl;
};
type StartFileDataUploadResponse = StartFileDataUploadResponses[keyof StartFileDataUploadResponses];
type GetFileDataUploadStatusData = {
    body?: never;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Version ID of the asset.
         */
        versionId: number;
        /**
         * Type of file.
         */
        fileType: 'file' | 'signature' | 'delta';
    };
    query?: never;
    url: '/file/{fileId}/{versionId}/{fileType}/status';
};
type GetFileDataUploadStatusResponses = {
    /**
     * Current FileVersion upload status. Contains the uploadId needed for uploading, as well as the already uploaded parts.
     */
    200: FileVersionUploadStatus;
};
type GetFileDataUploadStatusResponse = GetFileDataUploadStatusResponses[keyof GetFileDataUploadStatusResponses];
type GetFileAnalysisData = {
    body?: never;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Version ID of the asset.
         */
        versionId: number;
    };
    query?: never;
    url: '/analysis/{fileId}/{versionId}';
};
type GetFileAnalysisErrors = {
    /**
     * Error response when trying to show information about a non-existent file.
     */
    404: _Error;
};
type GetFileAnalysisError = GetFileAnalysisErrors[keyof GetFileAnalysisErrors];
type GetFileAnalysisResponses = {
    /**
     * Returns a single FileAnalysis object.
     */
    200: FileAnalysis;
    /**
     * Error response when requesting file Analysis that is not yet available.
     */
    202: _Error;
};
type GetFileAnalysisResponse = GetFileAnalysisResponses[keyof GetFileAnalysisResponses];
type GetFileAnalysisSecurityData = {
    body?: never;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Version ID of the asset.
         */
        versionId: number;
    };
    query?: never;
    url: '/analysis/{fileId}/{versionId}/security';
};
type GetFileAnalysisSecurityErrors = {
    /**
     * Error response when trying to show information about a non-existent file.
     */
    404: _Error;
};
type GetFileAnalysisSecurityError = GetFileAnalysisSecurityErrors[keyof GetFileAnalysisSecurityErrors];
type GetFileAnalysisSecurityResponses = {
    /**
     * Returns a single FileAnalysis object.
     */
    200: FileAnalysis;
    /**
     * Error response when requesting file Analysis that is not yet available.
     */
    202: _Error;
};
type GetFileAnalysisSecurityResponse = GetFileAnalysisSecurityResponses[keyof GetFileAnalysisSecurityResponses];
type GetFileAnalysisStandardData = {
    body?: never;
    path: {
        /**
         * Must be a valid file ID.
         */
        fileId: string;
        /**
         * Version ID of the asset.
         */
        versionId: number;
    };
    query?: never;
    url: '/analysis/{fileId}/{versionId}/standard';
};
type GetFileAnalysisStandardErrors = {
    /**
     * Error response when trying to show information about a non-existent file.
     */
    404: _Error;
};
type GetFileAnalysisStandardError = GetFileAnalysisStandardErrors[keyof GetFileAnalysisStandardErrors];
type GetFileAnalysisStandardResponses = {
    /**
     * Returns a single FileAnalysis object.
     */
    200: FileAnalysis;
    /**
     * Error response when requesting file Analysis that is not yet available.
     */
    202: _Error;
};
type GetFileAnalysisStandardResponse = GetFileAnalysisStandardResponses[keyof GetFileAnalysisStandardResponses];
type UploadImageData = {
    body?: {
        /**
         * The binary blob of the png file.
         */
        file: Blob | File;
        /**
         * Needs to be either icon, gallery, sticker, emoji, or emojianimated
         */
        tag: string;
        /**
         * Required for emojianimated. Total number of frames to be animated (2-64)
         */
        frames?: number;
        /**
         * Required for emojianimated. Animation frames per second (1-64)
         */
        framesOverTime?: number;
        /**
         * Animation style for sticker, required for emoji.
         */
        animationStyle?: string;
        /**
         * Mask of the sticker, optional for emoji.
         */
        maskTag?: string;
    };
    path?: never;
    query?: never;
    url: '/file/image';
};
type UploadImageResponses = {
    /**
     * Returns a single File object.
     */
    200: File;
};
type UploadImageResponse = UploadImageResponses[keyof UploadImageResponses];
type UploadIconData = {
    body?: {
        /**
         * The binary blob of the png file.
         */
        file: Blob | File;
    };
    path?: never;
    query?: never;
    url: '/icon';
};
type UploadIconResponses = {
    /**
     * Returns a single File object.
     */
    200: File;
};
type UploadIconResponse = UploadIconResponses[keyof UploadIconResponses];
type UploadGalleryImageData = {
    body?: {
        /**
         * The binary blob of the png file.
         */
        file: Blob | File;
    };
    path?: never;
    query?: never;
    url: '/gallery';
};
type UploadGalleryImageResponses = {
    /**
     * Returns a single File object.
     */
    200: File;
};
type UploadGalleryImageResponse = UploadGalleryImageResponses[keyof UploadGalleryImageResponses];
type GetAdminAssetBundleData = {
    body?: never;
    path: {
        /**
         * Must be a valid admin asset bundle ID.
         */
        adminAssetBundleId: string;
    };
    query?: never;
    url: '/adminassetbundles/{adminAssetBundleId}';
};
type GetAdminAssetBundleResponses = {
    /**
     * Returns a single AdminAssetBundle object.
     */
    200: AdminAssetBundle;
};
type GetAdminAssetBundleResponse = GetAdminAssetBundleResponses[keyof GetAdminAssetBundleResponses];
type GetFriendsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Returns *only* offline users if true, returns only online and active users if false
         */
        offline?: boolean;
    };
    url: '/auth/user/friends';
};
type GetFriendsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetFriendsError = GetFriendsErrors[keyof GetFriendsErrors];
type GetFriendsResponses = {
    /**
     * Returns a list of LimitedUserFriend objects.
     */
    200: Array<LimitedUserFriend>;
};
type GetFriendsResponse = GetFriendsResponses[keyof GetFriendsResponses];
type DeleteFriendRequestData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/user/{userId}/friendRequest';
};
type DeleteFriendRequestErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to delete a non-existent friend-request.
     */
    404: _Error;
};
type DeleteFriendRequestError = DeleteFriendRequestErrors[keyof DeleteFriendRequestErrors];
type DeleteFriendRequestResponses = {
    /**
     * Successful response after cancelling a friend request.
     */
    200: Success;
};
type DeleteFriendRequestResponse = DeleteFriendRequestResponses[keyof DeleteFriendRequestResponses];
type FriendData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/user/{userId}/friendRequest';
};
type FriendErrors = {
    /**
     * Bad request error response when sending a friend request
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to send a friend request to a user which doesn't exist.
     */
    404: _Error;
};
type FriendError = FriendErrors[keyof FriendErrors];
type FriendResponses = {
    /**
     * Returns a single Notifcation object.
     */
    200: Notification;
};
type FriendResponse = FriendResponses[keyof FriendResponses];
type GetFriendStatusData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/user/{userId}/friendStatus';
};
type GetFriendStatusErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetFriendStatusError = GetFriendStatusErrors[keyof GetFriendStatusErrors];
type GetFriendStatusResponses = {
    /**
     * Returns a users Friend Status.
     */
    200: FriendStatus;
};
type GetFriendStatusResponse = GetFriendStatusResponses[keyof GetFriendStatusResponses];
type UnfriendData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/auth/user/friends/{userId}';
};
type UnfriendErrors = {
    /**
     * Error response when trying to unfriend someone who is not a friend.
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type UnfriendError = UnfriendErrors[keyof UnfriendErrors];
type UnfriendResponses = {
    /**
     * Successful response after unfriending a user.
     */
    200: Success;
};
type UnfriendResponse = UnfriendResponses[keyof UnfriendResponses];
type SearchGroupsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Query to search for, can be either Group Name or Group shortCode
         */
        query?: string;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * The number of objects to return.
         */
        n?: number;
    };
    url: '/groups';
};
type SearchGroupsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type SearchGroupsError = SearchGroupsErrors[keyof SearchGroupsErrors];
type SearchGroupsResponses = {
    /**
     * Returns a list of LimitedGroup objects.
     */
    200: Array<LimitedGroup>;
};
type SearchGroupsResponse = SearchGroupsResponses[keyof SearchGroupsResponses];
type CreateGroupData = {
    body: CreateGroupRequest;
    path?: never;
    query?: never;
    url: '/groups';
};
type CreateGroupErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type CreateGroupError = CreateGroupErrors[keyof CreateGroupErrors];
type CreateGroupResponses = {
    /**
     * Returns a single Group object.
     */
    200: Group;
};
type CreateGroupResponse = CreateGroupResponses[keyof CreateGroupResponses];
type GetGroupRoleTemplatesData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/groups/roleTemplates';
};
type GetGroupRoleTemplatesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetGroupRoleTemplatesError = GetGroupRoleTemplatesErrors[keyof GetGroupRoleTemplatesErrors];
type GetGroupRoleTemplatesResponses = {
    /**
     * Returns a dictionary of GroupRoleTemplate objects.
     */
    200: {
        [key: string]: GroupRoleTemplateValues;
    };
};
type GetGroupRoleTemplatesResponse = GetGroupRoleTemplatesResponses[keyof GetGroupRoleTemplatesResponses];
type DeleteGroupData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}';
};
type DeleteGroupErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type DeleteGroupError = DeleteGroupErrors[keyof DeleteGroupErrors];
type DeleteGroupResponses = {
    /**
     * Successful response after deleting a Group.
     */
    200: Success;
};
type DeleteGroupResponse = DeleteGroupResponses[keyof DeleteGroupResponses];
type GetGroupData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * Include roles for the Group object. Defaults to false.
         */
        includeRoles?: boolean;
    };
    url: '/groups/{groupId}';
};
type GetGroupErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupError = GetGroupErrors[keyof GetGroupErrors];
type GetGroupResponses = {
    /**
     * Returns a single Group object.
     */
    200: Group;
};
type GetGroupResponse = GetGroupResponses[keyof GetGroupResponses];
type UpdateGroupData = {
    body?: UpdateGroupRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}';
};
type UpdateGroupErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type UpdateGroupError = UpdateGroupErrors[keyof UpdateGroupErrors];
type UpdateGroupResponses = {
    /**
     * Returns a single Group object.
     */
    200: Group;
};
type UpdateGroupResponse = UpdateGroupResponses[keyof UpdateGroupResponses];
type DeleteGroupAnnouncementData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/announcement';
};
type DeleteGroupAnnouncementErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type DeleteGroupAnnouncementError = DeleteGroupAnnouncementErrors[keyof DeleteGroupAnnouncementErrors];
type DeleteGroupAnnouncementResponses = {
    /**
     * Successful response after deleting/clearing the group announcement.
     */
    200: Success;
};
type DeleteGroupAnnouncementResponse = DeleteGroupAnnouncementResponses[keyof DeleteGroupAnnouncementResponses];
type GetGroupAnnouncementsData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/announcement';
};
type GetGroupAnnouncementsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupAnnouncementsError = GetGroupAnnouncementsErrors[keyof GetGroupAnnouncementsErrors];
type GetGroupAnnouncementsResponses = {
    /**
     * Returns a single GroupAnnouncement object.
     */
    200: GroupAnnouncement;
};
type GetGroupAnnouncementsResponse = GetGroupAnnouncementsResponses[keyof GetGroupAnnouncementsResponses];
type CreateGroupAnnouncementData = {
    body: CreateGroupAnnouncementRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/announcement';
};
type CreateGroupAnnouncementErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type CreateGroupAnnouncementError = CreateGroupAnnouncementErrors[keyof CreateGroupAnnouncementErrors];
type CreateGroupAnnouncementResponses = {
    /**
     * Returns a single GroupAnnouncement object.
     */
    200: GroupAnnouncement;
};
type CreateGroupAnnouncementResponse = CreateGroupAnnouncementResponses[keyof CreateGroupAnnouncementResponses];
type GetGroupAuditLogsData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * The start date of the search range.
         */
        startDate?: Date;
        /**
         * The end date of the search range.
         */
        endDate?: Date;
        /**
         * The comma-separated actor ids to search for.
         */
        actorIds?: string;
        /**
         * The comma-separated event types to search for.
         */
        eventTypes?: string;
        /**
         * The comma-separated target ids to search for.
         */
        targetIds?: string;
    };
    url: '/groups/{groupId}/auditLogs';
};
type GetGroupAuditLogsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupAuditLogsError = GetGroupAuditLogsErrors[keyof GetGroupAuditLogsErrors];
type GetGroupAuditLogsResponses = {
    /**
     * Returns a list of GroupAudit objects, wrapped in new pagination format.
     */
    200: PaginatedGroupAuditLogEntryList;
};
type GetGroupAuditLogsResponse = GetGroupAuditLogsResponses[keyof GetGroupAuditLogsResponses];
type GetGroupBansData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/groups/{groupId}/bans';
};
type GetGroupBansErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response due to missing permissions.
     */
    403: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupBansError = GetGroupBansErrors[keyof GetGroupBansErrors];
type GetGroupBansResponses = {
    /**
     * Returns a list of GroupMember objects.
     */
    200: Array<GroupMember>;
};
type GetGroupBansResponse = GetGroupBansResponses[keyof GetGroupBansResponses];
type BanGroupMemberData = {
    body: BanGroupMemberRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/bans';
};
type BanGroupMemberErrors = {
    /**
     * Bad request error response when banning a user
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type BanGroupMemberError = BanGroupMemberErrors[keyof BanGroupMemberErrors];
type BanGroupMemberResponses = {
    /**
     * Returns a list of GroupMember objects.
     */
    200: GroupMember;
};
type BanGroupMemberResponse = BanGroupMemberResponses[keyof BanGroupMemberResponses];
type UnbanGroupMemberData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/groups/{groupId}/bans/{userId}';
};
type UnbanGroupMemberErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type UnbanGroupMemberError = UnbanGroupMemberErrors[keyof UnbanGroupMemberErrors];
type UnbanGroupMemberResponses = {
    /**
     * Returns a list of GroupMember objects.
     */
    200: GroupMember;
};
type UnbanGroupMemberResponse = UnbanGroupMemberResponses[keyof UnbanGroupMemberResponses];
type CreateGroupGalleryData = {
    body: CreateGroupGalleryRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/galleries';
};
type CreateGroupGalleryErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type CreateGroupGalleryError = CreateGroupGalleryErrors[keyof CreateGroupGalleryErrors];
type CreateGroupGalleryResponses = {
    /**
     * Returns a single GroupGallery object.
     */
    200: GroupGallery;
};
type CreateGroupGalleryResponse = CreateGroupGalleryResponses[keyof CreateGroupGalleryResponses];
type DeleteGroupGalleryData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid group gallery ID.
         */
        groupGalleryId: string;
    };
    query?: never;
    url: '/groups/{groupId}/galleries/{groupGalleryId}';
};
type DeleteGroupGalleryErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type DeleteGroupGalleryError = DeleteGroupGalleryErrors[keyof DeleteGroupGalleryErrors];
type DeleteGroupGalleryResponses = {
    /**
     * Successful response after deleting a group gallery.
     */
    200: Success;
};
type DeleteGroupGalleryResponse = DeleteGroupGalleryResponses[keyof DeleteGroupGalleryResponses];
type GetGroupGalleryImagesData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid group gallery ID.
         */
        groupGalleryId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * If specified, only returns images that have been approved or not approved.
         */
        approved?: boolean;
    };
    url: '/groups/{groupId}/galleries/{groupGalleryId}';
};
type GetGroupGalleryImagesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupGalleryImagesError = GetGroupGalleryImagesErrors[keyof GetGroupGalleryImagesErrors];
type GetGroupGalleryImagesResponses = {
    /**
     * Returns a list of GroupGalleryImage objects.
     */
    200: Array<GroupGalleryImage>;
};
type GetGroupGalleryImagesResponse = GetGroupGalleryImagesResponses[keyof GetGroupGalleryImagesResponses];
type UpdateGroupGalleryData = {
    body?: UpdateGroupGalleryRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid group gallery ID.
         */
        groupGalleryId: string;
    };
    query?: never;
    url: '/groups/{groupId}/galleries/{groupGalleryId}';
};
type UpdateGroupGalleryErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type UpdateGroupGalleryError = UpdateGroupGalleryErrors[keyof UpdateGroupGalleryErrors];
type UpdateGroupGalleryResponses = {
    /**
     * Returns a single GroupGallery object.
     */
    200: GroupGallery;
};
type UpdateGroupGalleryResponse = UpdateGroupGalleryResponses[keyof UpdateGroupGalleryResponses];
type AddGroupGalleryImageData = {
    body: AddGroupGalleryImageRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid group gallery ID.
         */
        groupGalleryId: string;
    };
    query?: never;
    url: '/groups/{groupId}/galleries/{groupGalleryId}/images';
};
type AddGroupGalleryImageErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type AddGroupGalleryImageError = AddGroupGalleryImageErrors[keyof AddGroupGalleryImageErrors];
type AddGroupGalleryImageResponses = {
    /**
     * Returns a single GroupGalleryImage object.
     */
    200: GroupGalleryImage;
};
type AddGroupGalleryImageResponse = AddGroupGalleryImageResponses[keyof AddGroupGalleryImageResponses];
type DeleteGroupGalleryImageData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid group gallery ID.
         */
        groupGalleryId: string;
        /**
         * Must be a valid group gallery image ID.
         */
        groupGalleryImageId: string;
    };
    query?: never;
    url: '/groups/{groupId}/galleries/{groupGalleryId}/images/{groupGalleryImageId}';
};
type DeleteGroupGalleryImageErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to delete a submission to a group's gallery when the user does not have permission to do so.
     */
    403: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type DeleteGroupGalleryImageError = DeleteGroupGalleryImageErrors[keyof DeleteGroupGalleryImageErrors];
type DeleteGroupGalleryImageResponses = {
    /**
     * Successful response after deleting a group gallery image.
     */
    200: Success;
};
type DeleteGroupGalleryImageResponse = DeleteGroupGalleryImageResponses[keyof DeleteGroupGalleryImageResponses];
type GetGroupInstancesData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/instances';
};
type GetGroupInstancesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupInstancesError = GetGroupInstancesErrors[keyof GetGroupInstancesErrors];
type GetGroupInstancesResponses = {
    /**
     * Returns a list of GroupInstance objects.
     */
    200: Array<GroupInstance>;
};
type GetGroupInstancesResponse = GetGroupInstancesResponses[keyof GetGroupInstancesResponses];
type GetGroupInvitesData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/groups/{groupId}/invites';
};
type GetGroupInvitesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a group you are not member of.
     */
    403: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupInvitesError = GetGroupInvitesErrors[keyof GetGroupInvitesErrors];
type GetGroupInvitesResponses = {
    /**
     * Returns a list of GroupMember objects.
     */
    200: Array<GroupMember>;
};
type GetGroupInvitesResponse = GetGroupInvitesResponses[keyof GetGroupInvitesResponses];
type CreateGroupInviteData = {
    body: CreateGroupInviteRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/invites';
};
type CreateGroupInviteErrors = {
    /**
     * Bad request error response when creating a group invite.
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Forbidden error response when creating a group invite.
     */
    403: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type CreateGroupInviteError = CreateGroupInviteErrors[keyof CreateGroupInviteErrors];
type CreateGroupInviteResponses = {
    /**
     * OK
     */
    200: unknown;
};
type DeleteGroupInviteData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/groups/{groupId}/invites/{userId}';
};
type DeleteGroupInviteErrors = {
    /**
     * Bad request error response when deleting a group invite
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type DeleteGroupInviteError = DeleteGroupInviteErrors[keyof DeleteGroupInviteErrors];
type DeleteGroupInviteResponses = {
    /**
     * OK
     */
    200: unknown;
};
type JoinGroupData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/join';
};
type JoinGroupErrors = {
    /**
     * Error response when trying to join a group that the user is already a member of.
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type JoinGroupError = JoinGroupErrors[keyof JoinGroupErrors];
type JoinGroupResponses = {
    /**
     * Returns a list of GroupMember objects.
     */
    200: GroupMember;
};
type JoinGroupResponse = JoinGroupResponses[keyof JoinGroupResponses];
type LeaveGroupData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/leave';
};
type LeaveGroupErrors = {
    /**
     * Error response when trying to perform operations on a group you are not member of.
     */
    403: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type LeaveGroupError = LeaveGroupErrors[keyof LeaveGroupErrors];
type LeaveGroupResponses = {
    /**
     * OK
     */
    200: unknown;
};
type GetGroupMembersData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * The sort order of Group Member results
         */
        sort?: GroupSearchSort;
        /**
         * Only returns members with a specific groupRoleId
         */
        roleId?: GroupRoleId;
    };
    url: '/groups/{groupId}/members';
};
type GetGroupMembersErrors = {
    /**
     * Error response when trying to search list of users with an invalid request.
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupMembersError = GetGroupMembersErrors[keyof GetGroupMembersErrors];
type GetGroupMembersResponses = {
    /**
     * Returns a list of GroupMember objects.
     */
    200: Array<GroupMember>;
};
type GetGroupMembersResponse = GetGroupMembersResponses[keyof GetGroupMembersResponses];
type KickGroupMemberData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/groups/{groupId}/members/{userId}';
};
type KickGroupMemberErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a group you are not member of.
     */
    403: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type KickGroupMemberError = KickGroupMemberErrors[keyof KickGroupMemberErrors];
type KickGroupMemberResponses = {
    /**
     * OK
     */
    200: unknown;
};
type GetGroupMemberData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/groups/{groupId}/members/{userId}';
};
type GetGroupMemberErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a group you are not member of.
     */
    403: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupMemberError = GetGroupMemberErrors[keyof GetGroupMemberErrors];
type GetGroupMemberResponses = {
    /**
     * Returns a list of GroupMember objects.
     */
    200: GroupLimitedMember;
};
type GetGroupMemberResponse = GetGroupMemberResponses[keyof GetGroupMemberResponses];
type UpdateGroupMemberData = {
    body?: UpdateGroupMemberRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/groups/{groupId}/members/{userId}';
};
type UpdateGroupMemberErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type UpdateGroupMemberError = UpdateGroupMemberErrors[keyof UpdateGroupMemberErrors];
type UpdateGroupMemberResponses = {
    /**
     * Returns a list of GroupMember objects.
     */
    200: GroupLimitedMember;
};
type UpdateGroupMemberResponse = UpdateGroupMemberResponses[keyof UpdateGroupMemberResponses];
type RemoveGroupMemberRoleData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
        /**
         * Must be a valid group role ID.
         */
        groupRoleId: string;
    };
    query?: never;
    url: '/groups/{groupId}/members/{userId}/roles/{groupRoleId}';
};
type RemoveGroupMemberRoleErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type RemoveGroupMemberRoleError = RemoveGroupMemberRoleErrors[keyof RemoveGroupMemberRoleErrors];
type RemoveGroupMemberRoleResponses = {
    /**
     * Returns a list of GroupRoleID objects.
     */
    200: GroupRoleIdList;
};
type RemoveGroupMemberRoleResponse = RemoveGroupMemberRoleResponses[keyof RemoveGroupMemberRoleResponses];
type AddGroupMemberRoleData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
        /**
         * Must be a valid group role ID.
         */
        groupRoleId: string;
    };
    query?: never;
    url: '/groups/{groupId}/members/{userId}/roles/{groupRoleId}';
};
type AddGroupMemberRoleErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type AddGroupMemberRoleError = AddGroupMemberRoleErrors[keyof AddGroupMemberRoleErrors];
type AddGroupMemberRoleResponses = {
    /**
     * Returns a list of GroupRoleID objects.
     */
    200: GroupRoleIdList;
};
type AddGroupMemberRoleResponse = AddGroupMemberRoleResponses[keyof AddGroupMemberRoleResponses];
type GetGroupPermissionsData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/permissions';
};
type GetGroupPermissionsErrors = {
    /**
     * Error response when trying to search list of users with an invalid request.
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupPermissionsError = GetGroupPermissionsErrors[keyof GetGroupPermissionsErrors];
type GetGroupPermissionsResponses = {
    /**
     * Returns a list of GroupPermission objects.
     */
    200: Array<GroupPermission>;
};
type GetGroupPermissionsResponse = GetGroupPermissionsResponses[keyof GetGroupPermissionsResponses];
type GetGroupPostsData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * See public posts only.
         */
        publicOnly?: boolean;
    };
    url: '/groups/{groupId}/posts';
};
type GetGroupPostsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetGroupPostsError = GetGroupPostsErrors[keyof GetGroupPostsErrors];
type GetGroupPostsResponses = {
    /**
     * Returns a GroupPost Array.
     */
    200: {
        posts?: Array<GroupPost>;
    };
};
type GetGroupPostsResponse = GetGroupPostsResponses[keyof GetGroupPostsResponses];
type AddGroupPostData = {
    body: CreateGroupPostRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/posts';
};
type AddGroupPostErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type AddGroupPostError = AddGroupPostErrors[keyof AddGroupPostErrors];
type AddGroupPostResponses = {
    /**
     * Returns a GroupPost object.
     */
    200: GroupPost;
};
type AddGroupPostResponse = AddGroupPostResponses[keyof AddGroupPostResponses];
type DeleteGroupPostData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
    query?: never;
    url: '/groups/{groupId}/posts/{notificationId}';
};
type DeleteGroupPostErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Response after deleting a group post.
     */
    404: Success;
};
type DeleteGroupPostError = DeleteGroupPostErrors[keyof DeleteGroupPostErrors];
type DeleteGroupPostResponses = {
    /**
     * Response after deleting a group post.
     */
    200: Success;
};
type DeleteGroupPostResponse = DeleteGroupPostResponses[keyof DeleteGroupPostResponses];
type UpdateGroupPostData = {
    body: CreateGroupPostRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
    query?: never;
    url: '/groups/{groupId}/posts/{notificationId}';
};
type UpdateGroupPostErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Response after deleting a group post.
     */
    404: Success;
};
type UpdateGroupPostError = UpdateGroupPostErrors[keyof UpdateGroupPostErrors];
type UpdateGroupPostResponses = {
    /**
     * Returns a GroupPost object.
     */
    200: GroupPost;
};
type UpdateGroupPostResponse = UpdateGroupPostResponses[keyof UpdateGroupPostResponses];
type UpdateGroupRepresentationData = {
    body: {
        /**
         * Whether the user is representing the group.
         */
        isRepresenting: boolean;
    };
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/representation';
};
type UpdateGroupRepresentationErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a group you are not member of.
     */
    403: _Error;
};
type UpdateGroupRepresentationError = UpdateGroupRepresentationErrors[keyof UpdateGroupRepresentationErrors];
type UpdateGroupRepresentationResponses = {
    /**
     * Successful response after updating group representation.
     */
    200: Success;
};
type UpdateGroupRepresentationResponse = UpdateGroupRepresentationResponses[keyof UpdateGroupRepresentationResponses];
type CancelGroupRequestData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/requests';
};
type CancelGroupRequestErrors = {
    /**
     * You can't cancel a join request if you didn't request to joinâ€¤
     */
    400: unknown;
    /**
     * Error response when trying to perform operations on a group you are not member of.
     */
    403: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type CancelGroupRequestError = CancelGroupRequestErrors[keyof CancelGroupRequestErrors];
type CancelGroupRequestResponses = {
    /**
     * OK
     */
    200: unknown;
};
type GetGroupRequestsData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * See blocked join requests
         */
        blocked?: boolean;
    };
    url: '/groups/{groupId}/requests';
};
type GetGroupRequestsErrors = {
    /**
     * Bad request error response when responding to a group join request
     */
    400: _Error;
    /**
     * Error response when trying to perform operations on a group you are not member of.
     */
    403: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupRequestsError = GetGroupRequestsErrors[keyof GetGroupRequestsErrors];
type GetGroupRequestsResponses = {
    /**
     * Returns a list of GroupMember objects.
     */
    200: Array<GroupMember>;
};
type GetGroupRequestsResponse = GetGroupRequestsResponses[keyof GetGroupRequestsResponses];
type RespondGroupJoinRequestData = {
    body: RespondGroupJoinRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/groups/{groupId}/requests/{userId}';
};
type RespondGroupJoinRequestErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type RespondGroupJoinRequestError = RespondGroupJoinRequestErrors[keyof RespondGroupJoinRequestErrors];
type RespondGroupJoinRequestResponses = {
    /**
     * OK
     */
    200: unknown;
};
type GetGroupRolesData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/roles';
};
type GetGroupRolesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type GetGroupRolesError = GetGroupRolesErrors[keyof GetGroupRolesErrors];
type GetGroupRolesResponses = {
    /**
     * Returns a list of GroupRole objects.
     */
    200: Array<GroupRole>;
};
type GetGroupRolesResponse = GetGroupRolesResponses[keyof GetGroupRolesResponses];
type CreateGroupRoleData = {
    body: CreateGroupRoleRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
    };
    query?: never;
    url: '/groups/{groupId}/roles';
};
type CreateGroupRoleErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing group.
     */
    404: _Error;
};
type CreateGroupRoleError = CreateGroupRoleErrors[keyof CreateGroupRoleErrors];
type CreateGroupRoleResponses = {
    /**
     * Returns a single GroupRole object.
     */
    200: GroupRole;
};
type CreateGroupRoleResponse = CreateGroupRoleResponses[keyof CreateGroupRoleResponses];
type DeleteGroupRoleData = {
    body?: never;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid group role ID.
         */
        groupRoleId: string;
    };
    query?: never;
    url: '/groups/{groupId}/roles/{groupRoleId}';
};
type DeleteGroupRoleErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a group you are not member of.
     */
    404: _Error;
};
type DeleteGroupRoleError = DeleteGroupRoleErrors[keyof DeleteGroupRoleErrors];
type DeleteGroupRoleResponses = {
    /**
     * Returns a list of GroupRole objects.
     */
    200: Array<GroupRole>;
};
type DeleteGroupRoleResponse = DeleteGroupRoleResponses[keyof DeleteGroupRoleResponses];
type UpdateGroupRoleData = {
    body?: UpdateGroupRoleRequest;
    path: {
        /**
         * Must be a valid group ID.
         */
        groupId: string;
        /**
         * Must be a valid group role ID.
         */
        groupRoleId: string;
    };
    query?: never;
    url: '/groups/{groupId}/roles/{groupRoleId}';
};
type UpdateGroupRoleErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type UpdateGroupRoleError = UpdateGroupRoleErrors[keyof UpdateGroupRoleErrors];
type UpdateGroupRoleResponses = {
    /**
     * Returns a list of GroupRole objects.
     */
    200: Array<GroupRole>;
};
type UpdateGroupRoleResponse = UpdateGroupRoleResponses[keyof UpdateGroupRoleResponses];
type GetInventoryData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Sort order for inventory retrieval.
         */
        order?: 'newest' | 'newest_created' | 'oldest' | 'oldest_created';
        /**
         * Filter tags for inventory retrieval (comma-separated).
         */
        tags?: Tag;
        /**
         * Filter for inventory retrieval.
         */
        types?: InventoryItemType;
        /**
         * Filter flags for inventory retrieval (comma-separated).
         */
        flags?: InventoryFlag;
        /**
         * Filter out types for inventory retrieval (comma-separated).
         */
        notTypes?: InventoryItemType;
        /**
         * Filter out flags for inventory retrieval (comma-separated).
         */
        notFlags?: InventoryFlag;
        /**
         * Filter archived status for inventory retrieval.
         */
        archived?: boolean;
    };
    url: '/inventory';
};
type GetInventoryErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetInventoryError = GetInventoryErrors[keyof GetInventoryErrors];
type GetInventoryResponses = {
    /**
     * Returns an Inventory object.
     */
    200: Inventory;
};
type GetInventoryResponse = GetInventoryResponses[keyof GetInventoryResponses];
type GetOwnInventoryItemData = {
    body?: never;
    path: {
        /**
         * Must be a valid inventory item ID.
         */
        inventoryItemId: string;
    };
    query?: never;
    url: '/inventory/{inventoryItemId}';
};
type GetOwnInventoryItemErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetOwnInventoryItemError = GetOwnInventoryItemErrors[keyof GetOwnInventoryItemErrors];
type GetOwnInventoryItemResponses = {
    /**
     * Returns an InventoryItem object.
     */
    200: InventoryItem;
};
type GetOwnInventoryItemResponse = GetOwnInventoryItemResponses[keyof GetOwnInventoryItemResponses];
type UpdateOwnInventoryItemData = {
    body?: UpdateInventoryItemRequest;
    path: {
        /**
         * Must be a valid inventory item ID.
         */
        inventoryItemId: string;
    };
    query?: never;
    url: '/inventory/{inventoryItemId}';
};
type UpdateOwnInventoryItemErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type UpdateOwnInventoryItemError = UpdateOwnInventoryItemErrors[keyof UpdateOwnInventoryItemErrors];
type UpdateOwnInventoryItemResponses = {
    /**
     * Returns an InventoryItem object.
     */
    200: InventoryItem;
};
type UpdateOwnInventoryItemResponse = UpdateOwnInventoryItemResponses[keyof UpdateOwnInventoryItemResponses];
type GetInventoryDropsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filter for users' listings and inventory bundles.
         */
        active?: boolean;
    };
    url: '/inventory/drops';
};
type GetInventoryDropsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetInventoryDropsError = GetInventoryDropsErrors[keyof GetInventoryDropsErrors];
type GetInventoryDropsResponses = {
    /**
     * Returns a list of InventoryDrop objects.
     */
    200: Array<InventoryDrop>;
};
type GetInventoryDropsResponse = GetInventoryDropsResponses[keyof GetInventoryDropsResponses];
type GetInventoryTemplateData = {
    body?: never;
    path: {
        /**
         * Must be a valid inventory template ID.
         */
        inventoryTemplateId: string;
    };
    query?: never;
    url: '/inventory/template/{inventoryTemplateId}';
};
type GetInventoryTemplateErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetInventoryTemplateError = GetInventoryTemplateErrors[keyof GetInventoryTemplateErrors];
type GetInventoryTemplateResponses = {
    /**
     * Returns an InventoryTemplate object.
     */
    200: InventoryTemplate;
};
type GetInventoryTemplateResponse = GetInventoryTemplateResponses[keyof GetInventoryTemplateResponses];
type SpawnInventoryItemData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Id for inventory item spawning.
         */
        id: InventoryItemId;
    };
    url: '/inventory/spawn';
};
type SpawnInventoryItemErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type SpawnInventoryItemError = SpawnInventoryItemErrors[keyof SpawnInventoryItemErrors];
type SpawnInventoryItemResponses = {
    /**
     * Returns an InventorySpawn object.
     */
    200: InventorySpawn;
};
type SpawnInventoryItemResponse = SpawnInventoryItemResponses[keyof SpawnInventoryItemResponses];
type ShareInventoryItemPedestalData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Id for inventory item sharing.
         */
        itemId: InventoryItemId;
        /**
         * The duration before the sharing pedestal despawns.
         */
        duration: number;
    };
    url: '/inventory/cloning/pedestal';
};
type ShareInventoryItemPedestalErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type ShareInventoryItemPedestalError = ShareInventoryItemPedestalErrors[keyof ShareInventoryItemPedestalErrors];
type ShareInventoryItemPedestalResponses = {
    /**
     * Returns an InventorySpawn object.
     */
    200: InventorySpawn;
};
type ShareInventoryItemPedestalResponse = ShareInventoryItemPedestalResponses[keyof ShareInventoryItemPedestalResponses];
type ShareInventoryItemDirectData = {
    body: ShareInventoryItemDirectRequest;
    path?: never;
    query: {
        /**
         * Id for inventory item sharing.
         */
        itemId: InventoryItemId;
        /**
         * The duration before the sharing pedestal despawns.
         */
        duration: number;
    };
    url: '/inventory/cloning/direct';
};
type ShareInventoryItemDirectErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type ShareInventoryItemDirectError = ShareInventoryItemDirectErrors[keyof ShareInventoryItemDirectErrors];
type ShareInventoryItemDirectResponses = {
    /**
     * Returns an OkStatus object.
     */
    200: OkStatus;
};
type ShareInventoryItemDirectResponse = ShareInventoryItemDirectResponses[keyof ShareInventoryItemDirectResponses];
type InviteUserData = {
    /**
     * Slot number of the Invite Message to use when inviting a user.
     */
    body: InviteRequest;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/invite/{userId}';
};
type InviteUserErrors = {
    /**
     * Error response when trying to invite someome whom you are not friends with.
     */
    403: _Error;
};
type InviteUserError = InviteUserErrors[keyof InviteUserErrors];
type InviteUserResponses = {
    /**
     * Returns a single SentNotifcation object.
     */
    200: SentNotification;
};
type InviteUserResponse = InviteUserResponses[keyof InviteUserResponses];
type InviteUserWithPhotoData = {
    body: {
        /**
         * The binary blob of the png file.
         */
        image: Blob | File;
        data: InviteRequest;
    };
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/invite/{userId}/photo';
};
type InviteUserWithPhotoErrors = {
    /**
     * Error response when trying to invite someome whom you are not friends with.
     */
    403: _Error;
};
type InviteUserWithPhotoError = InviteUserWithPhotoErrors[keyof InviteUserWithPhotoErrors];
type InviteUserWithPhotoResponses = {
    /**
     * Returns a single SentNotifcation object.
     */
    200: SentNotification;
};
type InviteUserWithPhotoResponse = InviteUserWithPhotoResponses[keyof InviteUserWithPhotoResponses];
type InviteMyselfToData = {
    body?: never;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
        /**
         * Must be a valid instance ID.
         */
        instanceId: string;
    };
    query?: never;
    url: '/invite/myself/to/{worldId}:{instanceId}';
};
type InviteMyselfToErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response due to non existant instance
     */
    404: _Error;
};
type InviteMyselfToError = InviteMyselfToErrors[keyof InviteMyselfToErrors];
type InviteMyselfToResponses = {
    /**
     * Returns a single SentNotifcation object.
     */
    200: SentNotification;
};
type InviteMyselfToResponse = InviteMyselfToResponses[keyof InviteMyselfToResponses];
type RequestInviteData = {
    /**
     * Slot number of the Request Message to use when request an invite.
     */
    body?: RequestInviteRequest;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/requestInvite/{userId}';
};
type RequestInviteErrors = {
    /**
     * Error response when trying to invite someome whom you are not friends with.
     */
    403: _Error;
};
type RequestInviteError = RequestInviteErrors[keyof RequestInviteErrors];
type RequestInviteResponses = {
    /**
     * Returns a single Notifcation object.
     */
    200: Notification;
};
type RequestInviteResponse = RequestInviteResponses[keyof RequestInviteResponses];
type RequestInviteWithPhotoData = {
    body?: {
        /**
         * The binary blob of the png file.
         */
        image: Blob | File;
        data: RequestInviteRequest;
    };
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/requestInvite/{userId}/photo';
};
type RequestInviteWithPhotoErrors = {
    /**
     * Error response when trying to invite someome whom you are not friends with.
     */
    403: _Error;
};
type RequestInviteWithPhotoError = RequestInviteWithPhotoErrors[keyof RequestInviteWithPhotoErrors];
type RequestInviteWithPhotoResponses = {
    /**
     * Returns a single Notifcation object.
     */
    200: Notification;
};
type RequestInviteWithPhotoResponse = RequestInviteWithPhotoResponses[keyof RequestInviteWithPhotoResponses];
type RespondInviteData = {
    /**
     * Slot number of the Response Message to use when responding to a user.
     */
    body: InviteResponse;
    path: {
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
    query?: never;
    url: '/invite/{notificationId}/response';
};
type RespondInviteErrors = {
    /**
     * Error response when trying to respond to an invite and something went wrong.
     */
    400: _Error;
};
type RespondInviteError = RespondInviteErrors[keyof RespondInviteErrors];
type RespondInviteResponses = {
    /**
     * Returns a single Notifcation object.
     */
    200: Notification;
};
type RespondInviteResponse = RespondInviteResponses[keyof RespondInviteResponses];
type RespondInviteWithPhotoData = {
    body: {
        /**
         * The binary blob of the png file.
         */
        image: Blob | File;
        data: InviteResponse;
    };
    path: {
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
    query?: never;
    url: '/invite/{notificationId}/response/photo';
};
type RespondInviteWithPhotoErrors = {
    /**
     * Error response when trying to respond to an invite and something went wrong.
     */
    400: _Error;
};
type RespondInviteWithPhotoError = RespondInviteWithPhotoErrors[keyof RespondInviteWithPhotoErrors];
type RespondInviteWithPhotoResponses = {
    /**
     * Returns a single Notifcation object.
     */
    200: Notification;
};
type RespondInviteWithPhotoResponse = RespondInviteWithPhotoResponses[keyof RespondInviteWithPhotoResponses];
type GetInviteMessagesData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
        /**
         * The type of message to fetch, must be a valid InviteMessageType.
         */
        messageType: InviteMessageType;
    };
    query?: never;
    url: '/message/{userId}/{messageType}';
};
type GetInviteMessagesErrors = {
    /**
     * Error response when trying to update an Invite Message with an invalid slot number.
     */
    400: _Error;
    /**
     * Error response due to missing authorization to perform that action.
     */
    401: _Error;
};
type GetInviteMessagesError = GetInviteMessagesErrors[keyof GetInviteMessagesErrors];
type GetInviteMessagesResponses = {
    /**
     * Returns a list of InviteMessage objects.
     */
    200: Array<InviteMessage>;
};
type GetInviteMessagesResponse = GetInviteMessagesResponses[keyof GetInviteMessagesResponses];
type ResetInviteMessageData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
        /**
         * The type of message to fetch, must be a valid InviteMessageType.
         */
        messageType: InviteMessageType;
        /**
         * The message slot to fetch of a given message type.
         */
        slot: number;
    };
    query?: never;
    url: '/message/{userId}/{messageType}/{slot}';
};
type ResetInviteMessageErrors = {
    /**
     * Error response when trying to update an Invite Message with an invalid slot number.
     */
    400: _Error;
    /**
     * Error response due to missing authorization to perform that action.
     */
    401: _Error;
    /**
     * Error response when trying to reset an Invite Message whos slot doesn't exist.
     */
    404: _Error;
    /**
     * Error response when trying to update an Invite Message before the cooldown has expired.
     */
    429: _Error;
};
type ResetInviteMessageError = ResetInviteMessageErrors[keyof ResetInviteMessageErrors];
type ResetInviteMessageResponses = {
    /**
     * Returns a list of InviteMessage objects.
     */
    200: Array<InviteMessage>;
};
type ResetInviteMessageResponse = ResetInviteMessageResponses[keyof ResetInviteMessageResponses];
type GetInviteMessageData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
        /**
         * The type of message to fetch, must be a valid InviteMessageType.
         */
        messageType: InviteMessageType;
        /**
         * The message slot to fetch of a given message type.
         */
        slot: number;
    };
    query?: never;
    url: '/message/{userId}/{messageType}/{slot}';
};
type GetInviteMessageErrors = {
    /**
     * Error response when trying to get an Invite Message with a negative slot number.
     */
    400: _Error;
    /**
     * Error response due to missing authorization to perform that action.
     */
    401: _Error;
    /**
     * Error response when trying to get an Invite Message with a too high slot number.
     */
    404: _Error;
};
type GetInviteMessageError = GetInviteMessageErrors[keyof GetInviteMessageErrors];
type GetInviteMessageResponses = {
    /**
     * Returns a single InviteMessage object.
     */
    200: InviteMessage;
};
type GetInviteMessageResponse = GetInviteMessageResponses[keyof GetInviteMessageResponses];
type UpdateInviteMessageData = {
    /**
     * Message of what to set the invite message to.
     */
    body?: UpdateInviteMessageRequest;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
        /**
         * The type of message to fetch, must be a valid InviteMessageType.
         */
        messageType: InviteMessageType;
        /**
         * The message slot to fetch of a given message type.
         */
        slot: number;
    };
    query?: never;
    url: '/message/{userId}/{messageType}/{slot}';
};
type UpdateInviteMessageErrors = {
    /**
     * Error response when trying to update an Invite Message with an invalid slot number.
     */
    400: _Error;
    /**
     * Error response due to missing authorization to perform that action.
     */
    401: _Error;
    /**
     * Error response when trying to update an Invite Message before the cooldown has expired.
     */
    429: _Error;
};
type UpdateInviteMessageError = UpdateInviteMessageErrors[keyof UpdateInviteMessageErrors];
type UpdateInviteMessageResponses = {
    /**
     * Returns a list of InviteMessage objects.
     */
    200: Array<InviteMessage>;
};
type UpdateInviteMessageResponse = UpdateInviteMessageResponses[keyof UpdateInviteMessageResponses];
type CreateInstanceData = {
    body: CreateInstanceRequest;
    path?: never;
    query?: never;
    url: '/instances';
};
type CreateInstanceErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type CreateInstanceError = CreateInstanceErrors[keyof CreateInstanceErrors];
type CreateInstanceResponses = {
    /**
     * Returns a single Instance object.
     */
    200: Instance;
};
type CreateInstanceResponse = CreateInstanceResponses[keyof CreateInstanceResponses];
type GetRecentLocationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/instances/recent';
};
type GetRecentLocationsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetRecentLocationsError = GetRecentLocationsErrors[keyof GetRecentLocationsErrors];
type GetRecentLocationsResponses = {
    /**
     * Returns a list of LocationIDs.
     */
    200: Array<LocationId>;
};
type GetRecentLocationsResponse = GetRecentLocationsResponses[keyof GetRecentLocationsResponses];
type CloseInstanceData = {
    body?: never;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
        /**
         * Must be a valid instance ID.
         */
        instanceId: string;
    };
    query?: {
        /**
         * Whether to hard close the instance. Defaults to false.
         */
        hardClose?: boolean;
        /**
         * The time after which users won't be allowed to join the instances.
         * If omitted, the instance will be closed immediately.
         */
        closedAt?: Date;
    };
    url: '/instances/{worldId}:{instanceId}';
};
type CloseInstanceErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response due to not being allowed to close an instance
     */
    403: _Error;
    /**
     * Error response due to non existant instance
     */
    404: _Error;
};
type CloseInstanceError = CloseInstanceErrors[keyof CloseInstanceErrors];
type CloseInstanceResponses = {
    /**
     * Returns a single Instance object.
     */
    200: Instance;
};
type CloseInstanceResponse = CloseInstanceResponses[keyof CloseInstanceResponses];
type GetInstanceData = {
    body?: never;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
        /**
         * Must be a valid instance ID.
         */
        instanceId: string;
    };
    query?: never;
    url: '/instances/{worldId}:{instanceId}';
};
type GetInstanceErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetInstanceError = GetInstanceErrors[keyof GetInstanceErrors];
type GetInstanceResponses = {
    /**
     * Returns a single Instance object.
     */
    200: Instance;
};
type GetInstanceResponse = GetInstanceResponses[keyof GetInstanceResponses];
type GetShortNameData = {
    body?: never;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
        /**
         * Must be a valid instance ID.
         */
        instanceId: string;
    };
    query?: never;
    url: '/instances/{worldId}:{instanceId}/shortName';
};
type GetShortNameErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetShortNameError = GetShortNameErrors[keyof GetShortNameErrors];
type GetShortNameResponses = {
    /**
     * Returns an instance secureName and/or shortName.
     */
    200: InstanceShortNameResponse;
};
type GetShortNameResponse = GetShortNameResponses[keyof GetShortNameResponses];
type GetInstanceByShortNameData = {
    body?: never;
    path: {
        /**
         * Must be a valid instance short name.
         */
        shortName: string;
    };
    query?: never;
    url: '/instances/s/{shortName}';
};
type GetInstanceByShortNameErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response due to non existant instance
     */
    404: _Error;
};
type GetInstanceByShortNameError = GetInstanceByShortNameErrors[keyof GetInstanceByShortNameErrors];
type GetInstanceByShortNameResponses = {
    /**
     * Returns a single Instance object.
     */
    200: Instance;
};
type GetInstanceByShortNameResponse = GetInstanceByShortNameResponses[keyof GetInstanceByShortNameResponses];
type GetNotificationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Only send notifications of this type (can use `all` for all). This parameter no longer does anything, and is deprecated.
         * @deprecated
         */
        type?: string;
        /**
         * Return notifications sent by the user. Must be false or omitted.
         * @deprecated
         */
        sent?: boolean;
        /**
         * Whether to return hidden or non-hidden notifications. True only allowed on type `friendRequest`.
         */
        hidden?: boolean;
        /**
         * Only return notifications sent after this Date. Ignored if type is `friendRequest`.
         */
        after?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/auth/user/notifications';
};
type GetNotificationsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetNotificationsError = GetNotificationsErrors[keyof GetNotificationsErrors];
type GetNotificationsResponses = {
    /**
     * Returns a list of Notifcation objects.
     */
    200: Array<Notification>;
};
type GetNotificationsResponse = GetNotificationsResponses[keyof GetNotificationsResponses];
type GetNotificationData = {
    body?: never;
    path: {
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
    query?: never;
    url: '/auth/user/notifications/{notificationId}';
};
type GetNotificationErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to perform operations on a non-existing notification.
     */
    404: _Error;
};
type GetNotificationError = GetNotificationErrors[keyof GetNotificationErrors];
type GetNotificationResponses = {
    /**
     * Returns a single Notifcation object.
     */
    200: Notification;
};
type GetNotificationResponse = GetNotificationResponses[keyof GetNotificationResponses];
type AcceptFriendRequestData = {
    body?: never;
    path: {
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
    query?: never;
    url: '/auth/user/notifications/{notificationId}/accept';
};
type AcceptFriendRequestErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to accept a non-existent friend request.
     */
    404: _Error;
};
type AcceptFriendRequestError = AcceptFriendRequestErrors[keyof AcceptFriendRequestErrors];
type AcceptFriendRequestResponses = {
    /**
     * Successful response after friending a user.
     */
    200: Success;
};
type AcceptFriendRequestResponse = AcceptFriendRequestResponses[keyof AcceptFriendRequestResponses];
type MarkNotificationAsReadData = {
    body?: never;
    path: {
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
    query?: never;
    url: '/auth/user/notifications/{notificationId}/see';
};
type MarkNotificationAsReadErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type MarkNotificationAsReadError = MarkNotificationAsReadErrors[keyof MarkNotificationAsReadErrors];
type MarkNotificationAsReadResponses = {
    /**
     * Returns a single Notifcation object.
     */
    200: Notification;
};
type MarkNotificationAsReadResponse = MarkNotificationAsReadResponses[keyof MarkNotificationAsReadResponses];
type DeleteNotificationData = {
    body?: never;
    path: {
        /**
         * Must be a valid notification ID.
         */
        notificationId: string;
    };
    query?: never;
    url: '/auth/user/notifications/{notificationId}/hide';
};
type DeleteNotificationErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type DeleteNotificationError = DeleteNotificationErrors[keyof DeleteNotificationErrors];
type DeleteNotificationResponses = {
    /**
     * Returns a single Notifcation object.
     */
    200: Notification;
};
type DeleteNotificationResponse = DeleteNotificationResponses[keyof DeleteNotificationResponses];
type ClearNotificationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/user/notifications/clear';
};
type ClearNotificationsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type ClearNotificationsError = ClearNotificationsErrors[keyof ClearNotificationsErrors];
type ClearNotificationsResponses = {
    /**
     * Successful response after clearing all notifications.
     */
    200: Success;
};
type ClearNotificationsResponse = ClearNotificationsResponses[keyof ClearNotificationsResponses];
type ClearAllPlayerModerationsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/user/playermoderations';
};
type ClearAllPlayerModerationsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type ClearAllPlayerModerationsError = ClearAllPlayerModerationsErrors[keyof ClearAllPlayerModerationsErrors];
type ClearAllPlayerModerationsResponses = {
    /**
     * Success response after e.g. clearing all player moderations.
     */
    200: Success;
};
type ClearAllPlayerModerationsResponse = ClearAllPlayerModerationsResponses[keyof ClearAllPlayerModerationsResponses];
type GetPlayerModerationsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Must be one of PlayerModerationType.
         */
        type?: PlayerModerationType;
        /**
         * Must be valid UserID. Trying to view someone else's moderations results with "Can't view someone else's player moderations" error.
         */
        sourceUserId?: UserId;
        /**
         * Must be valid UserID.
         */
        targetUserId?: UserId;
    };
    url: '/auth/user/playermoderations';
};
type GetPlayerModerationsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetPlayerModerationsError = GetPlayerModerationsErrors[keyof GetPlayerModerationsErrors];
type GetPlayerModerationsResponses = {
    /**
     * Returns a list of PlayerModeration objects.
     */
    200: Array<PlayerModeration>;
};
type GetPlayerModerationsResponse = GetPlayerModerationsResponses[keyof GetPlayerModerationsResponses];
type ModerateUserData = {
    body: ModerateUserRequest;
    path?: never;
    query?: never;
    url: '/auth/user/playermoderations';
};
type ModerateUserErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type ModerateUserError = ModerateUserErrors[keyof ModerateUserErrors];
type ModerateUserResponses = {
    /**
     * Returns a single PlayerModeration object.
     */
    200: PlayerModeration;
};
type ModerateUserResponse = ModerateUserResponses[keyof ModerateUserResponses];
type UnmoderateUserData = {
    body: ModerateUserRequest;
    path?: never;
    query?: never;
    url: '/auth/user/unplayermoderate';
};
type UnmoderateUserErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type UnmoderateUserError = UnmoderateUserErrors[keyof UnmoderateUserErrors];
type UnmoderateUserResponses = {
    /**
     * Success response after unmoderating a player moderation.
     */
    200: Success;
};
type UnmoderateUserResponse = UnmoderateUserResponses[keyof UnmoderateUserResponses];
type GetUserPrintsData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/prints/user/{userId}';
};
type GetUserPrintsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to request another user's prints.
     */
    403: _Error;
};
type GetUserPrintsError = GetUserPrintsErrors[keyof GetUserPrintsErrors];
type GetUserPrintsResponses = {
    /**
     * Returns a list of Print objects.
     */
    200: Array<Print>;
};
type GetUserPrintsResponse = GetUserPrintsResponses[keyof GetUserPrintsResponses];
type DeletePrintData = {
    body?: never;
    path: {
        /**
         * Print ID.
         */
        printId: string;
    };
    query?: never;
    url: '/prints/{printId}';
};
type DeletePrintErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type DeletePrintError = DeletePrintErrors[keyof DeletePrintErrors];
type DeletePrintResponses = {
    /**
     * Empty response if successful
     */
    200: unknown;
};
type GetPrintData = {
    body?: never;
    path: {
        /**
         * Print ID.
         */
        printId: string;
    };
    query?: never;
    url: '/prints/{printId}';
};
type GetPrintErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetPrintError = GetPrintErrors[keyof GetPrintErrors];
type GetPrintResponses = {
    /**
     * Returns a single Print object.
     */
    200: Print;
};
type GetPrintResponse = GetPrintResponses[keyof GetPrintResponses];
type EditPrintData = {
    body?: {
        /**
         * The binary blob of the png file.
         */
        image: Blob | File;
        /**
         * The caption for the image.
         */
        note?: string;
    };
    path: {
        /**
         * Print ID.
         */
        printId: string;
    };
    query?: never;
    url: '/prints/{printId}';
};
type EditPrintErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type EditPrintError = EditPrintErrors[keyof EditPrintErrors];
type EditPrintResponses = {
    /**
     * Returns a single Print object.
     */
    200: Print;
};
type EditPrintResponse = EditPrintResponses[keyof EditPrintResponses];
type UploadPrintData = {
    body?: {
        /**
         * The binary blob of the png file.
         */
        image: Blob | File;
        /**
         * The time the image was captured.
         */
        timestamp: Date;
        /**
         * The caption for the image.
         */
        note?: string;
        /**
         * The id of the world in which the image was captured.
         */
        worldId?: string;
        /**
         * The name of the world in which the image was captured.
         */
        worldName?: string;
    };
    path?: never;
    query?: never;
    url: '/prints';
};
type UploadPrintErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type UploadPrintError = UploadPrintErrors[keyof UploadPrintErrors];
type UploadPrintResponses = {
    /**
     * Returns a single Print object.
     */
    200: Print;
};
type UploadPrintResponse = UploadPrintResponses[keyof UploadPrintResponses];
type GetPropData = {
    body?: never;
    path: {
        /**
         * Prop ID.
         */
        propId: string;
    };
    query?: never;
    url: '/props/{propId}';
};
type GetPropErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetPropError = GetPropErrors[keyof GetPropErrors];
type GetPropResponses = {
    /**
     * Returns a single Prop object.
     */
    200: Prop;
};
type GetPropResponse = GetPropResponses[keyof GetPropResponses];
type GetJamsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Only show jams of this type (`avatar` or `world`).
         */
        type?: string;
    };
    url: '/jams';
};
type GetJamsResponses = {
    /**
     * Returns a list of Jam objects.
     */
    200: Array<Jam>;
};
type GetJamsResponse = GetJamsResponses[keyof GetJamsResponses];
type GetJamData = {
    body?: never;
    path: {
        /**
         * Must be a valid query ID.
         */
        jamId: string;
    };
    query?: never;
    url: '/jams/{jamId}';
};
type GetJamErrors = {
    /**
     * Error response when trying to show information about a non-existent jam.
     */
    404: _Error;
};
type GetJamError = GetJamErrors[keyof GetJamErrors];
type GetJamResponses = {
    /**
     * Returns a Jam object.
     */
    200: Jam;
};
type GetJamResponse = GetJamResponses[keyof GetJamResponses];
type GetJamSubmissionsData = {
    body?: never;
    path: {
        /**
         * Must be a valid query ID.
         */
        jamId: string;
    };
    query?: never;
    url: '/jams/{jamId}/submissions';
};
type GetJamSubmissionsErrors = {
    /**
     * Error response when trying to show information about a non-existent jam.
     */
    404: _Error;
};
type GetJamSubmissionsError = GetJamSubmissionsErrors[keyof GetJamSubmissionsErrors];
type GetJamSubmissionsResponses = {
    /**
     * Returns a list of Submission objects.
     */
    200: Array<Submission>;
};
type GetJamSubmissionsResponse = GetJamSubmissionsResponses[keyof GetJamSubmissionsResponses];
type SearchUsersData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Searches by `displayName`. Will return empty array if search query is empty or missing.
         */
        search?: string;
        /**
         * Active user by developer type, none for normal users and internal for moderators
         */
        developerType?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/users';
};
type SearchUsersErrors = {
    /**
     * Error response when trying to search list of users with an invalid request.
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type SearchUsersError = SearchUsersErrors[keyof SearchUsersErrors];
type SearchUsersResponses = {
    /**
     * Returns a list of LimitedUserSearch objects.
     */
    200: Array<LimitedUserSearch>;
};
type SearchUsersResponse = SearchUsersResponses[keyof SearchUsersResponses];
type SearchActiveUsersData = {
    body?: never;
    path?: never;
    query: {
        /**
         * Username to search for
         */
        search: string;
        /**
         * Active user by developer type, none for normal users and internal for moderators
         */
        developerType?: string;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * The number of objects to return.
         */
        n?: number;
    };
    url: '/users/active';
};
type SearchActiveUsersErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response due to missing Administrator credentials.
     */
    403: _Error;
};
type SearchActiveUsersError = SearchActiveUsersErrors[keyof SearchActiveUsersErrors];
type SearchActiveUsersResponses = {
    /**
     * OK
     */
    200: Array<LimitedUserFriend>;
};
type SearchActiveUsersResponse = SearchActiveUsersResponses[keyof SearchActiveUsersResponses];
type GetUserByNameData = {
    body?: never;
    path: {
        /**
         * Username of the user
         */
        username: string;
    };
    query?: never;
    url: '/users/{username}/name';
};
type GetUserByNameErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetUserByNameError = GetUserByNameErrors[keyof GetUserByNameErrors];
type GetUserByNameResponses = {
    /**
     * Returns a single User object.
     */
    200: User;
};
type GetUserByNameResponse = GetUserByNameResponses[keyof GetUserByNameResponses];
type GetUserData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/users/{userId}';
};
type GetUserErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetUserError = GetUserErrors[keyof GetUserErrors];
type GetUserResponses = {
    /**
     * Returns a single User object.
     */
    200: User;
};
type GetUserResponse = GetUserResponses[keyof GetUserResponses];
type UpdateUserData = {
    body?: UpdateUserRequest;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/users/{userId}';
};
type UpdateUserErrors = {
    /**
     * Error response when a user attempts to change a property without supplying their current password.
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type UpdateUserError = UpdateUserErrors[keyof UpdateUserErrors];
type UpdateUserResponses = {
    /**
     * Returns a single CurrentUser object.
     */
    200: CurrentUser;
};
type UpdateUserResponse = UpdateUserResponses[keyof UpdateUserResponses];
type GetUserGroupsData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/users/{userId}/groups';
};
type GetUserGroupsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetUserGroupsError = GetUserGroupsErrors[keyof GetUserGroupsErrors];
type GetUserGroupsResponses = {
    /**
     * Returns a list of LimitedUserGroups objects.
     */
    200: Array<LimitedUserGroups>;
};
type GetUserGroupsResponse = GetUserGroupsResponses[keyof GetUserGroupsResponses];
type GetUserGroupRequestsData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/users/{userId}/groups/requested';
};
type GetUserGroupRequestsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetUserGroupRequestsError = GetUserGroupRequestsErrors[keyof GetUserGroupRequestsErrors];
type GetUserGroupRequestsResponses = {
    /**
     * Returns a list of Group objects.
     */
    200: Array<Group>;
};
type GetUserGroupRequestsResponse = GetUserGroupRequestsResponses[keyof GetUserGroupRequestsResponses];
type GetUserRepresentedGroupData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/users/{userId}/groups/represented';
};
type GetUserRepresentedGroupErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetUserRepresentedGroupError = GetUserRepresentedGroupErrors[keyof GetUserRepresentedGroupErrors];
type GetUserRepresentedGroupResponses = {
    /**
     * OK
     */
    200: RepresentedGroup;
};
type GetUserRepresentedGroupResponse = GetUserRepresentedGroupResponses[keyof GetUserRepresentedGroupResponses];
type GetUserFeedbackData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: {
        /**
         * Filter for users' previously submitted feedback, e.g., a groupId, userId, avatarId, etc.
         */
        contentId?: boolean;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/users/{userId}/feedback';
};
type GetUserFeedbackErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetUserFeedbackError = GetUserFeedbackErrors[keyof GetUserFeedbackErrors];
type GetUserFeedbackResponses = {
    /**
     * Returns a list of Feedback objects.
     */
    200: Array<Feedback>;
};
type GetUserFeedbackResponse = GetUserFeedbackResponses[keyof GetUserFeedbackResponses];
type GetUserNotesData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
    };
    url: '/userNotes';
};
type GetUserNotesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetUserNotesError = GetUserNotesErrors[keyof GetUserNotesErrors];
type GetUserNotesResponses = {
    /**
     * Returns a list of UserNote objects.
     */
    200: Array<UserNote>;
};
type GetUserNotesResponse = GetUserNotesResponses[keyof GetUserNotesResponses];
type UpdateUserNoteData = {
    body: UpdateUserNoteRequest;
    path?: never;
    query?: never;
    url: '/userNotes';
};
type UpdateUserNoteErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type UpdateUserNoteError = UpdateUserNoteErrors[keyof UpdateUserNoteErrors];
type UpdateUserNoteResponses = {
    /**
     * Returns a single UserNote object.
     */
    200: UserNote;
};
type UpdateUserNoteResponse = UpdateUserNoteResponses[keyof UpdateUserNoteResponses];
type GetUserNoteData = {
    body?: never;
    path: {
        /**
         * Must be a valid user note ID.
         */
        userNoteId: string;
    };
    query?: never;
    url: '/userNotes/{userNoteId}';
};
type GetUserNoteErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetUserNoteError = GetUserNoteErrors[keyof GetUserNoteErrors];
type GetUserNoteResponses = {
    /**
     * Returns a single UserNote object.
     */
    200: UserNote;
};
type GetUserNoteResponse = GetUserNoteResponses[keyof GetUserNoteResponses];
type AddTagsData = {
    body: ChangeUserTagsRequest;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/users/{userId}/addTags';
};
type AddTagsErrors = {
    /**
     * Error response when a user attempts to add an invalid, restricted, or duplicate tag to their profile, attempts to add tags above the limit for their profile, or attempts to remove invalid, restricted, or absent tag from their profile.
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type AddTagsError = AddTagsErrors[keyof AddTagsErrors];
type AddTagsResponses = {
    /**
     * Returns a single CurrentUser object.
     */
    200: CurrentUser;
};
type AddTagsResponse = AddTagsResponses[keyof AddTagsResponses];
type RemoveTagsData = {
    body: ChangeUserTagsRequest;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/users/{userId}/removeTags';
};
type RemoveTagsErrors = {
    /**
     * Error response when a user attempts to add an invalid, restricted, or duplicate tag to their profile, attempts to add tags above the limit for their profile, or attempts to remove invalid, restricted, or absent tag from their profile.
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type RemoveTagsError = RemoveTagsErrors[keyof RemoveTagsErrors];
type RemoveTagsResponses = {
    /**
     * Returns a single CurrentUser object.
     */
    200: CurrentUser;
};
type RemoveTagsResponse = RemoveTagsResponses[keyof RemoveTagsResponses];
type UpdateBadgeData = {
    body: UpdateUserBadgeRequest;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
        /**
         * Must be a valid badge ID.
         */
        badgeId: string;
    };
    query?: never;
    url: '/users/{userId}/badges/{badgeId}';
};
type UpdateBadgeErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying get group instances of another user.
     */
    403: _Error;
    /**
     * The user does not have the badge.
     */
    404: unknown;
};
type UpdateBadgeError = UpdateBadgeErrors[keyof UpdateBadgeErrors];
type UpdateBadgeResponses = {
    /**
     * The user's badge is updated.
     */
    200: unknown;
};
type GetUserGroupInstancesData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
    };
    query?: never;
    url: '/users/{userId}/instances/groups';
};
type GetUserGroupInstancesErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying get group instances of another user.
     */
    403: _Error;
};
type GetUserGroupInstancesError = GetUserGroupInstancesErrors[keyof GetUserGroupInstancesErrors];
type GetUserGroupInstancesResponses = {
    /**
     * Returns a list of Instance objects with a fetched at time.
     */
    200: {
        fetchedAt?: Date;
        instances?: Array<Instance>;
    };
};
type GetUserGroupInstancesResponse = GetUserGroupInstancesResponses[keyof GetUserGroupInstancesResponses];
type CheckUserPersistenceExistsData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
    query?: never;
    url: '/users/{userId}/{worldId}/persist/exists';
};
type CheckUserPersistenceExistsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * The user does not have persistence data for the given world.
     */
    404: unknown;
};
type CheckUserPersistenceExistsError = CheckUserPersistenceExistsErrors[keyof CheckUserPersistenceExistsErrors];
type CheckUserPersistenceExistsResponses = {
    /**
     * The user has persistence data for the given world.
     */
    200: unknown;
};
type DeleteUserPersistenceData = {
    body?: never;
    path: {
        /**
         * Must be a valid user ID.
         */
        userId: string;
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
    query?: never;
    url: '/users/{userId}/{worldId}/persist';
};
type DeleteUserPersistenceErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * The user does not have persistence data for the given world.
     */
    404: unknown;
};
type DeleteUserPersistenceError = DeleteUserPersistenceErrors[keyof DeleteUserPersistenceErrors];
type DeleteUserPersistenceResponses = {
    /**
     * The user's persistence data for the given world is deleted.
     */
    200: unknown;
};
type SearchWorldsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * Set to `me` for searching own worlds.
         */
        user?: 'me';
        /**
         * Filter by UserID.
         */
        userId?: string;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Filters by world name.
         */
        search?: string;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The platform the asset supports.
         */
        platform?: string;
        fuzzy?: boolean;
    };
    url: '/worlds';
};
type SearchWorldsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type SearchWorldsError = SearchWorldsErrors[keyof SearchWorldsErrors];
type SearchWorldsResponses = {
    /**
     * Returns a list of LimitedWorld objects.
     */
    200: Array<LimitedWorld>;
};
type SearchWorldsResponse = SearchWorldsResponses[keyof SearchWorldsResponses];
type CreateWorldData = {
    body?: CreateWorldRequest;
    path?: never;
    query?: never;
    url: '/worlds';
};
type CreateWorldErrors = {
    /**
     * Error response when trying create a world without having the neccesary Trust rank yet.
     */
    400: _Error;
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type CreateWorldError = CreateWorldErrors[keyof CreateWorldErrors];
type CreateWorldResponses = {
    /**
     * Returns a single World object.
     */
    200: World;
};
type CreateWorldResponse = CreateWorldResponses[keyof CreateWorldResponses];
type GetActiveWorldsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Filters by world name.
         */
        search?: string;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The platform the asset supports.
         */
        platform?: string;
    };
    url: '/worlds/active';
};
type GetActiveWorldsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetActiveWorldsError = GetActiveWorldsErrors[keyof GetActiveWorldsErrors];
type GetActiveWorldsResponses = {
    /**
     * Returns a list of LimitedWorld objects.
     */
    200: Array<LimitedWorld>;
};
type GetActiveWorldsResponse = GetActiveWorldsResponses[keyof GetActiveWorldsResponses];
type GetFavoritedWorldsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Filters by world name.
         */
        search?: string;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The platform the asset supports.
         */
        platform?: string;
        /**
         * Target user to see information on, admin-only.
         */
        userId?: string;
    };
    url: '/worlds/favorites';
};
type GetFavoritedWorldsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to see favourited worlds of another user without sufficient admin permissions.
     */
    403: _Error;
};
type GetFavoritedWorldsError = GetFavoritedWorldsErrors[keyof GetFavoritedWorldsErrors];
type GetFavoritedWorldsResponses = {
    /**
     * Returns a list of FavoritedWorld objects.
     */
    200: Array<FavoritedWorld>;
};
type GetFavoritedWorldsResponse = GetFavoritedWorldsResponses[keyof GetFavoritedWorldsResponses];
type GetRecentWorldsData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Filters on featured results.
         */
        featured?: boolean;
        /**
         * The sort order of the results.
         */
        sort?: SortOption;
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * Result ordering
         */
        order?: OrderOption;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Filters by world name.
         */
        search?: string;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        tag?: string;
        /**
         * Tags to exclude (comma-separated).
         */
        notag?: string;
        /**
         * Filter by ReleaseStatus.
         */
        releaseStatus?: ReleaseStatus;
        /**
         * The maximum Unity version supported by the asset.
         */
        maxUnityVersion?: string;
        /**
         * The minimum Unity version supported by the asset.
         */
        minUnityVersion?: string;
        /**
         * The platform the asset supports.
         */
        platform?: string;
        /**
         * Target user to see information on, admin-only.
         */
        userId?: string;
    };
    url: '/worlds/recent';
};
type GetRecentWorldsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to see recently visited worlds of another user without sufficient admin permissions.
     */
    403: _Error;
};
type GetRecentWorldsError = GetRecentWorldsErrors[keyof GetRecentWorldsErrors];
type GetRecentWorldsResponses = {
    /**
     * Returns a list of LimitedWorld objects.
     */
    200: Array<LimitedWorld>;
};
type GetRecentWorldsResponse = GetRecentWorldsResponses[keyof GetRecentWorldsResponses];
type DeleteWorldData = {
    body?: never;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
    query?: never;
    url: '/worlds/{worldId}';
};
type DeleteWorldErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
     */
    404: _Error;
};
type DeleteWorldError = DeleteWorldErrors[keyof DeleteWorldErrors];
type DeleteWorldResponses = {
    /**
     * OK
     */
    200: unknown;
};
type GetWorldData = {
    body?: never;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
    query?: never;
    url: '/worlds/{worldId}';
};
type GetWorldErrors = {
    /**
     * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
     */
    404: _Error;
};
type GetWorldError = GetWorldErrors[keyof GetWorldErrors];
type GetWorldResponses = {
    /**
     * Returns a single World object.
     */
    200: World;
};
type GetWorldResponse = GetWorldResponses[keyof GetWorldResponses];
type UpdateWorldData = {
    body?: UpdateWorldRequest;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
    query?: never;
    url: '/worlds/{worldId}';
};
type UpdateWorldErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
     */
    404: _Error;
};
type UpdateWorldError = UpdateWorldErrors[keyof UpdateWorldErrors];
type UpdateWorldResponses = {
    /**
     * Returns a single World object.
     */
    200: World;
};
type UpdateWorldResponse = UpdateWorldResponses[keyof UpdateWorldResponses];
type GetWorldMetadataData = {
    body?: never;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
    query?: never;
    url: '/worlds/{worldId}/metadata';
};
type GetWorldMetadataErrors = {
    /**
     * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
     */
    404: _Error;
};
type GetWorldMetadataError = GetWorldMetadataErrors[keyof GetWorldMetadataErrors];
type GetWorldMetadataResponses = {
    /**
     * OK
     */
    200: WorldMetadata;
};
type GetWorldMetadataResponse = GetWorldMetadataResponses[keyof GetWorldMetadataResponses];
type UnpublishWorldData = {
    body?: never;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
    query?: never;
    url: '/worlds/{worldId}/publish';
};
type UnpublishWorldErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
     */
    404: _Error;
};
type UnpublishWorldError = UnpublishWorldErrors[keyof UnpublishWorldErrors];
type UnpublishWorldResponses = {
    /**
     * OK
     */
    200: unknown;
};
type GetWorldPublishStatusData = {
    body?: never;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
    query?: never;
    url: '/worlds/{worldId}/publish';
};
type GetWorldPublishStatusErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
     */
    404: _Error;
};
type GetWorldPublishStatusError = GetWorldPublishStatusErrors[keyof GetWorldPublishStatusErrors];
type GetWorldPublishStatusResponses = {
    /**
     * Returns a single WorldPublishStatus object.
     */
    200: WorldPublishStatus;
};
type GetWorldPublishStatusResponse = GetWorldPublishStatusResponses[keyof GetWorldPublishStatusResponses];
type PublishWorldData = {
    body?: never;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
    };
    query?: never;
    url: '/worlds/{worldId}/publish';
};
type PublishWorldErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response when trying to show information about a non-existent world. Sometimes returns with `model <worldId> not found` instead of `World <worldId not found`.
     */
    404: _Error;
};
type PublishWorldError = PublishWorldErrors[keyof PublishWorldErrors];
type PublishWorldResponses = {
    /**
     * TODO
     */
    200: unknown;
};
type GetWorldInstanceData = {
    body?: never;
    path: {
        /**
         * Must be a valid world ID.
         */
        worldId: string;
        /**
         * Must be a valid instance ID.
         */
        instanceId: string;
    };
    query?: never;
    url: '/worlds/{worldId}/{instanceId}';
};
type GetWorldInstanceErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetWorldInstanceError = GetWorldInstanceErrors[keyof GetWorldInstanceErrors];
type GetWorldInstanceResponses = {
    /**
     * Returns a single Instance object.
     */
    200: Instance;
};
type GetWorldInstanceResponse = GetWorldInstanceResponses[keyof GetWorldInstanceResponses];
type GetConfigData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/config';
};
type GetConfigResponses = {
    /**
     * Returns the API's config.
     */
    200: ApiConfig;
};
type GetConfigResponse = GetConfigResponses[keyof GetConfigResponses];
type GetInfoPushData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Tags to include (comma-separated). All of the tags needs to be present.
         */
        require?: string;
        /**
         * Tags to include (comma-separated). Any of the tags needs to be present.
         */
        include?: string;
    };
    url: '/infoPush';
};
type GetInfoPushResponses = {
    /**
     * Returns a list of InfoPush objects.
     */
    200: Array<InfoPush>;
};
type GetInfoPushResponse = GetInfoPushResponses[keyof GetInfoPushResponses];
type GetCssData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Specifies which `variant` of the site. Public is the end-user site, while `internal` is the staff-only site with special pages for moderation and management.
         */
        variant?: 'public' | 'internal';
        /**
         * Specifies which git branch the site should load frontend source code from.
         */
        branch?: string;
    };
    url: '/css/app.css';
};
type GetCssErrors = {
    /**
     * Error response when trying to download non-public and non-main JavaScript or CSS without Admin Credentials.
     */
    400: _Error;
};
type GetCssError = GetCssErrors[keyof GetCssErrors];
type GetCssResponses = {
    /**
     * **Note:** VRChat uses 302 Redirect to Cloudfront. The implementing library **must** support and follow redirects natively.
     */
    200: Blob | File;
};
type GetCssResponse = GetCssResponses[keyof GetCssResponses];
type GetJavaScriptData = {
    body?: never;
    path?: never;
    query?: {
        /**
         * Specifies which `variant` of the site. Public is the end-user site, while `internal` is the staff-only site with special pages for moderation and management.
         */
        variant?: 'public' | 'internal';
        /**
         * Specifies which git branch the site should load frontend source code from.
         */
        branch?: string;
    };
    url: '/js/app.js';
};
type GetJavaScriptErrors = {
    /**
     * Error response when trying to download non-public and non-main JavaScript or CSS without Admin Credentials.
     */
    400: _Error;
};
type GetJavaScriptError = GetJavaScriptErrors[keyof GetJavaScriptErrors];
type GetJavaScriptResponses = {
    /**
     * **Note:** VRChat uses 302 Redirect to Cloudfront. The implementing library **must** support and follow redirects natively.
     */
    200: string;
};
type GetJavaScriptResponse = GetJavaScriptResponses[keyof GetJavaScriptResponses];
type GetHealthData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/health';
};
type GetHealthResponses = {
    /**
     * Returns the API's health.
     */
    200: ApiHealth;
};
type GetHealthResponse = GetHealthResponses[keyof GetHealthResponses];
type GetCurrentOnlineUsersData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/visits';
};
type GetCurrentOnlineUsersResponses = {
    /**
     * Number of online users
     */
    200: number;
};
type GetCurrentOnlineUsersResponse = GetCurrentOnlineUsersResponses[keyof GetCurrentOnlineUsersResponses];
type GetSystemTimeData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/time';
};
type GetSystemTimeResponses = {
    /**
     * Does not return millisecond precision. Always returns time in UTC.
     */
    200: Date;
};
type GetSystemTimeResponse = GetSystemTimeResponses[keyof GetSystemTimeResponses];
type GetAssignedPermissionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/auth/permissions';
};
type GetAssignedPermissionsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetAssignedPermissionsError = GetAssignedPermissionsErrors[keyof GetAssignedPermissionsErrors];
type GetAssignedPermissionsResponses = {
    /**
     * Returns a list of Permission objects.
     */
    200: Array<Permission>;
};
type GetAssignedPermissionsResponse = GetAssignedPermissionsResponses[keyof GetAssignedPermissionsResponses];
type GetPermissionsData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/permissions';
};
type GetPermissionsErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response due to missing Administrator credentials.
     */
    403: _Error;
};
type GetPermissionsError = GetPermissionsErrors[keyof GetPermissionsErrors];
type GetPermissionsResponses = {
    /**
     * Returns a list of Permission objects.
     */
    200: Array<Permission>;
};
type GetPermissionsResponse = GetPermissionsResponses[keyof GetPermissionsResponses];
type CreatePermissionData = {
    body?: {
        name: string;
        ownerId?: UserId;
    };
    path?: never;
    query?: {
        /**
         * The number of objects to return.
         */
        n?: number;
        /**
         * A zero-based offset from the default object sorting from where search results start.
         */
        offset?: number;
        /**
         * Owner of the Permission, MUST be valid UserID.
         */
        ownerId?: string;
    };
    url: '/permissions';
};
type CreatePermissionErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response due to missing Administrator credentials.
     */
    403: _Error;
};
type CreatePermissionError = CreatePermissionErrors[keyof CreatePermissionErrors];
type CreatePermissionResponses = {
    /**
     * Returns a single Permission object.
     */
    200: Permission;
};
type CreatePermissionResponse = CreatePermissionResponses[keyof CreatePermissionResponses];
type DeletePermissionData = {
    body?: never;
    path: {
        /**
         * Must be a valid permission ID.
         */
        permissionId: string;
    };
    query?: never;
    url: '/permissions/{permissionId}';
};
type DeletePermissionErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response due to missing Administrator credentials.
     */
    403: _Error;
};
type DeletePermissionError = DeletePermissionErrors[keyof DeletePermissionErrors];
type DeletePermissionResponses = {
    /**
     * Returns a single Permission object.
     */
    200: Permission;
};
type DeletePermissionResponse = DeletePermissionResponses[keyof DeletePermissionResponses];
type GetPermissionData = {
    body?: never;
    path: {
        /**
         * Must be a valid permission ID.
         */
        permissionId: string;
    };
    query?: never;
    url: '/permissions/{permissionId}';
};
type GetPermissionErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
};
type GetPermissionError = GetPermissionErrors[keyof GetPermissionErrors];
type GetPermissionResponses = {
    /**
     * Returns a single Permission object.
     */
    200: Permission;
};
type GetPermissionResponse = GetPermissionResponses[keyof GetPermissionResponses];
type UpdatePermissionData = {
    body?: {
        name?: string;
        ownerId?: UserId;
    };
    path: {
        /**
         * Must be a valid permission ID.
         */
        permissionId: string;
    };
    query?: never;
    url: '/permissions/{permissionId}';
};
type UpdatePermissionErrors = {
    /**
     * Error response due to missing auth cookie.
     */
    401: _Error;
    /**
     * Error response due to missing Administrator credentials.
     */
    403: _Error;
};
type UpdatePermissionError = UpdatePermissionErrors[keyof UpdatePermissionErrors];
type UpdatePermissionResponses = {
    /**
     * Returns a single Permission object.
     */
    200: Permission;
};
type UpdatePermissionResponse = UpdatePermissionResponses[keyof UpdatePermissionResponses];
type ClientOptions = {
    baseUrl: 'https://api.vrchat.cloud/api/1' | (string & {});
};

type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options$1<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};
declare class _HeyApiClient {
    protected _client: Client;
    constructor(args?: {
        client?: Client;
    });
}
declare class VRChatInternal extends _HeyApiClient {
    /**
     * Check User Exists
     * Checks if a user by a given `username`, `displayName` or `email` exist. This is used during registration to check if a username has already been taken, during change of displayName to check if a displayName is available, and during change of email to check if the email is already used. In the later two cases the `excludeUserId` is used to exclude oneself, otherwise the result would always be true.
     *
     * It is **REQUIRED** to include **AT LEAST** `username`, `displayName` **or** `email` query parameter. Although they can be combined - in addition with `excludeUserId` (generally to exclude yourself) - to further fine-tune the search.
     */
    checkUserExists<ThrowOnError extends boolean = false>(options?: Options<CheckUserExistsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CheckUserExistsResponses, CheckUserExistsErrors, ThrowOnError, "fields">;
    /**
     * Login and/or Get Current User Info
     * This endpoint does the following two operations:
     * 1) Checks if you are already logged in by looking for a valid `auth` cookie. If you are have a valid auth cookie then no additional auth-related actions are taken. If you are **not** logged in then it will log you in with the `Authorization` header and set the `auth` cookie. The `auth` cookie will only be sent once.
     * 2) If logged in, this function will also return the CurrentUser object containing detailed information about the currently logged in user.
     *
     * The auth string after `Authorization: Basic {string}` is a base64-encoded string of the username and password, both individually url-encoded, and then joined with a colon.
     *
     * > base64(urlencode(username):urlencode(password))
     *
     * **WARNING: Session Limit:** Each authentication with login credentials counts as a separate session, out of which you have a limited amount. Make sure to save and reuse the `auth` cookie if you are often restarting the program. The provided API libraries automatically save cookies during runtime, but does not persist during restart. While it can be fine to use username/password during development, expect in production to very fast run into the rate-limit and be temporarily blocked from making new sessions until older ones expire. The exact number of simultaneous sessions is unknown/undisclosed.
     */
    getCurrentUser<ThrowOnError extends boolean = false>(options?: Options<GetCurrentUserData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetCurrentUserResponses, GetCurrentUserErrors, ThrowOnError, "fields">;
    /**
     * Disable 2FA
     * Disables 2FA for the currently logged in account
     */
    disable2Fa<ThrowOnError extends boolean = false>(options?: Options<Disable2FaData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Disable2FaResponses, Disable2FaErrors, ThrowOnError, "fields">;
    /**
     * Verify 2FA code
     * Finishes the login sequence with a normal 2FA-generated code for accounts with 2FA-protection enabled.
     */
    verify2Fa<ThrowOnError extends boolean = false>(options: Options<Verify2FaData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Verify2FaResponses, Verify2FaErrors, ThrowOnError, "fields">;
    /**
     * Cancel pending enabling of time-based 2FA codes
     * Cancels the sequence for enabling time-based 2FA.
     */
    cancelPending2Fa<ThrowOnError extends boolean = false>(options?: Options<CancelPending2FaData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CancelPending2FaResponses, CancelPending2FaErrors, ThrowOnError, "fields">;
    /**
     * Enable time-based 2FA codes
     * Begins the sequence for enabling time-based 2FA.
     */
    enable2Fa<ThrowOnError extends boolean = false>(options?: Options<Enable2FaData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Enable2FaResponses, Enable2FaErrors, ThrowOnError, "fields">;
    /**
     * Verify Pending 2FA code
     * Finishes sequence for enabling time-based 2FA.
     */
    verifyPending2Fa<ThrowOnError extends boolean = false>(options: Options<VerifyPending2FaData, ThrowOnError>): _hey_api_client_fetch.RequestResult<VerifyPending2FaResponses, VerifyPending2FaErrors, ThrowOnError, "fields">;
    /**
     * Get 2FA Recovery codes
     * Gets the OTP (One Time Password) recovery codes for accounts with 2FA-protection enabled.
     */
    getRecoveryCodes<ThrowOnError extends boolean = false>(options?: Options<GetRecoveryCodesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetRecoveryCodesResponses, GetRecoveryCodesErrors, ThrowOnError, "fields">;
    /**
     * Verify 2FA code with Recovery code
     * Finishes the login sequence with an OTP (One Time Password) recovery code for accounts with 2FA-protection enabled.
     */
    verifyRecoveryCode<ThrowOnError extends boolean = false>(options: Options<VerifyRecoveryCodeData, ThrowOnError>): _hey_api_client_fetch.RequestResult<VerifyRecoveryCodeResponses, VerifyRecoveryCodeErrors, ThrowOnError, "fields">;
    /**
     * Verify 2FA email code
     * Finishes the login sequence with an 2FA email code.
     */
    verify2FaEmailCode<ThrowOnError extends boolean = false>(options: Options<Verify2FaEmailCodeData, ThrowOnError>): _hey_api_client_fetch.RequestResult<Verify2FaEmailCodeResponses, Verify2FaEmailCodeErrors, ThrowOnError, "fields">;
    /**
     * Verify Auth Token
     * Verify whether the currently provided Auth Token is valid.
     */
    verifyAuthToken<ThrowOnError extends boolean = false>(options?: Options<VerifyAuthTokenData, ThrowOnError>): _hey_api_client_fetch.RequestResult<VerifyAuthTokenResponses, VerifyAuthTokenErrors, ThrowOnError, "fields">;
    /**
     * Logout
     * Invalidates the login session.
     */
    logout<ThrowOnError extends boolean = false>(options?: Options<LogoutData, ThrowOnError>): _hey_api_client_fetch.RequestResult<LogoutResponses, LogoutErrors, ThrowOnError, "fields">;
    /**
     * Delete User
     * Deletes the account with given ID. Normal users only have permission to delete their own account. Account deletion is 14 days from this request, and will be cancelled if you do an authenticated request with the account afterwards.
     *
     * **VRC+ NOTE:** Despite the 14-days cooldown, any VRC+ subscription will be cancelled **immediately**.
     *
     * **METHOD NOTE:** Despite this being a Delete action, the method type required is PUT.
     */
    deleteUser<ThrowOnError extends boolean = false>(options: Options<DeleteUserData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteUserResponses, DeleteUserErrors, ThrowOnError, "fields">;
    /**
     * Register User Account
     * ~~Register a new user account.~~
     *
     * **DEPRECATED:** Automated creation of accounts has no legitimate public third-party use case, and would be in violation of ToS Â§13.2:
     * *By using the Platform, you agree not to: i. [...] use the Platform in a manner inconsistent with individual human usage*
     * This endpoint is documented in the interest of completeness
     * @deprecated
     */
    registerUserAccount<ThrowOnError extends boolean = false>(options: Options<RegisterUserAccountData, ThrowOnError>): _hey_api_client_fetch.RequestResult<RegisterUserAccountResponses, RegisterUserAccountErrors, ThrowOnError, "fields">;
    /**
     * Resend Email Confirmation
     * Requests a resend of pending email address confirmation email
     */
    resendEmailConfirmation<ThrowOnError extends boolean = false>(options?: Options<ResendEmailConfirmationData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ResendEmailConfirmationResponses, ResendEmailConfirmationErrors, ThrowOnError, "fields">;
    /**
     * Confirm Email
     * Confirms the email address for a user
     */
    confirmEmail<ThrowOnError extends boolean = false>(options: Options<ConfirmEmailData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError, "fields">;
    /**
     * Verify Login Place
     * Verifies a login attempt for a user
     */
    verifyLoginPlace<ThrowOnError extends boolean = false>(options: Options<VerifyLoginPlaceData, ThrowOnError>): _hey_api_client_fetch.RequestResult<unknown, unknown, ThrowOnError, "fields">;
    /**
     * Get Global Avatar Moderations
     * Returns list of globally blocked avatars.
     */
    getGlobalAvatarModerations<ThrowOnError extends boolean = false>(options?: Options<GetGlobalAvatarModerationsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGlobalAvatarModerationsResponses, GetGlobalAvatarModerationsErrors, ThrowOnError, "fields">;
    /**
     * Get Own Avatar
     * Get the current avatar for the user. This will return an error for any other user than the one logged in.
     */
    getOwnAvatar<ThrowOnError extends boolean = false>(options: Options<GetOwnAvatarData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetOwnAvatarResponses, GetOwnAvatarErrors, ThrowOnError, "fields">;
    /**
     * Search Avatars
     * Search and list avatars by query filters. You can only search your own or featured avatars. It is not possible as a normal user to search other peoples avatars.
     */
    searchAvatars<ThrowOnError extends boolean = false>(options?: Options<SearchAvatarsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<SearchAvatarsResponses, SearchAvatarsErrors, ThrowOnError, "fields">;
    /**
     * Create Avatar
     * Create an avatar. It's possible to optionally specify a ID if you want a custom one. Attempting to create an Avatar with an already claimed ID will result in a DB error.
     */
    createAvatar<ThrowOnError extends boolean = false>(options?: Options<CreateAvatarData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateAvatarResponses, CreateAvatarErrors, ThrowOnError, "fields">;
    /**
     * Get Avatar Styles
     * List avatar styles.
     */
    getAvatarStyles<ThrowOnError extends boolean = false>(options?: Options<GetAvatarStylesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetAvatarStylesResponses, unknown, ThrowOnError, "fields">;
    /**
     * Delete Avatar
     * Delete an avatar. Notice an avatar is never fully "deleted", only its ReleaseStatus is set to "hidden" and the linked Files are deleted. The AvatarID is permanently reserved.
     */
    deleteAvatar<ThrowOnError extends boolean = false>(options: Options<DeleteAvatarData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteAvatarResponses, DeleteAvatarErrors, ThrowOnError, "fields">;
    /**
     * Get Avatar
     * Get information about a specific Avatar.
     */
    getAvatar<ThrowOnError extends boolean = false>(options: Options<GetAvatarData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetAvatarResponses, GetAvatarErrors, ThrowOnError, "fields">;
    /**
     * Update Avatar
     * Update information about a specific avatar.
     */
    updateAvatar<ThrowOnError extends boolean = false>(options: Options<UpdateAvatarData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateAvatarResponses, UpdateAvatarErrors, ThrowOnError, "fields">;
    /**
     * Select Avatar
     * Switches into that avatar.
     */
    selectAvatar<ThrowOnError extends boolean = false>(options: Options<SelectAvatarData, ThrowOnError>): _hey_api_client_fetch.RequestResult<SelectAvatarResponses, SelectAvatarErrors, ThrowOnError, "fields">;
    /**
     * Select Fallback Avatar
     * Switches into that avatar as your fallback avatar.
     * @deprecated
     */
    selectFallbackAvatar<ThrowOnError extends boolean = false>(options: Options<SelectFallbackAvatarData, ThrowOnError>): _hey_api_client_fetch.RequestResult<SelectFallbackAvatarResponses, SelectFallbackAvatarErrors, ThrowOnError, "fields">;
    /**
     * List Favorited Avatars
     * Search and list favorited avatars by query filters.
     */
    getFavoritedAvatars<ThrowOnError extends boolean = false>(options?: Options<GetFavoritedAvatarsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFavoritedAvatarsResponses, GetFavoritedAvatarsErrors, ThrowOnError, "fields">;
    /**
     * List Licensed Avatars
     * List licensed avatars.
     */
    getLicensedAvatars<ThrowOnError extends boolean = false>(options?: Options<GetLicensedAvatarsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetLicensedAvatarsResponses, GetLicensedAvatarsErrors, ThrowOnError, "fields">;
    /**
     * Enqueue Impostor generation
     * Enqueue Impostor generation for that avatar.
     */
    enqueueImpostor<ThrowOnError extends boolean = false>(options: Options<EnqueueImpostorData, ThrowOnError>): _hey_api_client_fetch.RequestResult<EnqueueImpostorResponses, EnqueueImpostorErrors, ThrowOnError, "fields">;
    /**
     * Get Impostor Queue Stats
     * Gets service stats for queued impostor.
     */
    getImpostorQueueStats<ThrowOnError extends boolean = false>(options?: Options<GetImpostorQueueStatsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetImpostorQueueStatsResponses, GetImpostorQueueStatsErrors, ThrowOnError, "fields">;
    /**
     * Delete generated Impostor
     * Delete generated Impostor for that avatar.
     */
    deleteImpostor<ThrowOnError extends boolean = false>(options: Options<DeleteImpostorData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteImpostorResponses, DeleteImpostorErrors, ThrowOnError, "fields">;
    /**
     * List calendar events
     * Get a list of a user's calendar events for the month in ?date
     */
    getCalendarEvents<ThrowOnError extends boolean = false>(options?: Options<GetCalendarEventsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetCalendarEventsResponses, GetCalendarEventsErrors, ThrowOnError, "fields">;
    /**
     * List featured calendar events
     * Get a list of a featured calendar events for the month in ?date
     */
    getFeaturedCalendarEvents<ThrowOnError extends boolean = false>(options?: Options<GetFeaturedCalendarEventsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFeaturedCalendarEventsResponses, GetFeaturedCalendarEventsErrors, ThrowOnError, "fields">;
    /**
     * List followed calendar events
     * Get a list of a followed calendar events for the month in ?date
     */
    getFollowedCalendarEvents<ThrowOnError extends boolean = false>(options?: Options<GetFollowedCalendarEventsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFollowedCalendarEventsResponses, GetFollowedCalendarEventsErrors, ThrowOnError, "fields">;
    /**
     * Search for calendar events
     * Get a list of calendar events by search terms
     */
    searchCalendarEvents<ThrowOnError extends boolean = false>(options: Options<SearchCalendarEventsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<SearchCalendarEventsResponses, SearchCalendarEventsErrors, ThrowOnError, "fields">;
    /**
     * List a group's calendar events
     * Get a list of a group's calendar events
     */
    getGroupCalendarEvents<ThrowOnError extends boolean = false>(options: Options<GetGroupCalendarEventsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupCalendarEventsResponses, GetGroupCalendarEventsErrors, ThrowOnError, "fields">;
    /**
     * Create a calendar event
     * Creates an event for a group on the calendar
     */
    createGroupCalendarEvent<ThrowOnError extends boolean = false>(options: Options<CreateGroupCalendarEventData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateGroupCalendarEventResponses, CreateGroupCalendarEventErrors, ThrowOnError, "fields">;
    /**
     * Delete a calendar event
     * Delete a group calendar event
     */
    deleteGroupCalendarEvent<ThrowOnError extends boolean = false>(options: Options<DeleteGroupCalendarEventData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteGroupCalendarEventResponses, DeleteGroupCalendarEventErrors, ThrowOnError, "fields">;
    /**
     * Get a calendar event
     * Get a group calendar event
     */
    getGroupCalendarEvent<ThrowOnError extends boolean = false>(options: Options<GetGroupCalendarEventData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupCalendarEventResponses, GetGroupCalendarEventErrors, ThrowOnError, "fields">;
    /**
     * Download calendar event as ICS
     * Returns the specified calendar in iCalendar (ICS) format.
     */
    getGroupCalendarEventIcs<ThrowOnError extends boolean = false>(options: Options<GetGroupCalendarEventIcsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupCalendarEventIcsResponses, GetGroupCalendarEventIcsErrors, ThrowOnError, "fields">;
    /**
     * Update a calendar event
     * Updates an event for a group on the calendar
     */
    updateGroupCalendarEvent<ThrowOnError extends boolean = false>(options: Options<UpdateGroupCalendarEventData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateGroupCalendarEventResponses, UpdateGroupCalendarEventErrors, ThrowOnError, "fields">;
    /**
     * Follow a calendar event
     * Follow or unfollow an event on a group's calendar
     */
    followGroupCalendarEvent<ThrowOnError extends boolean = false>(options: Options<FollowGroupCalendarEventData, ThrowOnError>): _hey_api_client_fetch.RequestResult<FollowGroupCalendarEventResponses, FollowGroupCalendarEventErrors, ThrowOnError, "fields">;
    /**
     * List Steam Transactions
     * Get all own Steam transactions.
     */
    getSteamTransactions<ThrowOnError extends boolean = false>(options?: Options<GetSteamTransactionsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetSteamTransactionsResponses, GetSteamTransactionsErrors, ThrowOnError, "fields">;
    /**
     * Get Steam Transaction
     * Get a single Steam transactions by ID. This returns the exact same information as `getSteamTransactions`, so no point in using this endpoint.
     * @deprecated
     */
    getSteamTransaction<ThrowOnError extends boolean = false>(options: Options<GetSteamTransactionData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetSteamTransactionResponses, GetSteamTransactionErrors, ThrowOnError, "fields">;
    /**
     * Get Admin Transactions
     * Get all own Admin transactions.
     */
    getAdminTransactions<ThrowOnError extends boolean = false>(options?: Options<GetAdminTransactionsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetAdminTransactionsResponses, GetAdminTransactionsErrors, ThrowOnError, "fields">;
    /**
     * Get Admin Transactions
     * Get a single Admin transactions by ID. This returns the exact same information as `getAdminTransactions`, so no point in using this endpoint.
     * @deprecated
     */
    getAdminTransaction<ThrowOnError extends boolean = false>(options: Options<GetAdminTransactionData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetAdminTransactionResponses, GetAdminTransactionErrors, ThrowOnError, "fields">;
    /**
     * Get Current Subscriptions
     * Get a list of all current user subscriptions.
     */
    getCurrentSubscriptions<ThrowOnError extends boolean = false>(options?: Options<GetCurrentSubscriptionsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetCurrentSubscriptionsResponses, GetCurrentSubscriptionsErrors, ThrowOnError, "fields">;
    /**
     * Get User Subscription Eligiblity
     * Get the user's eligibility status for subscriptions.
     */
    getUserSubscriptionEligible<ThrowOnError extends boolean = false>(options: Options<GetUserSubscriptionEligibleData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetUserSubscriptionEligibleResponses, GetUserSubscriptionEligibleErrors, ThrowOnError, "fields">;
    /**
     * List Subscriptions
     * List all existing Subscriptions. For example, "vrchatplus-monthly" and "vrchatplus-yearly".
     */
    getSubscriptions<ThrowOnError extends boolean = false>(options?: Options<GetSubscriptionsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetSubscriptionsResponses, GetSubscriptionsErrors, ThrowOnError, "fields">;
    /**
     * Get License Group
     * Get a single License Group by given ID.
     */
    getLicenseGroup<ThrowOnError extends boolean = false>(options: Options<GetLicenseGroupData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetLicenseGroupResponses, GetLicenseGroupErrors, ThrowOnError, "fields">;
    /**
     * Get Product Listing
     * Gets a product listing
     */
    getProductListing<ThrowOnError extends boolean = false>(options: Options<GetProductListingData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetProductListingResponses, GetProductListingErrors, ThrowOnError, "fields">;
    /**
     * Get User Product Listings
     * Gets the product listings of a given user
     */
    getProductListings<ThrowOnError extends boolean = false>(options: Options<GetProductListingsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetProductListingsResponses, GetProductListingsErrors, ThrowOnError, "fields">;
    /**
     * List Token Bundles
     * Gets the list of token bundles
     */
    getTokenBundles<ThrowOnError extends boolean = false>(options?: Options<GetTokenBundlesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetTokenBundlesResponses, GetTokenBundlesErrors, ThrowOnError, "fields">;
    /**
     * Get Tilia Status
     * Gets the status of Tilia integration
     */
    getTiliaStatus<ThrowOnError extends boolean = false>(options?: Options<GetTiliaStatusData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetTiliaStatusResponses, GetTiliaStatusErrors, ThrowOnError, "fields">;
    /**
     * Get Tilia TOS Agreement Status
     * Gets the status of the agreement of a user to the Tilia TOS
     */
    getTiliaTos<ThrowOnError extends boolean = false>(options: Options<GetTiliaTosData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetTiliaTosResponses, GetTiliaTosErrors, ThrowOnError, "fields">;
    /**
     * Get Balance
     * Gets the balance of a user
     */
    getBalance<ThrowOnError extends boolean = false>(options: Options<GetBalanceData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetBalanceResponses, GetBalanceErrors, ThrowOnError, "fields">;
    /**
     * Get Balance Earnings
     * Gets the balance of a user from earnings
     */
    getBalanceEarnings<ThrowOnError extends boolean = false>(options: Options<GetBalanceEarningsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetBalanceEarningsResponses, GetBalanceEarningsErrors, ThrowOnError, "fields">;
    /**
     * Get Economy Account
     * Gets the economy account of a user
     */
    getEconomyAccount<ThrowOnError extends boolean = false>(options: Options<GetEconomyAccountData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetEconomyAccountResponses, GetEconomyAccountErrors, ThrowOnError, "fields">;
    /**
     * Get Active Licenses
     * Gets active licenses
     */
    getActiveLicenses<ThrowOnError extends boolean = false>(options?: Options<GetActiveLicensesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetActiveLicensesResponses, GetActiveLicensesErrors, ThrowOnError, "fields">;
    /**
     * Get Store
     * Gets a store
     */
    getStore<ThrowOnError extends boolean = false>(options: Options<GetStoreData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetStoreResponses, GetStoreErrors, ThrowOnError, "fields">;
    /**
     * Get Store Shelves
     * Gets the shelves for a store
     */
    getStoreShelves<ThrowOnError extends boolean = false>(options: Options<GetStoreShelvesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetStoreShelvesResponses, GetStoreShelvesErrors, ThrowOnError, "fields">;
    /**
     * List Favorites
     * Returns a list of favorites.
     */
    getFavorites<ThrowOnError extends boolean = false>(options?: Options<GetFavoritesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFavoritesResponses, GetFavoritesErrors, ThrowOnError, "fields">;
    /**
     * Add Favorite
     * Add a new favorite.
     *
     * Friend groups are named `group_0` through `group_3`. Avatar and World groups are named `avatars1` to `avatars4` and `worlds1` to `worlds4`.
     *
     * You cannot add people whom you are not friends with to your friends list. Destroying a friendship removes the person as favorite on both sides.
     */
    addFavorite<ThrowOnError extends boolean = false>(options?: Options<AddFavoriteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<AddFavoriteResponses, AddFavoriteErrors, ThrowOnError, "fields">;
    /**
     * Remove Favorite
     * Remove a favorite from your favorites list.
     */
    removeFavorite<ThrowOnError extends boolean = false>(options: Options<RemoveFavoriteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<RemoveFavoriteResponses, RemoveFavoriteErrors, ThrowOnError, "fields">;
    /**
     * List Favorite Groups
     * Return a list of favorite groups owned by a user. Returns the same information as `getFavoriteGroups`.
     */
    getFavoriteGroups<ThrowOnError extends boolean = false>(options?: Options<GetFavoriteGroupsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFavoriteGroupsResponses, GetFavoriteGroupsErrors, ThrowOnError, "fields">;
    /**
     * Clear Favorite Group
     * Clear ALL contents of a specific favorite group.
     */
    clearFavoriteGroup<ThrowOnError extends boolean = false>(options: Options<ClearFavoriteGroupData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ClearFavoriteGroupResponses, unknown, ThrowOnError, "fields">;
    /**
     * Show Favorite Group
     * Fetch information about a specific favorite group.
     */
    getFavoriteGroup<ThrowOnError extends boolean = false>(options: Options<GetFavoriteGroupData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFavoriteGroupResponses, unknown, ThrowOnError, "fields">;
    /**
     * Update Favorite Group
     * Update information about a specific favorite group.
     */
    updateFavoriteGroup<ThrowOnError extends boolean = false>(options: Options<UpdateFavoriteGroupData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateFavoriteGroupResponses, unknown, ThrowOnError, "fields">;
    /**
     * Get Favorite Limits
     * Return information about a specific Favorite.
     */
    getFavoriteLimits<ThrowOnError extends boolean = false>(options?: Options<GetFavoriteLimitsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFavoriteLimitsResponses, GetFavoriteLimitsErrors, ThrowOnError, "fields">;
    /**
     * List Files
     * Returns a list of files
     */
    getFiles<ThrowOnError extends boolean = false>(options?: Options<GetFilesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFilesResponses, unknown, ThrowOnError, "fields">;
    /**
     * Create File
     * Creates a new File object
     */
    createFile<ThrowOnError extends boolean = false>(options?: Options<CreateFileData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateFileResponses, unknown, ThrowOnError, "fields">;
    /**
     * Delete File
     * Deletes a File object.
     */
    deleteFile<ThrowOnError extends boolean = false>(options: Options<DeleteFileData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteFileResponses, DeleteFileErrors, ThrowOnError, "fields">;
    /**
     * Show File
     * Shows general information about the "File" object. Each File can have several "Version"'s, and each Version can have multiple real files or "Data" blobs.
     */
    getFile<ThrowOnError extends boolean = false>(options: Options<GetFileData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFileResponses, GetFileErrors, ThrowOnError, "fields">;
    /**
     * Create File Version
     * Creates a new FileVersion. Once a Version has been created, proceed to the `/file/{fileId}/{versionId}/file/start` endpoint to start a file upload.
     */
    createFileVersion<ThrowOnError extends boolean = false>(options: Options<CreateFileVersionData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateFileVersionResponses, unknown, ThrowOnError, "fields">;
    /**
     * Delete File Version
     * Delete a specific version of a file. You can only delete the latest version.
     */
    deleteFileVersion<ThrowOnError extends boolean = false>(options: Options<DeleteFileVersionData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteFileVersionResponses, DeleteFileVersionErrors, ThrowOnError, "fields">;
    /**
     * Download File Version
     * Downloads the file with the provided version number.
     *
     * **Version Note:** Version 0 is always when the file was created. The real data is usually always located in version 1 and up.
     *
     * **Extension Note:** Files are not guaranteed to have a file extensions. UnityPackage files tends to have it, images through this endpoint do not. You are responsible for appending file extension from the `extension` field when neccesary.
     */
    downloadFileVersion<ThrowOnError extends boolean = false>(options: Options<DownloadFileVersionData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DownloadFileVersionResponses, DownloadFileVersionErrors, ThrowOnError, "fields">;
    /**
     * Finish FileData Upload
     * Finish an upload of a FileData. This will mark it as "complete". After uploading the `file` for Avatars and Worlds you then have to upload a `signature` file.
     */
    finishFileDataUpload<ThrowOnError extends boolean = false>(options: Options<FinishFileDataUploadData, ThrowOnError>): _hey_api_client_fetch.RequestResult<FinishFileDataUploadResponses, unknown, ThrowOnError, "fields">;
    /**
     * Start FileData Upload
     * Starts an upload of a specific FilePart. This endpoint will return an AWS URL which you can PUT data to. You need to call this and receive a new AWS API URL for each `partNumber`. Please see AWS's REST documentation on "PUT Object to S3" on how to upload. Once all parts has been uploaded, proceed to `/finish` endpoint.
     *
     * **Note:** `nextPartNumber` seems like it is always ignored. Despite it returning 0, first partNumber is always 1.
     */
    startFileDataUpload<ThrowOnError extends boolean = false>(options: Options<StartFileDataUploadData, ThrowOnError>): _hey_api_client_fetch.RequestResult<StartFileDataUploadResponses, StartFileDataUploadErrors, ThrowOnError, "fields">;
    /**
     * Check FileData Upload Status
     * Retrieves the upload status for file upload. Can currently only be accessed when `status` is `waiting`. Trying to access it on a file version already uploaded currently times out.
     */
    getFileDataUploadStatus<ThrowOnError extends boolean = false>(options: Options<GetFileDataUploadStatusData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFileDataUploadStatusResponses, unknown, ThrowOnError, "fields">;
    /**
     * Get File Version Analysis
     * Get the performance analysis for the uploaded assets of an avatar
     */
    getFileAnalysis<ThrowOnError extends boolean = false>(options: Options<GetFileAnalysisData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFileAnalysisResponses, GetFileAnalysisErrors, ThrowOnError, "fields">;
    /**
     * Get File Version Analysis Security
     * Get the security performance analysis for the uploaded assets of an avatar
     */
    getFileAnalysisSecurity<ThrowOnError extends boolean = false>(options: Options<GetFileAnalysisSecurityData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFileAnalysisSecurityResponses, GetFileAnalysisSecurityErrors, ThrowOnError, "fields">;
    /**
     * Get File Version Analysis Standard
     * Get the standard performance analysis for the uploaded assets of an avatar
     */
    getFileAnalysisStandard<ThrowOnError extends boolean = false>(options: Options<GetFileAnalysisStandardData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFileAnalysisStandardResponses, GetFileAnalysisStandardErrors, ThrowOnError, "fields">;
    /**
     * Upload gallery image, icon, emoji or sticker
     * Upload an image, which can be an icon, gallery image, sticker or emoji
     */
    uploadImage<ThrowOnError extends boolean = false>(options?: Options<UploadImageData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UploadImageResponses, unknown, ThrowOnError, "fields">;
    /**
     * Upload icon
     * Upload an icon
     */
    uploadIcon<ThrowOnError extends boolean = false>(options?: Options<UploadIconData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UploadIconResponses, unknown, ThrowOnError, "fields">;
    /**
     * Upload gallery image
     * Upload a gallery image
     */
    uploadGalleryImage<ThrowOnError extends boolean = false>(options?: Options<UploadGalleryImageData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UploadGalleryImageResponses, unknown, ThrowOnError, "fields">;
    /**
     * Get AdminAssetBundle
     * Returns an AdminAssetBundle
     */
    getAdminAssetBundle<ThrowOnError extends boolean = false>(options: Options<GetAdminAssetBundleData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetAdminAssetBundleResponses, unknown, ThrowOnError, "fields">;
    /**
     * List Friends
     * List information about friends.
     */
    getFriends<ThrowOnError extends boolean = false>(options?: Options<GetFriendsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFriendsResponses, GetFriendsErrors, ThrowOnError, "fields">;
    /**
     * Delete Friend Request
     * Deletes an outgoing pending friend request to another user. To delete an incoming friend request, use the `deleteNotification` endpoint instead.
     */
    deleteFriendRequest<ThrowOnError extends boolean = false>(options: Options<DeleteFriendRequestData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteFriendRequestResponses, DeleteFriendRequestErrors, ThrowOnError, "fields">;
    /**
     * Send Friend Request
     * Send a friend request to another user.
     */
    friend<ThrowOnError extends boolean = false>(options: Options<FriendData, ThrowOnError>): _hey_api_client_fetch.RequestResult<FriendResponses, FriendErrors, ThrowOnError, "fields">;
    /**
     * Check Friend Status
     * Retrieve if the user is currently a friend with a given user, if they have an outgoing friend request, and if they have an incoming friend request. The proper way to receive and accept friend request is by checking if the user has an incoming `Notification` of type `friendRequest`, and then accepting that notification.
     */
    getFriendStatus<ThrowOnError extends boolean = false>(options: Options<GetFriendStatusData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFriendStatusResponses, GetFriendStatusErrors, ThrowOnError, "fields">;
    /**
     * Unfriend
     * Unfriend a user by ID.
     */
    unfriend<ThrowOnError extends boolean = false>(options: Options<UnfriendData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UnfriendResponses, UnfriendErrors, ThrowOnError, "fields">;
    /**
     * Search Group
     * Searches Groups by name or shortCode
     */
    searchGroups<ThrowOnError extends boolean = false>(options?: Options<SearchGroupsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<SearchGroupsResponses, SearchGroupsErrors, ThrowOnError, "fields">;
    /**
     * Create Group
     * Creates a Group and returns a Group object. **Requires VRC+ Subscription.**
     */
    createGroup<ThrowOnError extends boolean = false>(options: Options<CreateGroupData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateGroupResponses, CreateGroupErrors, ThrowOnError, "fields">;
    /**
     * Get Group Role Templates
     * Obtain predefined templates for group roles
     */
    getGroupRoleTemplates<ThrowOnError extends boolean = false>(options?: Options<GetGroupRoleTemplatesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupRoleTemplatesResponses, GetGroupRoleTemplatesErrors, ThrowOnError, "fields">;
    /**
     * Delete Group
     * Deletes a Group.
     */
    deleteGroup<ThrowOnError extends boolean = false>(options: Options<DeleteGroupData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteGroupResponses, DeleteGroupErrors, ThrowOnError, "fields">;
    /**
     * Get Group by ID
     * Returns a single Group by ID.
     */
    getGroup<ThrowOnError extends boolean = false>(options: Options<GetGroupData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupResponses, GetGroupErrors, ThrowOnError, "fields">;
    /**
     * Update Group
     * Updates a Group and returns it.
     */
    updateGroup<ThrowOnError extends boolean = false>(options: Options<UpdateGroupData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateGroupResponses, UpdateGroupErrors, ThrowOnError, "fields">;
    /**
     * Delete Group Announcement
     * Deletes the announcement for a Group.
     */
    deleteGroupAnnouncement<ThrowOnError extends boolean = false>(options: Options<DeleteGroupAnnouncementData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteGroupAnnouncementResponses, DeleteGroupAnnouncementErrors, ThrowOnError, "fields">;
    /**
     * Get Group Announcement
     * Returns the announcement for a Group.
     * If no announcement has been made, then it returns **empty object**.
     * If an announcement exists, then it will always return all fields except `imageId` and `imageUrl` which may be null.
     */
    getGroupAnnouncements<ThrowOnError extends boolean = false>(options: Options<GetGroupAnnouncementsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupAnnouncementsResponses, GetGroupAnnouncementsErrors, ThrowOnError, "fields">;
    /**
     * Create Group Announcement
     * Creates an Announcement for a Group. Warning: This will also remove all announcements. To make proper announcements, use the posts endpoint instead
     */
    createGroupAnnouncement<ThrowOnError extends boolean = false>(options: Options<CreateGroupAnnouncementData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateGroupAnnouncementResponses, CreateGroupAnnouncementErrors, ThrowOnError, "fields">;
    /**
     * Get Group Audit Logs
     * Returns a list of audit logs for a Group.
     */
    getGroupAuditLogs<ThrowOnError extends boolean = false>(options: Options<GetGroupAuditLogsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupAuditLogsResponses, GetGroupAuditLogsErrors, ThrowOnError, "fields">;
    /**
     * Get Group Bans
     * Returns a list of banned users for a Group.
     */
    getGroupBans<ThrowOnError extends boolean = false>(options: Options<GetGroupBansData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupBansResponses, GetGroupBansErrors, ThrowOnError, "fields">;
    /**
     * Ban Group Member
     * Bans a user from a Group.
     */
    banGroupMember<ThrowOnError extends boolean = false>(options: Options<BanGroupMemberData, ThrowOnError>): _hey_api_client_fetch.RequestResult<BanGroupMemberResponses, BanGroupMemberErrors, ThrowOnError, "fields">;
    /**
     * Unban Group Member
     * Unbans a user from a Group.
     */
    unbanGroupMember<ThrowOnError extends boolean = false>(options: Options<UnbanGroupMemberData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UnbanGroupMemberResponses, UnbanGroupMemberErrors, ThrowOnError, "fields">;
    /**
     * Create Group Gallery
     * Creates a gallery for a Group.
     */
    createGroupGallery<ThrowOnError extends boolean = false>(options: Options<CreateGroupGalleryData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateGroupGalleryResponses, CreateGroupGalleryErrors, ThrowOnError, "fields">;
    /**
     * Delete Group Gallery
     * Deletes a gallery for a Group.
     */
    deleteGroupGallery<ThrowOnError extends boolean = false>(options: Options<DeleteGroupGalleryData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteGroupGalleryResponses, DeleteGroupGalleryErrors, ThrowOnError, "fields">;
    /**
     * Get Group Gallery Images
     * Returns a list of images for a Group gallery.
     */
    getGroupGalleryImages<ThrowOnError extends boolean = false>(options: Options<GetGroupGalleryImagesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupGalleryImagesResponses, GetGroupGalleryImagesErrors, ThrowOnError, "fields">;
    /**
     * Update Group Gallery
     * Updates a gallery for a Group.
     */
    updateGroupGallery<ThrowOnError extends boolean = false>(options: Options<UpdateGroupGalleryData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateGroupGalleryResponses, UpdateGroupGalleryErrors, ThrowOnError, "fields">;
    /**
     * Add Group Gallery Image
     * Adds an image to a Group gallery.
     */
    addGroupGalleryImage<ThrowOnError extends boolean = false>(options: Options<AddGroupGalleryImageData, ThrowOnError>): _hey_api_client_fetch.RequestResult<AddGroupGalleryImageResponses, AddGroupGalleryImageErrors, ThrowOnError, "fields">;
    /**
     * Delete Group Gallery Image
     * Deletes an image from a Group gallery.
     */
    deleteGroupGalleryImage<ThrowOnError extends boolean = false>(options: Options<DeleteGroupGalleryImageData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteGroupGalleryImageResponses, DeleteGroupGalleryImageErrors, ThrowOnError, "fields">;
    /**
     * Get Group Instances
     * Returns a list of group instances
     */
    getGroupInstances<ThrowOnError extends boolean = false>(options: Options<GetGroupInstancesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupInstancesResponses, GetGroupInstancesErrors, ThrowOnError, "fields">;
    /**
     * Get Group Invites Sent
     * Returns a list of members that have been invited to the Group.
     */
    getGroupInvites<ThrowOnError extends boolean = false>(options: Options<GetGroupInvitesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupInvitesResponses, GetGroupInvitesErrors, ThrowOnError, "fields">;
    /**
     * Invite User to Group
     * Sends an invite to a user to join the group.
     */
    createGroupInvite<ThrowOnError extends boolean = false>(options: Options<CreateGroupInviteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateGroupInviteResponses, CreateGroupInviteErrors, ThrowOnError, "fields">;
    /**
     * Delete User Invite
     * Deletes an Group invite sent to a User
     */
    deleteGroupInvite<ThrowOnError extends boolean = false>(options: Options<DeleteGroupInviteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteGroupInviteResponses, DeleteGroupInviteErrors, ThrowOnError, "fields">;
    /**
     * Join Group
     * Join a Group by ID and returns the member object.
     */
    joinGroup<ThrowOnError extends boolean = false>(options: Options<JoinGroupData, ThrowOnError>): _hey_api_client_fetch.RequestResult<JoinGroupResponses, JoinGroupErrors, ThrowOnError, "fields">;
    /**
     * Leave Group
     * Leave a group by ID.
     */
    leaveGroup<ThrowOnError extends boolean = false>(options: Options<LeaveGroupData, ThrowOnError>): _hey_api_client_fetch.RequestResult<LeaveGroupResponses, LeaveGroupErrors, ThrowOnError, "fields">;
    /**
     * List Group Members
     * Returns a List of all **other** Group Members. This endpoint will never return the user calling the endpoint.
     * Information about the user calling the endpoint must be found in the `myMember` field of the Group object.
     */
    getGroupMembers<ThrowOnError extends boolean = false>(options: Options<GetGroupMembersData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupMembersResponses, GetGroupMembersErrors, ThrowOnError, "fields">;
    /**
     * Kick Group Member
     * Kicks a Group Member from the Group. The current user must have the "Remove Group Members" permission.
     */
    kickGroupMember<ThrowOnError extends boolean = false>(options: Options<KickGroupMemberData, ThrowOnError>): _hey_api_client_fetch.RequestResult<KickGroupMemberResponses, KickGroupMemberErrors, ThrowOnError, "fields">;
    /**
     * Get Group Member
     * Returns a LimitedGroup Member.
     */
    getGroupMember<ThrowOnError extends boolean = false>(options: Options<GetGroupMemberData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupMemberResponses, GetGroupMemberErrors, ThrowOnError, "fields">;
    /**
     * Update Group Member
     * Updates a Group Member
     */
    updateGroupMember<ThrowOnError extends boolean = false>(options: Options<UpdateGroupMemberData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateGroupMemberResponses, UpdateGroupMemberErrors, ThrowOnError, "fields">;
    /**
     * Remove Role from GroupMember
     * Removes a Role from a Group Member
     */
    removeGroupMemberRole<ThrowOnError extends boolean = false>(options: Options<RemoveGroupMemberRoleData, ThrowOnError>): _hey_api_client_fetch.RequestResult<RemoveGroupMemberRoleResponses, RemoveGroupMemberRoleErrors, ThrowOnError, "fields">;
    /**
     * Add Role to GroupMember
     * Adds a Role to a Group Member
     */
    addGroupMemberRole<ThrowOnError extends boolean = false>(options: Options<AddGroupMemberRoleData, ThrowOnError>): _hey_api_client_fetch.RequestResult<AddGroupMemberRoleResponses, AddGroupMemberRoleErrors, ThrowOnError, "fields">;
    /**
     * List Group Permissions
     * Returns a List of all possible/available permissions for a Group.
     */
    getGroupPermissions<ThrowOnError extends boolean = false>(options: Options<GetGroupPermissionsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupPermissionsResponses, GetGroupPermissionsErrors, ThrowOnError, "fields">;
    /**
     * Get posts from a Group
     * Get posts from a Group
     */
    getGroupPosts<ThrowOnError extends boolean = false>(options: Options<GetGroupPostsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupPostsResponses, GetGroupPostsErrors, ThrowOnError, "fields">;
    /**
     * Create a post in a Group
     * Create a post in a Group.
     */
    addGroupPost<ThrowOnError extends boolean = false>(options: Options<AddGroupPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<AddGroupPostResponses, AddGroupPostErrors, ThrowOnError, "fields">;
    /**
     * Delete a Group post
     * Delete a Group post
     */
    deleteGroupPost<ThrowOnError extends boolean = false>(options: Options<DeleteGroupPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteGroupPostResponses, DeleteGroupPostErrors, ThrowOnError, "fields">;
    /**
     * Edits a Group post
     * Edits a Group post
     */
    updateGroupPost<ThrowOnError extends boolean = false>(options: Options<UpdateGroupPostData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateGroupPostResponses, UpdateGroupPostErrors, ThrowOnError, "fields">;
    /**
     * Update Group Representation
     * Updates whether the user is representing the group.
     *
     * When `isRepresenting` is set to `true`, this flag will be set to `false` for all other groups
     */
    updateGroupRepresentation<ThrowOnError extends boolean = false>(options: Options<UpdateGroupRepresentationData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateGroupRepresentationResponses, UpdateGroupRepresentationErrors, ThrowOnError, "fields">;
    /**
     * Cancel Group Join Request
     * Cancels a request sent to join the group.
     */
    cancelGroupRequest<ThrowOnError extends boolean = false>(options: Options<CancelGroupRequestData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CancelGroupRequestResponses, CancelGroupRequestErrors, ThrowOnError, "fields">;
    /**
     * Get Group Join Requests
     * Returns a list of members that have requested to join the Group.
     */
    getGroupRequests<ThrowOnError extends boolean = false>(options: Options<GetGroupRequestsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupRequestsResponses, GetGroupRequestsErrors, ThrowOnError, "fields">;
    /**
     * Respond Group Join request
     * Responds to a Group Join Request with Accept/Deny
     */
    respondGroupJoinRequest<ThrowOnError extends boolean = false>(options: Options<RespondGroupJoinRequestData, ThrowOnError>): _hey_api_client_fetch.RequestResult<RespondGroupJoinRequestResponses, RespondGroupJoinRequestErrors, ThrowOnError, "fields">;
    /**
     * Get Group Roles
     * Returns a Group Role by ID.
     */
    getGroupRoles<ThrowOnError extends boolean = false>(options: Options<GetGroupRolesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetGroupRolesResponses, GetGroupRolesErrors, ThrowOnError, "fields">;
    /**
     * Create GroupRole
     * Create a Group role.
     */
    createGroupRole<ThrowOnError extends boolean = false>(options: Options<CreateGroupRoleData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateGroupRoleResponses, CreateGroupRoleErrors, ThrowOnError, "fields">;
    /**
     * Delete Group Role
     * Deletes a Group Role by ID and returns the remaining roles.
     */
    deleteGroupRole<ThrowOnError extends boolean = false>(options: Options<DeleteGroupRoleData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteGroupRoleResponses, DeleteGroupRoleErrors, ThrowOnError, "fields">;
    /**
     * Update Group Role
     * Updates a group role by ID.
     */
    updateGroupRole<ThrowOnError extends boolean = false>(options: Options<UpdateGroupRoleData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateGroupRoleResponses, UpdateGroupRoleErrors, ThrowOnError, "fields">;
    /**
     * Get Inventory
     * Returns an Inventory object.
     */
    getInventory<ThrowOnError extends boolean = false>(options?: Options<GetInventoryData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetInventoryResponses, GetInventoryErrors, ThrowOnError, "fields">;
    /**
     * Get Own Inventory Item
     * Returns an InventoryItem object held by the currently logged in user.
     */
    getOwnInventoryItem<ThrowOnError extends boolean = false>(options: Options<GetOwnInventoryItemData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetOwnInventoryItemResponses, GetOwnInventoryItemErrors, ThrowOnError, "fields">;
    /**
     * Update Own Inventory Item
     * Returns the modified InventoryItem object as held by the currently logged in user.
     */
    updateOwnInventoryItem<ThrowOnError extends boolean = false>(options: Options<UpdateOwnInventoryItemData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateOwnInventoryItemResponses, UpdateOwnInventoryItemErrors, ThrowOnError, "fields">;
    /**
     * List Inventory Drops
     * Returns a list of InventoryDrop objects.
     */
    getInventoryDrops<ThrowOnError extends boolean = false>(options?: Options<GetInventoryDropsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetInventoryDropsResponses, GetInventoryDropsErrors, ThrowOnError, "fields">;
    /**
     * Get Inventory Template
     * Returns an InventoryTemplate object.
     */
    getInventoryTemplate<ThrowOnError extends boolean = false>(options: Options<GetInventoryTemplateData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetInventoryTemplateResponses, GetInventoryTemplateErrors, ThrowOnError, "fields">;
    /**
     * Spawn Inventory Item
     * Returns an InventorySpawn object.
     */
    spawnInventoryItem<ThrowOnError extends boolean = false>(options: Options<SpawnInventoryItemData, ThrowOnError>): _hey_api_client_fetch.RequestResult<SpawnInventoryItemResponses, SpawnInventoryItemErrors, ThrowOnError, "fields">;
    /**
     * Share Inventory Item by Pedestal
     * Returns an InventorySpawn object.
     */
    shareInventoryItemPedestal<ThrowOnError extends boolean = false>(options: Options<ShareInventoryItemPedestalData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ShareInventoryItemPedestalResponses, ShareInventoryItemPedestalErrors, ThrowOnError, "fields">;
    /**
     * Share Inventory Item Direct
     * Share content directly with other users.
     */
    shareInventoryItemDirect<ThrowOnError extends boolean = false>(options: Options<ShareInventoryItemDirectData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ShareInventoryItemDirectResponses, ShareInventoryItemDirectErrors, ThrowOnError, "fields">;
    /**
     * Invite User
     * Sends an invite to a user. Returns the Notification of type `invite` that was sent.
     */
    inviteUser<ThrowOnError extends boolean = false>(options: Options<InviteUserData, ThrowOnError>): _hey_api_client_fetch.RequestResult<InviteUserResponses, InviteUserErrors, ThrowOnError, "fields">;
    /**
     * Invite User with photo
     * Sends an photo invite to a user. Returns the Notification of type `invite` that was sent.
     */
    inviteUserWithPhoto<ThrowOnError extends boolean = false>(options: Options<InviteUserWithPhotoData, ThrowOnError>): _hey_api_client_fetch.RequestResult<InviteUserWithPhotoResponses, InviteUserWithPhotoErrors, ThrowOnError, "fields">;
    /**
     * Invite Myself To Instance
     * Sends self an invite to an instance
     */
    inviteMyselfTo<ThrowOnError extends boolean = false>(options: Options<InviteMyselfToData, ThrowOnError>): _hey_api_client_fetch.RequestResult<InviteMyselfToResponses, InviteMyselfToErrors, ThrowOnError, "fields">;
    /**
     * Request Invite
     * Requests an invite from a user. Returns the Notification of type `requestInvite` that was sent.
     */
    requestInvite<ThrowOnError extends boolean = false>(options: Options<RequestInviteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<RequestInviteResponses, RequestInviteErrors, ThrowOnError, "fields">;
    /**
     * Request Invite with photo
     * Requests with photo an invite from a user. Returns the Notification of type `requestInvite` that was sent.
     */
    requestInviteWithPhoto<ThrowOnError extends boolean = false>(options: Options<RequestInviteWithPhotoData, ThrowOnError>): _hey_api_client_fetch.RequestResult<RequestInviteWithPhotoResponses, RequestInviteWithPhotoErrors, ThrowOnError, "fields">;
    /**
     * Respond Invite
     * Respond to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.
     *
     * In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection.
     * In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.
     */
    respondInvite<ThrowOnError extends boolean = false>(options: Options<RespondInviteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<RespondInviteResponses, RespondInviteErrors, ThrowOnError, "fields">;
    /**
     * Respond Invite with photo
     * Respond with photo to an invite or invite request without accepting it. `:notificationId` is the ID of the requesting notification.
     *
     * In case the notification being replied to is an invite, the `responseSlot` refers to a response message from the the `message` collection.
     * In case the notification is an invite request, it will refer to one from the `requestResponse` collection instead.'
     */
    respondInviteWithPhoto<ThrowOnError extends boolean = false>(options: Options<RespondInviteWithPhotoData, ThrowOnError>): _hey_api_client_fetch.RequestResult<RespondInviteWithPhotoResponses, RespondInviteWithPhotoErrors, ThrowOnError, "fields">;
    /**
     * List Invite Messages
     * Returns a list of all the users Invite Messages. Admin Credentials are required to view messages of other users!
     *
     * Message type refers to a different collection of messages, used during different types of responses.
     *
     * * `message` = Message during a normal invite
     * * `response` = Message when replying to a message
     * * `request` = Message when requesting an invite
     * * `requestResponse` = Message when replying to a request for invite
     */
    getInviteMessages<ThrowOnError extends boolean = false>(options: Options<GetInviteMessagesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetInviteMessagesResponses, GetInviteMessagesErrors, ThrowOnError, "fields">;
    /**
     * Reset Invite Message
     * Resets a single Invite Message back to its original message, and then returns a list of all of them. Admin Credentials are required to update messages of other users!
     *
     * Resetting a message respects the rate-limit, so it is not possible to reset within the 60 minutes countdown.
     * Resetting it does however not set the rate-limit to 60 like when editing it.
     * It is possible to edit it right after resetting it.
     * Trying to edit a message before the cooldown timer expires results in a 429 "Too Fast Error".
     *
     * Message type refers to a different collection of messages, used during different types of responses.
     *
     * * `message` = Message during a normal invite
     * * `response` = Message when replying to a message
     * * `request` = Message when requesting an invite
     * * `requestResponse` = Message when replying to a request for invite
     *
     * The DELETE endpoint does not have/require any request body.
     */
    resetInviteMessage<ThrowOnError extends boolean = false>(options: Options<ResetInviteMessageData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ResetInviteMessageResponses, ResetInviteMessageErrors, ThrowOnError, "fields">;
    /**
     * Get Invite Message
     * Returns a single Invite Message. This returns the exact same information but less than `getInviteMessages`. Admin Credentials are required to view messages of other users!
     *
     * Message type refers to a different collection of messages, used during different types of responses.
     *
     * * `message` = Message during a normal invite
     * * `response` = Message when replying to a message
     * * `request` = Message when requesting an invite
     * * `requestResponse` = Message when replying to a request for invite
     */
    getInviteMessage<ThrowOnError extends boolean = false>(options: Options<GetInviteMessageData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetInviteMessageResponses, GetInviteMessageErrors, ThrowOnError, "fields">;
    /**
     * Update Invite Message
     * Updates a single Invite Message and then returns a list of all of them. Admin Credentials are required to update messages of other users!
     *
     * Updating a message automatically sets the cooldown timer to 60 minutes.
     * Trying to edit a message before the cooldown timer expires results in a 429 "Too Fast Error".
     *
     * Message type refers to a different collection of messages, used during different types of responses.
     *
     * * `message` = Message during a normal invite
     * * `response` = Message when replying to a message
     * * `request` = Message when requesting an invite
     * * `requestResponse` = Message when replying to a request for invite
     */
    updateInviteMessage<ThrowOnError extends boolean = false>(options: Options<UpdateInviteMessageData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateInviteMessageResponses, UpdateInviteMessageErrors, ThrowOnError, "fields">;
    /**
     * Create Instance
     * Create an instance
     */
    createInstance<ThrowOnError extends boolean = false>(options: Options<CreateInstanceData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateInstanceResponses, CreateInstanceErrors, ThrowOnError, "fields">;
    /**
     * List Recent Locations
     * Returns a list of recently visited locations.
     */
    getRecentLocations<ThrowOnError extends boolean = false>(options?: Options<GetRecentLocationsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetRecentLocationsResponses, GetRecentLocationsErrors, ThrowOnError, "fields">;
    /**
     * Close Instance
     * Close an instance or update the closedAt time when it will be closed.
     *
     * You can only close an instance if the ownerId is yourself or if the instance owner is a group and you have the `group-instance-manage` permission.
     */
    closeInstance<ThrowOnError extends boolean = false>(options: Options<CloseInstanceData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CloseInstanceResponses, CloseInstanceErrors, ThrowOnError, "fields">;
    /**
     * Get Instance
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
     *
     * If an invalid instanceId is provided, this endpoint will simply return "null"!
     */
    getInstance<ThrowOnError extends boolean = false>(options: Options<GetInstanceData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetInstanceResponses, GetInstanceErrors, ThrowOnError, "fields">;
    /**
     * Get Instance Short Name
     * Returns an instance short name.
     */
    getShortName<ThrowOnError extends boolean = false>(options: Options<GetShortNameData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetShortNameResponses, GetShortNameErrors, ThrowOnError, "fields">;
    /**
     * Get Instance By Short Name
     * Returns an instance. Please read [Instances Tutorial](https://vrchatapi.github.io/tutorials/instances/) for more information on Instances.
     */
    getInstanceByShortName<ThrowOnError extends boolean = false>(options: Options<GetInstanceByShortNameData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetInstanceByShortNameResponses, GetInstanceByShortNameErrors, ThrowOnError, "fields">;
    /**
     * List Notifications
     * Retrieve all of the current user's notifications.
     */
    getNotifications<ThrowOnError extends boolean = false>(options?: Options<GetNotificationsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetNotificationsResponses, GetNotificationsErrors, ThrowOnError, "fields">;
    /**
     * Show notification
     * Get a notification by notification `not_` ID.
     */
    getNotification<ThrowOnError extends boolean = false>(options: Options<GetNotificationData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetNotificationResponses, GetNotificationErrors, ThrowOnError, "fields">;
    /**
     * Accept Friend Request
     * Accept a friend request by notification `frq_` ID. Friend requests can be found using the NotificationsAPI `getNotifications` by filtering of type `friendRequest`.
     */
    acceptFriendRequest<ThrowOnError extends boolean = false>(options: Options<AcceptFriendRequestData, ThrowOnError>): _hey_api_client_fetch.RequestResult<AcceptFriendRequestResponses, AcceptFriendRequestErrors, ThrowOnError, "fields">;
    /**
     * Mark Notification As Read
     * Mark a notification as seen.
     */
    markNotificationAsRead<ThrowOnError extends boolean = false>(options: Options<MarkNotificationAsReadData, ThrowOnError>): _hey_api_client_fetch.RequestResult<MarkNotificationAsReadResponses, MarkNotificationAsReadErrors, ThrowOnError, "fields">;
    /**
     * Delete Notification
     * Delete a notification.
     */
    deleteNotification<ThrowOnError extends boolean = false>(options: Options<DeleteNotificationData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteNotificationResponses, DeleteNotificationErrors, ThrowOnError, "fields">;
    /**
     * Clear All Notifications
     * Clear **all** notifications.
     */
    clearNotifications<ThrowOnError extends boolean = false>(options?: Options<ClearNotificationsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ClearNotificationsResponses, ClearNotificationsErrors, ThrowOnError, "fields">;
    /**
     * Clear All Player Moderations
     * âš ï¸ **This will delete every single player moderation you've ever made.**
     */
    clearAllPlayerModerations<ThrowOnError extends boolean = false>(options?: Options<ClearAllPlayerModerationsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ClearAllPlayerModerationsResponses, ClearAllPlayerModerationsErrors, ThrowOnError, "fields">;
    /**
     * Search Player Moderations
     * Returns a list of all player moderations made by **you**.
     *
     * This endpoint does not have pagination, and will return *all* results. Use query parameters to limit your query if needed.
     */
    getPlayerModerations<ThrowOnError extends boolean = false>(options?: Options<GetPlayerModerationsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetPlayerModerationsResponses, GetPlayerModerationsErrors, ThrowOnError, "fields">;
    /**
     * Moderate User
     * Moderate a user, e.g. unmute them or show their avatar.
     *
     * Please see the [Player Moderation docs](https://vrchatapi.github.io/docs/api/#tag--playermoderation) on what playerModerations are, and how they differ from staff moderations.
     */
    moderateUser<ThrowOnError extends boolean = false>(options: Options<ModerateUserData, ThrowOnError>): _hey_api_client_fetch.RequestResult<ModerateUserResponses, ModerateUserErrors, ThrowOnError, "fields">;
    /**
     * Unmoderate User
     * Removes a player moderation previously added through `moderateUser`. E.g if you previously have shown their avatar, but now want to reset it to default.
     */
    unmoderateUser<ThrowOnError extends boolean = false>(options: Options<UnmoderateUserData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UnmoderateUserResponses, UnmoderateUserErrors, ThrowOnError, "fields">;
    /**
     * Get Own Prints
     * Returns a list of all prints of the user. User id has to be your own userId, as you can't request other user's prints.
     */
    getUserPrints<ThrowOnError extends boolean = false>(options: Options<GetUserPrintsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetUserPrintsResponses, GetUserPrintsErrors, ThrowOnError, "fields">;
    /**
     * Delete Print
     * Returns a print.
     */
    deletePrint<ThrowOnError extends boolean = false>(options: Options<DeletePrintData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeletePrintResponses, DeletePrintErrors, ThrowOnError, "fields">;
    /**
     * Get Print
     * Returns a print.
     */
    getPrint<ThrowOnError extends boolean = false>(options: Options<GetPrintData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetPrintResponses, GetPrintErrors, ThrowOnError, "fields">;
    /**
     * Edit Print
     * Edits a print.
     */
    editPrint<ThrowOnError extends boolean = false>(options: Options<EditPrintData, ThrowOnError>): _hey_api_client_fetch.RequestResult<EditPrintResponses, EditPrintErrors, ThrowOnError, "fields">;
    /**
     * Upload Print
     * Uploads and creates a print.
     */
    uploadPrint<ThrowOnError extends boolean = false>(options?: Options<UploadPrintData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UploadPrintResponses, UploadPrintErrors, ThrowOnError, "fields">;
    /**
     * Get Prop
     * Returns a Prop object.
     */
    getProp<ThrowOnError extends boolean = false>(options: Options<GetPropData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetPropResponses, GetPropErrors, ThrowOnError, "fields">;
    /**
     * Show jams list
     * Lists World Jams or Avatar Jams, both currently running and ones that have ended.
     *
     * `isActive` is used to select only active or already ended jams.
     *
     * `type` is used to select only world or avatar jams, and can only take `world` or `avatar`.
     * ``
     */
    getJams<ThrowOnError extends boolean = false>(options?: Options<GetJamsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetJamsResponses, unknown, ThrowOnError, "fields">;
    /**
     * Show jam information
     * Returns a jam.
     */
    getJam<ThrowOnError extends boolean = false>(options: Options<GetJamData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetJamResponses, GetJamErrors, ThrowOnError, "fields">;
    /**
     * Show jam submissions
     * Returns all submissions of a jam.
     */
    getJamSubmissions<ThrowOnError extends boolean = false>(options: Options<GetJamSubmissionsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetJamSubmissionsResponses, GetJamSubmissionsErrors, ThrowOnError, "fields">;
    /**
     * Search All Users
     * Search and list any users by text query
     */
    searchUsers<ThrowOnError extends boolean = false>(options?: Options<SearchUsersData, ThrowOnError>): _hey_api_client_fetch.RequestResult<SearchUsersResponses, SearchUsersErrors, ThrowOnError, "fields">;
    /**
     * Search Active Users
     * **REQUIRES ADMIN CREDENTIALS**. Search and list any Active users by text query.
     * @deprecated
     */
    searchActiveUsers<ThrowOnError extends boolean = false>(options: Options<SearchActiveUsersData, ThrowOnError>): _hey_api_client_fetch.RequestResult<SearchActiveUsersResponses, SearchActiveUsersErrors, ThrowOnError, "fields">;
    /**
     * Get User by Username
     * ~~Get public user information about a specific user using their name.~~
     *
     * **DEPRECATED:** VRChat API no longer return usernames of other users. [See issue by Tupper for more information](https://github.com/pypy-vrc/VRCX/issues/429).
     * This endpoint now require Admin Credentials.
     * @deprecated
     */
    getUserByName<ThrowOnError extends boolean = false>(options: Options<GetUserByNameData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetUserByNameResponses, GetUserByNameErrors, ThrowOnError, "fields">;
    /**
     * Get User by ID
     * Get public user information about a specific user using their ID.
     */
    getUser<ThrowOnError extends boolean = false>(options: Options<GetUserData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetUserResponses, GetUserErrors, ThrowOnError, "fields">;
    /**
     * Update User Info
     * Update a users information such as the email and birthday.
     */
    updateUser<ThrowOnError extends boolean = false>(options: Options<UpdateUserData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateUserResponses, UpdateUserErrors, ThrowOnError, "fields">;
    /**
     * Get User Groups
     * Get user's public groups
     */
    getUserGroups<ThrowOnError extends boolean = false>(options: Options<GetUserGroupsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetUserGroupsResponses, GetUserGroupsErrors, ThrowOnError, "fields">;
    /**
     * Get User Group Requests
     * Returns a list of Groups the user has requested to be invited into.
     */
    getUserGroupRequests<ThrowOnError extends boolean = false>(options: Options<GetUserGroupRequestsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetUserGroupRequestsResponses, GetUserGroupRequestsErrors, ThrowOnError, "fields">;
    /**
     * Get user's current represented group
     * Returns the current group that the user is currently representing
     */
    getUserRepresentedGroup<ThrowOnError extends boolean = false>(options: Options<GetUserRepresentedGroupData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetUserRepresentedGroupResponses, GetUserRepresentedGroupErrors, ThrowOnError, "fields">;
    /**
     * Get User Feedback
     * Get user's submitted feedback
     * @deprecated
     */
    getUserFeedback<ThrowOnError extends boolean = false>(options: Options<GetUserFeedbackData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetUserFeedbackResponses, GetUserFeedbackErrors, ThrowOnError, "fields">;
    /**
     * Get User Notes
     * Get recently updated user notes
     */
    getUserNotes<ThrowOnError extends boolean = false>(options?: Options<GetUserNotesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetUserNotesResponses, GetUserNotesErrors, ThrowOnError, "fields">;
    /**
     * Update User Note
     * Updates the currently authenticated user's note on a user
     */
    updateUserNote<ThrowOnError extends boolean = false>(options: Options<UpdateUserNoteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateUserNoteResponses, UpdateUserNoteErrors, ThrowOnError, "fields">;
    /**
     * Get User Note
     * Get a particular user note
     */
    getUserNote<ThrowOnError extends boolean = false>(options: Options<GetUserNoteData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetUserNoteResponses, GetUserNoteErrors, ThrowOnError, "fields">;
    /**
     * Add User Tags
     * Adds tags to the user's profile
     */
    addTags<ThrowOnError extends boolean = false>(options: Options<AddTagsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<AddTagsResponses, AddTagsErrors, ThrowOnError, "fields">;
    /**
     * Remove User Tags
     * Removes tags from the user's profile
     */
    removeTags<ThrowOnError extends boolean = false>(options: Options<RemoveTagsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<RemoveTagsResponses, RemoveTagsErrors, ThrowOnError, "fields">;
    /**
     * Update User Badge
     * Updates a user's badge
     */
    updateBadge<ThrowOnError extends boolean = false>(options: Options<UpdateBadgeData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateBadgeResponses, UpdateBadgeErrors, ThrowOnError, "fields">;
    /**
     * Get User Group Instances
     * Returns a list of group instances for a user
     */
    getUserGroupInstances<ThrowOnError extends boolean = false>(options: Options<GetUserGroupInstancesData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetUserGroupInstancesResponses, GetUserGroupInstancesErrors, ThrowOnError, "fields">;
    /**
     * Check User Persistence Exists
     * Checks whether the user has persistence data for a given world
     */
    checkUserPersistenceExists<ThrowOnError extends boolean = false>(options: Options<CheckUserPersistenceExistsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CheckUserPersistenceExistsResponses, CheckUserPersistenceExistsErrors, ThrowOnError, "fields">;
    /**
     * Delete User Persistence
     * Deletes the user's persistence data for a given world
     */
    deleteUserPersistence<ThrowOnError extends boolean = false>(options: Options<DeleteUserPersistenceData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteUserPersistenceResponses, DeleteUserPersistenceErrors, ThrowOnError, "fields">;
    /**
     * Search All Worlds
     * Search and list any worlds by query filters.
     */
    searchWorlds<ThrowOnError extends boolean = false>(options?: Options<SearchWorldsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<SearchWorldsResponses, SearchWorldsErrors, ThrowOnError, "fields">;
    /**
     * Create World
     * Create a new world. This endpoint requires `assetUrl` to be a valid File object with `.vrcw` file extension, and `imageUrl` to be a valid File object with an image file extension.
     */
    createWorld<ThrowOnError extends boolean = false>(options?: Options<CreateWorldData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreateWorldResponses, CreateWorldErrors, ThrowOnError, "fields">;
    /**
     * List Active Worlds
     * Search and list currently Active worlds by query filters.
     */
    getActiveWorlds<ThrowOnError extends boolean = false>(options?: Options<GetActiveWorldsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetActiveWorldsResponses, GetActiveWorldsErrors, ThrowOnError, "fields">;
    /**
     * List Favorited Worlds
     * Search and list favorited worlds by query filters.
     */
    getFavoritedWorlds<ThrowOnError extends boolean = false>(options?: Options<GetFavoritedWorldsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetFavoritedWorldsResponses, GetFavoritedWorldsErrors, ThrowOnError, "fields">;
    /**
     * List Recent Worlds
     * Search and list recently visited worlds by query filters.
     */
    getRecentWorlds<ThrowOnError extends boolean = false>(options?: Options<GetRecentWorldsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetRecentWorldsResponses, GetRecentWorldsErrors, ThrowOnError, "fields">;
    /**
     * Delete World
     * Delete a world. Notice a world is never fully "deleted", only its ReleaseStatus is set to "hidden" and the linked Files are deleted. The WorldID is permanently reserved.
     */
    deleteWorld<ThrowOnError extends boolean = false>(options: Options<DeleteWorldData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeleteWorldResponses, DeleteWorldErrors, ThrowOnError, "fields">;
    /**
     * Get World by ID
     * Get information about a specific World.
     * Works unauthenticated but when so will always return `0` for certain fields.
     */
    getWorld<ThrowOnError extends boolean = false>(options: Options<GetWorldData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetWorldResponses, GetWorldErrors, ThrowOnError, "fields">;
    /**
     * Update World
     * Update information about a specific World.
     */
    updateWorld<ThrowOnError extends boolean = false>(options: Options<UpdateWorldData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdateWorldResponses, UpdateWorldErrors, ThrowOnError, "fields">;
    /**
     * Get World Metadata
     * Return a worlds custom metadata. This is currently believed to be unused. Metadata can be set with `updateWorld` and can be any arbitrary object.
     * @deprecated
     */
    getWorldMetadata<ThrowOnError extends boolean = false>(options: Options<GetWorldMetadataData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetWorldMetadataResponses, GetWorldMetadataErrors, ThrowOnError, "fields">;
    /**
     * Unpublish World
     * Unpublish a world.
     */
    unpublishWorld<ThrowOnError extends boolean = false>(options: Options<UnpublishWorldData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UnpublishWorldResponses, UnpublishWorldErrors, ThrowOnError, "fields">;
    /**
     * Get World Publish Status
     * Returns a worlds publish status.
     */
    getWorldPublishStatus<ThrowOnError extends boolean = false>(options: Options<GetWorldPublishStatusData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetWorldPublishStatusResponses, GetWorldPublishStatusErrors, ThrowOnError, "fields">;
    /**
     * Publish World
     * Publish a world. You can only publish one world per week.
     */
    publishWorld<ThrowOnError extends boolean = false>(options: Options<PublishWorldData, ThrowOnError>): _hey_api_client_fetch.RequestResult<PublishWorldResponses, PublishWorldErrors, ThrowOnError, "fields">;
    /**
     * Get World Instance
     * Returns a worlds instance.
     */
    getWorldInstance<ThrowOnError extends boolean = false>(options: Options<GetWorldInstanceData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetWorldInstanceResponses, GetWorldInstanceErrors, ThrowOnError, "fields">;
    /**
     * Fetch API Config
     * API config contains configuration that the clients needs to work properly.
     *
     * Currently the most important value here is `clientApiKey` which is used for all other API endpoints.
     */
    getConfig<ThrowOnError extends boolean = false>(options?: Options<GetConfigData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetConfigResponses, unknown, ThrowOnError, "fields">;
    /**
     * Show Information Notices
     * IPS (Info Push System) is a system for VRChat to push out dynamic information to the client. This is primarily used by the Quick-Menu info banners, but can also be used to e.g. alert you to update your game to the latest version.
     *
     * `include` is used to query what Information Pushes should be included in the response. If include is missing or empty, then no notices will normally be returned. This is an "any of" search.
     *
     * `require` is used to limit what Information Pushes should be included in the response. This is usually used in combination with `include`, and is an "all of" search.
     */
    getInfoPush<ThrowOnError extends boolean = false>(options?: Options<GetInfoPushData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetInfoPushResponses, unknown, ThrowOnError, "fields">;
    /**
     * Download CSS
     * Fetches the CSS code to the frontend React website.
     */
    getCss<ThrowOnError extends boolean = false>(options?: Options<GetCssData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetCssResponses, GetCssErrors, ThrowOnError, "fields">;
    /**
     * Download JavaScript
     * Fetches the JavaScript code to the frontend React website.
     */
    getJavaScript<ThrowOnError extends boolean = false>(options?: Options<GetJavaScriptData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetJavaScriptResponses, GetJavaScriptErrors, ThrowOnError, "fields">;
    /**
     * Check API Health
     * ~~Gets the overall health status, the server name, and the current build version tag of the API.~~
     *
     * **DEPRECATED:** VRChat has suddenly restricted this endpoint for unknown reasons, and now always return 401 Unauthorized.
     * @deprecated
     */
    getHealth<ThrowOnError extends boolean = false>(options?: Options<GetHealthData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetHealthResponses, unknown, ThrowOnError, "fields">;
    /**
     * Current Online Users
     * Returns the current number of online users.
     *
     * **NOTE:** The response type is not a JSON object, but a simple JSON integer.
     */
    getCurrentOnlineUsers<ThrowOnError extends boolean = false>(options?: Options<GetCurrentOnlineUsersData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetCurrentOnlineUsersResponses, unknown, ThrowOnError, "fields">;
    /**
     * Current System Time
     * Returns the current time of the API server.
     *
     * **NOTE:** The response type is not a JSON object, but a simple JSON string.
     */
    getSystemTime<ThrowOnError extends boolean = false>(options?: Options<GetSystemTimeData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetSystemTimeResponses, unknown, ThrowOnError, "fields">;
    /**
     * Get Assigned Permissions
     * Returns a list of all permissions currently granted by the user. Permissions are assigned e.g. by subscribing to VRC+.
     */
    getAssignedPermissions<ThrowOnError extends boolean = false>(options?: Options<GetAssignedPermissionsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetAssignedPermissionsResponses, GetAssignedPermissionsErrors, ThrowOnError, "fields">;
    /**
     * Get Permissions
     * **REQUIRES ADMIN CREDENTIALS**. Returns a list of all existing permissions, just like `/users` with empty search would.
     */
    getPermissions<ThrowOnError extends boolean = false>(options?: Options<GetPermissionsData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetPermissionsResponses, GetPermissionsErrors, ThrowOnError, "fields">;
    /**
     * Create Permission
     * **REQUIRES ADMIN CREDENTIALS**. Creates and returns a new Permission. The permission will by default be owned by the sender of the request unless otherwise specified.
     */
    createPermission<ThrowOnError extends boolean = false>(options?: Options<CreatePermissionData, ThrowOnError>): _hey_api_client_fetch.RequestResult<CreatePermissionResponses, CreatePermissionErrors, ThrowOnError, "fields">;
    /**
     * Delete Permission
     * **REQUIRES ADMIN CREDENTIALS**. Deletes a permission.
     */
    deletePermission<ThrowOnError extends boolean = false>(options: Options<DeletePermissionData, ThrowOnError>): _hey_api_client_fetch.RequestResult<DeletePermissionResponses, DeletePermissionErrors, ThrowOnError, "fields">;
    /**
     * Get Permission
     * Returns a single permission. This endpoint is pretty useless, as it returns the exact same information as `/auth/permissions`.
     */
    getPermission<ThrowOnError extends boolean = false>(options: Options<GetPermissionData, ThrowOnError>): _hey_api_client_fetch.RequestResult<GetPermissionResponses, GetPermissionErrors, ThrowOnError, "fields">;
    /**
     * Update Permission
     * **REQUIRES ADMIN CREDENTIALS**. Updates the info on a permission.
     */
    updatePermission<ThrowOnError extends boolean = false>(options: Options<UpdatePermissionData, ThrowOnError>): _hey_api_client_fetch.RequestResult<UpdatePermissionResponses, UpdatePermissionErrors, ThrowOnError, "fields">;
}

type MaybePromise<T> = Promise<T> | T;
type LazyFunction<T> = () => MaybePromise<T>;
type Lazy<T> = LazyFunction<T> | MaybePromise<T>;

interface EventData {
    "group-member-updated": {
        member: GroupLimitedMember;
    };
    "group-role-updated": {
        role: GroupRole;
    };
}
type Events = {
    [K in keyof EventData]: (data: EventData[K]) => void;
} & {
    [K: string]: (data: unknown) => void;
};

interface VRChatWebsocketOptions {
    baseUrl?: string;
    headers?: Headers;
    authToken?: string;
}
declare const VRChatWebsocket_base: new () => TypedEventEmitter<Events>;
declare class VRChatWebsocket extends VRChatWebsocket_base {
    readonly options: VRChatWebsocketOptions;
    private readonly vrchat?;
    private url;
    private websocket?;
    constructor(options?: VRChatWebsocketOptions, vrchat?: VRChat | undefined);
    get connected(): boolean;
    close(): void;
    authenticate(authToken: string): Promise<void>;
}

interface VRChatOptions extends Omit<NonNullable<Parameters<typeof createConfig>[0]>, "body" | "bodySerializer" | "credentials" | "global" | "method" | "mode" | "parseAs" | "querySerializer"> {
    /**
     * When using the VRChat API, you must provide an application name, version, and contact information.
     * This is used to identify your application to VRChat, and to provide support if needed.
     */
    application: {
        /**
         * The name of your application.
         */
        name: string;
        /**
         * The version of your application.
         *
         * [Semantic versioning](https://semver.org/) is recommended, e.g. `1.0.0`, but commit hashes or other identifiers are also acceptable.
         */
        version: string;
        /**
         * An email, or a URL to a support page.
         */
        contact: string;
    };
    authentication?: {
        /**
         * The credentials to use for the VRChat API.
         *
         * If not provided, the user must be logged in using the `login` method.
         * If provided, this will be used to authenticate the user automatically.
         */
        credentials?: Lazy<LoginCredentials>;
        /**
         * If set to `true`, the client will attempt to authenticate immediately after being created.
         * If set to `false`, the client will only re-authenticate on request failure (e.g. 401 Unauthorized).
         * @default true
         */
        optimistic?: boolean;
    };
    pipeline?: VRChatWebsocketOptions;
    /**
     * A [Keyv-compatible adapter](https://npm.im/keyv#official-storage-adapters) for caching & persistent sessions.
     */
    keyv?: Keyv<unknown> | KeyvStoreAdapter | Map<unknown, unknown>;
    /**
     * If set to `true`, this client will log debug information to the console.
     * This is useful for debugging, but **will expose sensitive information**.
     * @default false
     */
    verbose?: boolean;
}
declare const TwoFactorMethods: readonly ["totp", "otp", "emailOtp"];
type TwoFactorMethods = (typeof TwoFactorMethods)[number];
interface LoginCredentials {
    /**
     * The username or email of the VRChat account.
     */
    username: string;
    /**
     * The password of the VRChat account.
     */
    password: string;
    /**
     * The secret key for two-factor authentication, useful for service accounts & automated workflows.
     * If this is a user-initiated login, don't use this.
     *
     * Equivalent to ``twoFactorCode: TOTP.generate(totpSecret).otp``.
     */
    totpSecret?: string;
    /**
     * If provided, this function will be called to generate the two-factor authentication code.
     * It overrides ``totpSecret`` if both are provided, ``totpSecret`` will be ignored.
     *
     * @returns The two-factor authentication code.
     */
    twoFactorCode?: Lazy<string>;
}
type LoginOptions<ThrowOnError extends boolean> = LoginCredentials & Omit<Options<GetCurrentUserData, ThrowOnError>, "credentials" | "responseTransformer">;
type CurrentUserResult<ThrowOnError extends boolean> = Awaited<RequestResult<GetCurrentUserResponses, GetCurrentUserErrors, ThrowOnError>>;
declare const baseUrl = "https://api.vrchat.cloud/api/1/";
declare class VRChat extends VRChatInternal {
    readonly options: VRChatOptions;
    private cache;
    private credentials?;
    private authenticatePromise?;
    private lastCurrentUser?;
    private userAgent;
    readonly client: Client;
    readonly pipeline: VRChatWebsocket;
    constructor(options: VRChatOptions);
    setCredentials(credentials?: Lazy<LoginCredentials>): void;
    private authenticate;
    /**
     * Logs in to the VRChat API using the provided credentials, and returns the current user.
     * This method handles two-factor authentication if required using the provided `twoFactorCode` function or `totpSecret`.
     *
     * @param options - The login options, including username, password, and optional two-factor authentication details.
     * @returns A promise that resolves to the current user data, or an error if the login fails.
     */
    login<ThrowOnError extends boolean = false>(options: LoginOptions<ThrowOnError>): Promise<CurrentUserResult<ThrowOnError>>;
    private loginWith2FA;
    /**
     * Alias for `vrchat.pipeline.on(...)`.
     */
    get on(): VRChatWebsocket["on"];
    private getCookies;
    private saveCookies;
}

export { type AcceptFriendRequestData, type AcceptFriendRequestError, type AcceptFriendRequestErrors, type AcceptFriendRequestResponse, type AcceptFriendRequestResponses, type AccountDeletionLog, type Active, type ActorIds, type AddFavoriteData, type AddFavoriteError, type AddFavoriteErrors, type AddFavoriteRequest, type AddFavoriteResponse, type AddFavoriteResponses, type AddGroupGalleryImageData, type AddGroupGalleryImageError, type AddGroupGalleryImageErrors, type AddGroupGalleryImageRequest, type AddGroupGalleryImageResponse, type AddGroupGalleryImageResponses, type AddGroupMemberRoleData, type AddGroupMemberRoleError, type AddGroupMemberRoleErrors, type AddGroupMemberRoleResponse, type AddGroupMemberRoleResponses, type AddGroupPostData, type AddGroupPostError, type AddGroupPostErrors, type AddGroupPostResponse, type AddGroupPostResponses, type AddTagsData, type AddTagsError, type AddTagsErrors, type AddTagsResponse, type AddTagsResponses, type AdminAssetBundle, type AdminAssetBundleId, type AdminUnityPackage, type AgeVerificationStatus, type AgeVerified, type ApiConfig, type ApiConfigAnnouncement, type ApiConfigConstants, type ApiConfigDownloadUrlList, type ApiConfigEvents, type ApiHealth, type Avatar, type AvatarId, type AvatarId2, type AvatarModeration, type AvatarModerationType, type AvatarStyle, type AvatarStyleId, type Badge, type BadgeId, type BadgeId2, type Balance, type BanGroupMemberData, type BanGroupMemberError, type BanGroupMemberErrors, type BanGroupMemberRequest, type BanGroupMemberResponse, type BanGroupMemberResponses, type Branch, type CalendarEvent, type CalendarId, type CalendarId2, type CalendarSearchTerm, type CancelGroupRequestData, type CancelGroupRequestError, type CancelGroupRequestErrors, type CancelGroupRequestResponses, type CancelPending2FaData, type CancelPending2FaError, type CancelPending2FaErrors, type CancelPending2FaResponse, type CancelPending2FaResponses, type ChangeUserTagsRequest, type CheckUserExistsData, type CheckUserExistsError, type CheckUserExistsErrors, type CheckUserExistsResponse, type CheckUserExistsResponses, type CheckUserPersistenceExistsData, type CheckUserPersistenceExistsError, type CheckUserPersistenceExistsErrors, type CheckUserPersistenceExistsResponses, type ClearAllPlayerModerationsData, type ClearAllPlayerModerationsError, type ClearAllPlayerModerationsErrors, type ClearAllPlayerModerationsResponse, type ClearAllPlayerModerationsResponses, type ClearFavoriteGroupData, type ClearFavoriteGroupResponse, type ClearFavoriteGroupResponses, type ClearNotificationsData, type ClearNotificationsError, type ClearNotificationsErrors, type ClearNotificationsResponse, type ClearNotificationsResponses, type ClientOptions, type CloseInstanceData, type CloseInstanceError, type CloseInstanceErrors, type CloseInstanceResponse, type CloseInstanceResponses, type ConfirmEmailData, type ConfirmEmailToken, type ConfirmEmailUserId, type ContentId, type CreateAvatarData, type CreateAvatarError, type CreateAvatarErrors, type CreateAvatarRequest, type CreateAvatarResponse, type CreateAvatarResponses, type CreateCalendarEventRequest, type CreateFileData, type CreateFileRequest, type CreateFileResponse, type CreateFileResponses, type CreateFileVersionData, type CreateFileVersionRequest, type CreateFileVersionResponse, type CreateFileVersionResponses, type CreateGroupAnnouncementData, type CreateGroupAnnouncementError, type CreateGroupAnnouncementErrors, type CreateGroupAnnouncementRequest, type CreateGroupAnnouncementResponse, type CreateGroupAnnouncementResponses, type CreateGroupCalendarEventData, type CreateGroupCalendarEventError, type CreateGroupCalendarEventErrors, type CreateGroupCalendarEventResponse, type CreateGroupCalendarEventResponses, type CreateGroupData, type CreateGroupError, type CreateGroupErrors, type CreateGroupGalleryData, type CreateGroupGalleryError, type CreateGroupGalleryErrors, type CreateGroupGalleryRequest, type CreateGroupGalleryResponse, type CreateGroupGalleryResponses, type CreateGroupInviteData, type CreateGroupInviteError, type CreateGroupInviteErrors, type CreateGroupInviteRequest, type CreateGroupInviteResponses, type CreateGroupPostRequest, type CreateGroupRequest, type CreateGroupResponse, type CreateGroupResponses, type CreateGroupRoleData, type CreateGroupRoleError, type CreateGroupRoleErrors, type CreateGroupRoleRequest, type CreateGroupRoleResponse, type CreateGroupRoleResponses, type CreateInstanceData, type CreateInstanceError, type CreateInstanceErrors, type CreateInstanceRequest, type CreateInstanceResponse, type CreateInstanceResponses, type CreatePermissionData, type CreatePermissionError, type CreatePermissionErrors, type CreatePermissionResponse, type CreatePermissionResponses, type CreateWorldData, type CreateWorldError, type CreateWorldErrors, type CreateWorldRequest, type CreateWorldResponse, type CreateWorldResponses, type CurrentAvatarImageUrl, type CurrentAvatarThumbnailImageUrl, type CurrentUser, type CurrentUserPresence, type DeleteAvatarData, type DeleteAvatarError, type DeleteAvatarErrors, type DeleteAvatarResponse, type DeleteAvatarResponses, type DeleteFileData, type DeleteFileError, type DeleteFileErrors, type DeleteFileResponse, type DeleteFileResponses, type DeleteFileVersionData, type DeleteFileVersionError, type DeleteFileVersionErrors, type DeleteFileVersionResponse, type DeleteFileVersionResponses, type DeleteFriendRequestData, type DeleteFriendRequestError, type DeleteFriendRequestErrors, type DeleteFriendRequestResponse, type DeleteFriendRequestResponses, type DeleteGroupAnnouncementData, type DeleteGroupAnnouncementError, type DeleteGroupAnnouncementErrors, type DeleteGroupAnnouncementResponse, type DeleteGroupAnnouncementResponses, type DeleteGroupCalendarEventData, type DeleteGroupCalendarEventError, type DeleteGroupCalendarEventErrors, type DeleteGroupCalendarEventResponse, type DeleteGroupCalendarEventResponses, type DeleteGroupData, type DeleteGroupError, type DeleteGroupErrors, type DeleteGroupGalleryData, type DeleteGroupGalleryError, type DeleteGroupGalleryErrors, type DeleteGroupGalleryImageData, type DeleteGroupGalleryImageError, type DeleteGroupGalleryImageErrors, type DeleteGroupGalleryImageResponse, type DeleteGroupGalleryImageResponses, type DeleteGroupGalleryResponse, type DeleteGroupGalleryResponses, type DeleteGroupInviteData, type DeleteGroupInviteError, type DeleteGroupInviteErrors, type DeleteGroupInviteResponses, type DeleteGroupPostData, type DeleteGroupPostError, type DeleteGroupPostErrors, type DeleteGroupPostResponse, type DeleteGroupPostResponses, type DeleteGroupResponse, type DeleteGroupResponses, type DeleteGroupRoleData, type DeleteGroupRoleError, type DeleteGroupRoleErrors, type DeleteGroupRoleResponse, type DeleteGroupRoleResponses, type DeleteImpostorData, type DeleteImpostorError, type DeleteImpostorErrors, type DeleteImpostorResponses, type DeleteNotificationData, type DeleteNotificationError, type DeleteNotificationErrors, type DeleteNotificationResponse, type DeleteNotificationResponses, type DeletePermissionData, type DeletePermissionError, type DeletePermissionErrors, type DeletePermissionResponse, type DeletePermissionResponses, type DeletePrintData, type DeletePrintError, type DeletePrintErrors, type DeletePrintResponses, type DeleteUserData, type DeleteUserError, type DeleteUserErrors, type DeleteUserPersistenceData, type DeleteUserPersistenceError, type DeleteUserPersistenceErrors, type DeleteUserPersistenceResponses, type DeleteUserResponse, type DeleteUserResponses, type DeleteWorldData, type DeleteWorldError, type DeleteWorldErrors, type DeleteWorldResponses, type DeveloperType, type Disable2FaData, type Disable2FaError, type Disable2FaErrors, type Disable2FaResponse, type Disable2FaResponses, type Disable2FaResult, type DiscordDetails, type DiscordId, type DisplayName, type DownloadFileVersionData, type DownloadFileVersionError, type DownloadFileVersionErrors, type DownloadFileVersionResponse, type DownloadFileVersionResponses, type DynamicContentRow, type EconomyAccount, type EditPrintData, type EditPrintError, type EditPrintErrors, type EditPrintResponse, type EditPrintResponses, type Email, type Enable2FaData, type Enable2FaError, type Enable2FaErrors, type Enable2FaResponse, type Enable2FaResponses, type EndDate, type EnqueueImpostorData, type EnqueueImpostorError, type EnqueueImpostorErrors, type EnqueueImpostorResponse, type EnqueueImpostorResponses, type EventTypes, type ExcludeUserId, type Favorite, type FavoriteGroup, type FavoriteGroupId, type FavoriteGroupLimits, type FavoriteGroupName, type FavoriteGroupType, type FavoriteGroupVisibility, type FavoriteId, type FavoriteId2, type FavoriteLimits, type FavoriteType, type FavoritedWorld, type Featured, type Feedback, type FeedbackId, type File, type FileAnalysis, type FileAnalysisAvatarStats, type FileData, type FileId, type FileId2, type FileStatus, type FileType, type FileUploadUrl, type FileVersion, type FileVersionUploadStatus, type FinishFileDataUploadData, type FinishFileDataUploadRequest, type FinishFileDataUploadResponse, type FinishFileDataUploadResponses, type FollowCalendarEventRequest, type FollowGroupCalendarEventData, type FollowGroupCalendarEventError, type FollowGroupCalendarEventErrors, type FollowGroupCalendarEventResponse, type FollowGroupCalendarEventResponses, type FriendData, type FriendError, type FriendErrors, type FriendResponse, type FriendResponses, type FriendStatus, type Fuzzy, type GetActiveLicensesData, type GetActiveLicensesError, type GetActiveLicensesErrors, type GetActiveLicensesResponse, type GetActiveLicensesResponses, type GetActiveWorldsData, type GetActiveWorldsError, type GetActiveWorldsErrors, type GetActiveWorldsResponse, type GetActiveWorldsResponses, type GetAdminAssetBundleData, type GetAdminAssetBundleResponse, type GetAdminAssetBundleResponses, type GetAdminTransactionData, type GetAdminTransactionError, type GetAdminTransactionErrors, type GetAdminTransactionResponse, type GetAdminTransactionResponses, type GetAdminTransactionsData, type GetAdminTransactionsError, type GetAdminTransactionsErrors, type GetAdminTransactionsResponse, type GetAdminTransactionsResponses, type GetAssignedPermissionsData, type GetAssignedPermissionsError, type GetAssignedPermissionsErrors, type GetAssignedPermissionsResponse, type GetAssignedPermissionsResponses, type GetAvatarData, type GetAvatarError, type GetAvatarErrors, type GetAvatarResponse, type GetAvatarResponses, type GetAvatarStylesData, type GetAvatarStylesResponse, type GetAvatarStylesResponses, type GetBalanceData, type GetBalanceEarningsData, type GetBalanceEarningsError, type GetBalanceEarningsErrors, type GetBalanceEarningsResponse, type GetBalanceEarningsResponses, type GetBalanceError, type GetBalanceErrors, type GetBalanceResponse, type GetBalanceResponses, type GetCalendarEventsData, type GetCalendarEventsError, type GetCalendarEventsErrors, type GetCalendarEventsResponse, type GetCalendarEventsResponses, type GetConfigData, type GetConfigResponse, type GetConfigResponses, type GetCssData, type GetCssError, type GetCssErrors, type GetCssResponse, type GetCssResponses, type GetCurrentOnlineUsersData, type GetCurrentOnlineUsersResponse, type GetCurrentOnlineUsersResponses, type GetCurrentSubscriptionsData, type GetCurrentSubscriptionsError, type GetCurrentSubscriptionsErrors, type GetCurrentSubscriptionsResponse, type GetCurrentSubscriptionsResponses, type GetCurrentUserData, type GetCurrentUserError, type GetCurrentUserErrors, type GetCurrentUserResponse, type GetCurrentUserResponses, type GetEconomyAccountData, type GetEconomyAccountError, type GetEconomyAccountErrors, type GetEconomyAccountResponse, type GetEconomyAccountResponses, type GetFavoriteGroupData, type GetFavoriteGroupResponse, type GetFavoriteGroupResponses, type GetFavoriteGroupsData, type GetFavoriteGroupsError, type GetFavoriteGroupsErrors, type GetFavoriteGroupsResponse, type GetFavoriteGroupsResponses, type GetFavoriteLimitsData, type GetFavoriteLimitsError, type GetFavoriteLimitsErrors, type GetFavoriteLimitsResponse, type GetFavoriteLimitsResponses, type GetFavoritedAvatarsData, type GetFavoritedAvatarsError, type GetFavoritedAvatarsErrors, type GetFavoritedAvatarsResponse, type GetFavoritedAvatarsResponses, type GetFavoritedWorldsData, type GetFavoritedWorldsError, type GetFavoritedWorldsErrors, type GetFavoritedWorldsResponse, type GetFavoritedWorldsResponses, type GetFavoritesData, type GetFavoritesError, type GetFavoritesErrors, type GetFavoritesResponse, type GetFavoritesResponses, type GetFeaturedCalendarEventsData, type GetFeaturedCalendarEventsError, type GetFeaturedCalendarEventsErrors, type GetFeaturedCalendarEventsResponse, type GetFeaturedCalendarEventsResponses, type GetFileAnalysisData, type GetFileAnalysisError, type GetFileAnalysisErrors, type GetFileAnalysisResponse, type GetFileAnalysisResponses, type GetFileAnalysisSecurityData, type GetFileAnalysisSecurityError, type GetFileAnalysisSecurityErrors, type GetFileAnalysisSecurityResponse, type GetFileAnalysisSecurityResponses, type GetFileAnalysisStandardData, type GetFileAnalysisStandardError, type GetFileAnalysisStandardErrors, type GetFileAnalysisStandardResponse, type GetFileAnalysisStandardResponses, type GetFileData, type GetFileDataUploadStatusData, type GetFileDataUploadStatusResponse, type GetFileDataUploadStatusResponses, type GetFileError, type GetFileErrors, type GetFileResponse, type GetFileResponses, type GetFilesData, type GetFilesResponse, type GetFilesResponses, type GetFollowedCalendarEventsData, type GetFollowedCalendarEventsError, type GetFollowedCalendarEventsErrors, type GetFollowedCalendarEventsResponse, type GetFollowedCalendarEventsResponses, type GetFriendStatusData, type GetFriendStatusError, type GetFriendStatusErrors, type GetFriendStatusResponse, type GetFriendStatusResponses, type GetFriendsData, type GetFriendsError, type GetFriendsErrors, type GetFriendsResponse, type GetFriendsResponses, type GetGlobalAvatarModerationsData, type GetGlobalAvatarModerationsError, type GetGlobalAvatarModerationsErrors, type GetGlobalAvatarModerationsResponse, type GetGlobalAvatarModerationsResponses, type GetGroupAnnouncementsData, type GetGroupAnnouncementsError, type GetGroupAnnouncementsErrors, type GetGroupAnnouncementsResponse, type GetGroupAnnouncementsResponses, type GetGroupAuditLogsData, type GetGroupAuditLogsError, type GetGroupAuditLogsErrors, type GetGroupAuditLogsResponse, type GetGroupAuditLogsResponses, type GetGroupBansData, type GetGroupBansError, type GetGroupBansErrors, type GetGroupBansResponse, type GetGroupBansResponses, type GetGroupCalendarEventData, type GetGroupCalendarEventError, type GetGroupCalendarEventErrors, type GetGroupCalendarEventIcsData, type GetGroupCalendarEventIcsError, type GetGroupCalendarEventIcsErrors, type GetGroupCalendarEventIcsResponse, type GetGroupCalendarEventIcsResponses, type GetGroupCalendarEventResponse, type GetGroupCalendarEventResponses, type GetGroupCalendarEventsData, type GetGroupCalendarEventsError, type GetGroupCalendarEventsErrors, type GetGroupCalendarEventsResponse, type GetGroupCalendarEventsResponses, type GetGroupData, type GetGroupError, type GetGroupErrors, type GetGroupGalleryImagesData, type GetGroupGalleryImagesError, type GetGroupGalleryImagesErrors, type GetGroupGalleryImagesResponse, type GetGroupGalleryImagesResponses, type GetGroupInstancesData, type GetGroupInstancesError, type GetGroupInstancesErrors, type GetGroupInstancesResponse, type GetGroupInstancesResponses, type GetGroupInvitesData, type GetGroupInvitesError, type GetGroupInvitesErrors, type GetGroupInvitesResponse, type GetGroupInvitesResponses, type GetGroupMemberData, type GetGroupMemberError, type GetGroupMemberErrors, type GetGroupMemberResponse, type GetGroupMemberResponses, type GetGroupMembersData, type GetGroupMembersError, type GetGroupMembersErrors, type GetGroupMembersResponse, type GetGroupMembersResponses, type GetGroupPermissionsData, type GetGroupPermissionsError, type GetGroupPermissionsErrors, type GetGroupPermissionsResponse, type GetGroupPermissionsResponses, type GetGroupPostsData, type GetGroupPostsError, type GetGroupPostsErrors, type GetGroupPostsResponse, type GetGroupPostsResponses, type GetGroupRequestsData, type GetGroupRequestsError, type GetGroupRequestsErrors, type GetGroupRequestsResponse, type GetGroupRequestsResponses, type GetGroupResponse, type GetGroupResponses, type GetGroupRoleTemplatesData, type GetGroupRoleTemplatesError, type GetGroupRoleTemplatesErrors, type GetGroupRoleTemplatesResponse, type GetGroupRoleTemplatesResponses, type GetGroupRolesData, type GetGroupRolesError, type GetGroupRolesErrors, type GetGroupRolesResponse, type GetGroupRolesResponses, type GetHealthData, type GetHealthResponse, type GetHealthResponses, type GetImpostorQueueStatsData, type GetImpostorQueueStatsError, type GetImpostorQueueStatsErrors, type GetImpostorQueueStatsResponse, type GetImpostorQueueStatsResponses, type GetInfoPushData, type GetInfoPushResponse, type GetInfoPushResponses, type GetInstanceByShortNameData, type GetInstanceByShortNameError, type GetInstanceByShortNameErrors, type GetInstanceByShortNameResponse, type GetInstanceByShortNameResponses, type GetInstanceData, type GetInstanceError, type GetInstanceErrors, type GetInstanceResponse, type GetInstanceResponses, type GetInventoryData, type GetInventoryDropsData, type GetInventoryDropsError, type GetInventoryDropsErrors, type GetInventoryDropsResponse, type GetInventoryDropsResponses, type GetInventoryError, type GetInventoryErrors, type GetInventoryResponse, type GetInventoryResponses, type GetInventoryTemplateData, type GetInventoryTemplateError, type GetInventoryTemplateErrors, type GetInventoryTemplateResponse, type GetInventoryTemplateResponses, type GetInviteMessageData, type GetInviteMessageError, type GetInviteMessageErrors, type GetInviteMessageResponse, type GetInviteMessageResponses, type GetInviteMessagesData, type GetInviteMessagesError, type GetInviteMessagesErrors, type GetInviteMessagesResponse, type GetInviteMessagesResponses, type GetJamData, type GetJamError, type GetJamErrors, type GetJamResponse, type GetJamResponses, type GetJamSubmissionsData, type GetJamSubmissionsError, type GetJamSubmissionsErrors, type GetJamSubmissionsResponse, type GetJamSubmissionsResponses, type GetJamsData, type GetJamsResponse, type GetJamsResponses, type GetJavaScriptData, type GetJavaScriptError, type GetJavaScriptErrors, type GetJavaScriptResponse, type GetJavaScriptResponses, type GetLicenseGroupData, type GetLicenseGroupError, type GetLicenseGroupErrors, type GetLicenseGroupResponse, type GetLicenseGroupResponses, type GetLicensedAvatarsData, type GetLicensedAvatarsError, type GetLicensedAvatarsErrors, type GetLicensedAvatarsResponse, type GetLicensedAvatarsResponses, type GetNotificationData, type GetNotificationError, type GetNotificationErrors, type GetNotificationResponse, type GetNotificationResponses, type GetNotificationsData, type GetNotificationsError, type GetNotificationsErrors, type GetNotificationsResponse, type GetNotificationsResponses, type GetOwnAvatarData, type GetOwnAvatarError, type GetOwnAvatarErrors, type GetOwnAvatarResponse, type GetOwnAvatarResponses, type GetOwnInventoryItemData, type GetOwnInventoryItemError, type GetOwnInventoryItemErrors, type GetOwnInventoryItemResponse, type GetOwnInventoryItemResponses, type GetPermissionData, type GetPermissionError, type GetPermissionErrors, type GetPermissionResponse, type GetPermissionResponses, type GetPermissionsData, type GetPermissionsError, type GetPermissionsErrors, type GetPermissionsResponse, type GetPermissionsResponses, type GetPlayerModerationsData, type GetPlayerModerationsError, type GetPlayerModerationsErrors, type GetPlayerModerationsResponse, type GetPlayerModerationsResponses, type GetPrintData, type GetPrintError, type GetPrintErrors, type GetPrintResponse, type GetPrintResponses, type GetProductListingData, type GetProductListingError, type GetProductListingErrors, type GetProductListingResponse, type GetProductListingResponses, type GetProductListingsData, type GetProductListingsError, type GetProductListingsErrors, type GetProductListingsResponse, type GetProductListingsResponses, type GetPropData, type GetPropError, type GetPropErrors, type GetPropResponse, type GetPropResponses, type GetRecentLocationsData, type GetRecentLocationsError, type GetRecentLocationsErrors, type GetRecentLocationsResponse, type GetRecentLocationsResponses, type GetRecentWorldsData, type GetRecentWorldsError, type GetRecentWorldsErrors, type GetRecentWorldsResponse, type GetRecentWorldsResponses, type GetRecoveryCodesData, type GetRecoveryCodesError, type GetRecoveryCodesErrors, type GetRecoveryCodesResponse, type GetRecoveryCodesResponses, type GetShortNameData, type GetShortNameError, type GetShortNameErrors, type GetShortNameResponse, type GetShortNameResponses, type GetSteamTransactionData, type GetSteamTransactionError, type GetSteamTransactionErrors, type GetSteamTransactionResponse, type GetSteamTransactionResponses, type GetSteamTransactionsData, type GetSteamTransactionsError, type GetSteamTransactionsErrors, type GetSteamTransactionsResponse, type GetSteamTransactionsResponses, type GetStoreData, type GetStoreError, type GetStoreErrors, type GetStoreResponse, type GetStoreResponses, type GetStoreShelvesData, type GetStoreShelvesError, type GetStoreShelvesErrors, type GetStoreShelvesResponse, type GetStoreShelvesResponses, type GetSubscriptionsData, type GetSubscriptionsError, type GetSubscriptionsErrors, type GetSubscriptionsResponse, type GetSubscriptionsResponses, type GetSystemTimeData, type GetSystemTimeResponse, type GetSystemTimeResponses, type GetTiliaStatusData, type GetTiliaStatusError, type GetTiliaStatusErrors, type GetTiliaStatusResponse, type GetTiliaStatusResponses, type GetTiliaTosData, type GetTiliaTosError, type GetTiliaTosErrors, type GetTiliaTosResponse, type GetTiliaTosResponses, type GetTokenBundlesData, type GetTokenBundlesError, type GetTokenBundlesErrors, type GetTokenBundlesResponse, type GetTokenBundlesResponses, type GetUserByNameData, type GetUserByNameError, type GetUserByNameErrors, type GetUserByNameResponse, type GetUserByNameResponses, type GetUserData, type GetUserError, type GetUserErrors, type GetUserFeedbackData, type GetUserFeedbackError, type GetUserFeedbackErrors, type GetUserFeedbackResponse, type GetUserFeedbackResponses, type GetUserGroupInstancesData, type GetUserGroupInstancesError, type GetUserGroupInstancesErrors, type GetUserGroupInstancesResponse, type GetUserGroupInstancesResponses, type GetUserGroupRequestsData, type GetUserGroupRequestsError, type GetUserGroupRequestsErrors, type GetUserGroupRequestsResponse, type GetUserGroupRequestsResponses, type GetUserGroupsData, type GetUserGroupsError, type GetUserGroupsErrors, type GetUserGroupsResponse, type GetUserGroupsResponses, type GetUserNoteData, type GetUserNoteError, type GetUserNoteErrors, type GetUserNoteResponse, type GetUserNoteResponses, type GetUserNotesData, type GetUserNotesError, type GetUserNotesErrors, type GetUserNotesResponse, type GetUserNotesResponses, type GetUserPrintsData, type GetUserPrintsError, type GetUserPrintsErrors, type GetUserPrintsResponse, type GetUserPrintsResponses, type GetUserRepresentedGroupData, type GetUserRepresentedGroupError, type GetUserRepresentedGroupErrors, type GetUserRepresentedGroupResponse, type GetUserRepresentedGroupResponses, type GetUserResponse, type GetUserResponses, type GetUserSubscriptionEligibleData, type GetUserSubscriptionEligibleError, type GetUserSubscriptionEligibleErrors, type GetUserSubscriptionEligibleResponse, type GetUserSubscriptionEligibleResponses, type GetWorldData, type GetWorldError, type GetWorldErrors, type GetWorldInstanceData, type GetWorldInstanceError, type GetWorldInstanceErrors, type GetWorldInstanceResponse, type GetWorldInstanceResponses, type GetWorldMetadataData, type GetWorldMetadataError, type GetWorldMetadataErrors, type GetWorldMetadataResponse, type GetWorldMetadataResponses, type GetWorldPublishStatusData, type GetWorldPublishStatusError, type GetWorldPublishStatusErrors, type GetWorldPublishStatusResponse, type GetWorldPublishStatusResponses, type GetWorldResponse, type GetWorldResponses, type Group, type GroupAccessType, type GroupAnnouncement, type GroupAnnouncementId, type GroupAuditLogEntry, type GroupAuditLogId, type GroupDiscriminator, type GroupGallery, type GroupGalleryId, type GroupGalleryId2, type GroupGalleryImage, type GroupGalleryImageId, type GroupGalleryImageId2, type GroupId, type GroupId2, type GroupIdFilter, type GroupInstance, type GroupJoinRequestAction, type GroupJoinState, type GroupLimitedMember, type GroupMember, type GroupMemberId, type GroupMemberLimitedUser, type GroupMemberRoleFilter, type GroupMemberSort, type GroupMemberStatus, type GroupMyMember, type GroupPermission, type GroupPermissions, type GroupPost, type GroupPostVisibility, type GroupPrivacy, type GroupRole, type GroupRoleId, type GroupRoleId2, type GroupRoleIdList, type GroupRoleTemplate, type GroupRoleTemplateValues, type GroupSearchSort, type GroupShortCode, type GroupUserVisibility, type Hydrate, type HydrateListings, type HydrateProducts, type Include, type InfoPush, type InfoPushData, type InfoPushDataArticle, type InfoPushDataArticleContent, type InfoPushDataClickable, type Instance, type InstanceContentSettings, type InstanceId, type InstanceId2, type InstanceOwnerId, type InstancePlatforms, type InstanceRegion, type InstanceShortNameResponse, type InstanceType, type Inventory, type InventoryDrop, type InventoryDropId, type InventoryFlag, type InventoryItem, type InventoryItemArchived, type InventoryItemFlags, type InventoryItemId, type InventoryItemId2, type InventoryItemNotFlags, type InventoryItemNotTypes, type InventoryItemTags, type InventoryItemType, type InventoryItemTypes, type InventoryMetadata, type InventoryNotificationDetails, type InventoryPedestalDuration, type InventoryPedestalItemId, type InventorySortOrder, type InventorySpawn, type InventorySpawnItemId, type InventoryTemplate, type InventoryTemplateId, type InventoryTemplateId2, type InviteMessage, type InviteMessageId, type InviteMessageType, type InviteMyselfToData, type InviteMyselfToError, type InviteMyselfToErrors, type InviteMyselfToResponse, type InviteMyselfToResponses, type InviteRequest, type InviteResponse, type InviteUserData, type InviteUserError, type InviteUserErrors, type InviteUserResponse, type InviteUserResponses, type InviteUserWithPhotoData, type InviteUserWithPhotoError, type InviteUserWithPhotoErrors, type InviteUserWithPhotoResponse, type InviteUserWithPhotoResponses, type Jam, type JamId, type JoinGroupData, type JoinGroupError, type JoinGroupErrors, type JoinGroupResponse, type JoinGroupResponses, type KickGroupMemberData, type KickGroupMemberError, type KickGroupMemberErrors, type KickGroupMemberResponses, type LeaveGroupData, type LeaveGroupError, type LeaveGroupErrors, type LeaveGroupResponses, type License, type LicenseAction, type LicenseGroup, type LicenseGroupId, type LicenseGroupId2, type LicenseType, type LimitedGroup, type LimitedUnityPackage, type LimitedUserFriend, type LimitedUserGroups, type LimitedUserInstance, type LimitedUserSearch, type LimitedWorld, type LocalDateTime, type LocationId, type LoginCredentials, type LogoutData, type LogoutError, type LogoutErrors, type LogoutResponse, type LogoutResponses, type MarkNotificationAsReadData, type MarkNotificationAsReadError, type MarkNotificationAsReadErrors, type MarkNotificationAsReadResponse, type MarkNotificationAsReadResponses, type MaxUnityVersion, type MessageType, type MimeType, type MinUnityVersion, type ModerateUserData, type ModerateUserError, type ModerateUserErrors, type ModerateUserRequest, type ModerateUserResponse, type ModerateUserResponses, type MonthDate, type Notag, type Notification, type NotificationDetailInvite, type NotificationDetailInviteResponse, type NotificationDetailRequestInvite, type NotificationDetailRequestInviteResponse, type NotificationDetailVoteToKick, type NotificationId, type NotificationId2, type NotificationType, type Number, type Offline, type Offset, type OkStatus, type Order, type OrderOption, type PaginatedCalendarEventList, type PaginatedGroupAuditLogEntryList, type PastDisplayName, type Pending2FaResult, type PerformanceLimiterInfo, type PerformanceRatings, type Permission, type PermissionId, type PermissionId2, type Platform, type Platform2, type PlatformBuildInfo, type PlayerModeration, type PlayerModerationId, type PlayerModerationType, type Print, type PrintId, type PrintId2, type Product, type ProductId, type ProductId2, type ProductListing, type ProductListingType, type ProductListingVariant, type ProductListingVariantId, type ProductType, type Prop, type PropId, type PropId2, type PropUnityPackage, type PublishWorldData, type PublishWorldError, type PublishWorldErrors, type PublishWorldResponses, type Region, type RegisterUserAccountData, type RegisterUserAccountError, type RegisterUserAccountErrors, type RegisterUserAccountRequest, type RegisterUserAccountResponse, type RegisterUserAccountResponses, type ReleaseStatus, type ReleaseStatus2, type RemoveFavoriteData, type RemoveFavoriteError, type RemoveFavoriteErrors, type RemoveFavoriteResponse, type RemoveFavoriteResponses, type RemoveGroupMemberRoleData, type RemoveGroupMemberRoleError, type RemoveGroupMemberRoleErrors, type RemoveGroupMemberRoleResponse, type RemoveGroupMemberRoleResponses, type RemoveTagsData, type RemoveTagsError, type RemoveTagsErrors, type RemoveTagsResponse, type RemoveTagsResponses, type ReportCategory, type ReportReason, type RepresentedGroup, type RequestInviteData, type RequestInviteError, type RequestInviteErrors, type RequestInviteRequest, type RequestInviteResponse, type RequestInviteResponses, type RequestInviteWithPhotoData, type RequestInviteWithPhotoError, type RequestInviteWithPhotoErrors, type RequestInviteWithPhotoResponse, type RequestInviteWithPhotoResponses, type Require, type ResendEmailConfirmationData, type ResendEmailConfirmationError, type ResendEmailConfirmationErrors, type ResendEmailConfirmationResponse, type ResendEmailConfirmationResponses, type ResetInviteMessageData, type ResetInviteMessageError, type ResetInviteMessageErrors, type ResetInviteMessageResponse, type ResetInviteMessageResponses, type RespondGroupJoinRequest, type RespondGroupJoinRequestData, type RespondGroupJoinRequestError, type RespondGroupJoinRequestErrors, type RespondGroupJoinRequestResponses, type RespondInviteData, type RespondInviteError, type RespondInviteErrors, type RespondInviteResponse, type RespondInviteResponses, type RespondInviteWithPhotoData, type RespondInviteWithPhotoError, type RespondInviteWithPhotoErrors, type RespondInviteWithPhotoResponse, type RespondInviteWithPhotoResponses, type Response$1 as Response, type Search, type SearchActiveUsersData, type SearchActiveUsersError, type SearchActiveUsersErrors, type SearchActiveUsersResponse, type SearchActiveUsersResponses, type SearchAvatarsData, type SearchAvatarsError, type SearchAvatarsErrors, type SearchAvatarsResponse, type SearchAvatarsResponses, type SearchCalendarEventsData, type SearchCalendarEventsError, type SearchCalendarEventsErrors, type SearchCalendarEventsResponse, type SearchCalendarEventsResponses, type SearchGroupsData, type SearchGroupsError, type SearchGroupsErrors, type SearchGroupsResponse, type SearchGroupsResponses, type SearchUsersData, type SearchUsersError, type SearchUsersErrors, type SearchUsersResponse, type SearchUsersResponses, type SearchWorldsData, type SearchWorldsError, type SearchWorldsErrors, type SearchWorldsResponse, type SearchWorldsResponses, type SelectAvatarData, type SelectAvatarError, type SelectAvatarErrors, type SelectAvatarResponse, type SelectAvatarResponses, type SelectFallbackAvatarData, type SelectFallbackAvatarError, type SelectFallbackAvatarErrors, type SelectFallbackAvatarResponse, type SelectFallbackAvatarResponses, type SentNotification, type ServiceQueueStats, type ServiceStatus, type ShareInventoryItemDirectData, type ShareInventoryItemDirectError, type ShareInventoryItemDirectErrors, type ShareInventoryItemDirectRequest, type ShareInventoryItemDirectResponse, type ShareInventoryItemDirectResponses, type ShareInventoryItemPedestalData, type ShareInventoryItemPedestalError, type ShareInventoryItemPedestalErrors, type ShareInventoryItemPedestalResponse, type ShareInventoryItemPedestalResponses, type Slot, type Sort, type SortOption, type SpawnInventoryItemData, type SpawnInventoryItemError, type SpawnInventoryItemErrors, type SpawnInventoryItemResponse, type SpawnInventoryItemResponses, type StartDate, type StartFileDataUploadData, type StartFileDataUploadError, type StartFileDataUploadErrors, type StartFileDataUploadResponse, type StartFileDataUploadResponses, type SteamId, type Store, type StoreId, type StoreId2, type StoreShelf, type StoreShelfId, type StoreType, type StoreView, type StoreView2, type Submission, type Subscription, type SubscriptionPeriod, type Success, type Tag, type Tag2, type TargetIds, type TiliaStatus, type TiliaTos, type TokenBundle, type Transaction, type TransactionAgreement, type TransactionId, type TransactionId2, type TransactionStatus, type TransactionSteamInfo, type TransactionSteamWalletInfo, type TwoFactorAuthCode, type TwoFactorEmailCode, TwoFactorMethods, type TwoFactorRecoveryCodes, type UdonProductId, type UnbanGroupMemberData, type UnbanGroupMemberError, type UnbanGroupMemberErrors, type UnbanGroupMemberResponse, type UnbanGroupMemberResponses, type UnfriendData, type UnfriendError, type UnfriendErrors, type UnfriendResponse, type UnfriendResponses, type UnityPackage, type UnityPackageId, type UnmoderateUserData, type UnmoderateUserError, type UnmoderateUserErrors, type UnmoderateUserResponse, type UnmoderateUserResponses, type UnpublishWorldData, type UnpublishWorldError, type UnpublishWorldErrors, type UnpublishWorldResponses, type UpdateAvatarData, type UpdateAvatarError, type UpdateAvatarErrors, type UpdateAvatarRequest, type UpdateAvatarResponse, type UpdateAvatarResponses, type UpdateBadgeData, type UpdateBadgeError, type UpdateBadgeErrors, type UpdateBadgeResponses, type UpdateCalendarEventRequest, type UpdateFavoriteGroupData, type UpdateFavoriteGroupRequest, type UpdateFavoriteGroupResponses, type UpdateGroupCalendarEventData, type UpdateGroupCalendarEventError, type UpdateGroupCalendarEventErrors, type UpdateGroupCalendarEventResponse, type UpdateGroupCalendarEventResponses, type UpdateGroupData, type UpdateGroupError, type UpdateGroupErrors, type UpdateGroupGalleryData, type UpdateGroupGalleryError, type UpdateGroupGalleryErrors, type UpdateGroupGalleryRequest, type UpdateGroupGalleryResponse, type UpdateGroupGalleryResponses, type UpdateGroupMemberData, type UpdateGroupMemberError, type UpdateGroupMemberErrors, type UpdateGroupMemberRequest, type UpdateGroupMemberResponse, type UpdateGroupMemberResponses, type UpdateGroupPostData, type UpdateGroupPostError, type UpdateGroupPostErrors, type UpdateGroupPostResponse, type UpdateGroupPostResponses, type UpdateGroupRepresentationData, type UpdateGroupRepresentationError, type UpdateGroupRepresentationErrors, type UpdateGroupRepresentationResponse, type UpdateGroupRepresentationResponses, type UpdateGroupRequest, type UpdateGroupResponse, type UpdateGroupResponses, type UpdateGroupRoleData, type UpdateGroupRoleError, type UpdateGroupRoleErrors, type UpdateGroupRoleRequest, type UpdateGroupRoleResponse, type UpdateGroupRoleResponses, type UpdateInventoryItemRequest, type UpdateInviteMessageData, type UpdateInviteMessageError, type UpdateInviteMessageErrors, type UpdateInviteMessageRequest, type UpdateInviteMessageResponse, type UpdateInviteMessageResponses, type UpdateOwnInventoryItemData, type UpdateOwnInventoryItemError, type UpdateOwnInventoryItemErrors, type UpdateOwnInventoryItemResponse, type UpdateOwnInventoryItemResponses, type UpdatePermissionData, type UpdatePermissionError, type UpdatePermissionErrors, type UpdatePermissionResponse, type UpdatePermissionResponses, type UpdateUserBadgeRequest, type UpdateUserData, type UpdateUserError, type UpdateUserErrors, type UpdateUserNoteData, type UpdateUserNoteError, type UpdateUserNoteErrors, type UpdateUserNoteRequest, type UpdateUserNoteResponse, type UpdateUserNoteResponses, type UpdateUserRequest, type UpdateUserResponse, type UpdateUserResponses, type UpdateWorldData, type UpdateWorldError, type UpdateWorldErrors, type UpdateWorldRequest, type UpdateWorldResponse, type UpdateWorldResponses, type UploadGalleryImageData, type UploadGalleryImageResponse, type UploadGalleryImageResponses, type UploadIconData, type UploadIconResponse, type UploadIconResponses, type UploadImageData, type UploadImageResponse, type UploadImageResponses, type UploadPrintData, type UploadPrintError, type UploadPrintErrors, type UploadPrintResponse, type UploadPrintResponses, type User, type UserExists, type UserId, type UserId2, type UserIdAdmin, type UserIdQuery, type UserNote, type UserNoteId, type UserNoteId2, type UserState, type UserStatus, type UserSubscription, type UserSubscriptionEligible, type UsernameQuery, type UtcOffset, VRChat, VRChatError, type VRChatOptions, type Variant, type Verify2FaData, type Verify2FaEmailCodeData, type Verify2FaEmailCodeError, type Verify2FaEmailCodeErrors, type Verify2FaEmailCodeResponse, type Verify2FaEmailCodeResponses, type Verify2FaEmailCodeResult, type Verify2FaError, type Verify2FaErrors, type Verify2FaResponse, type Verify2FaResponses, type Verify2FaResult, type VerifyAuthTokenData, type VerifyAuthTokenError, type VerifyAuthTokenErrors, type VerifyAuthTokenResponse, type VerifyAuthTokenResponses, type VerifyAuthTokenResult, type VerifyLoginPlaceData, type VerifyLoginPlaceToken, type VerifyPending2FaData, type VerifyPending2FaError, type VerifyPending2FaErrors, type VerifyPending2FaResponse, type VerifyPending2FaResponses, type VerifyRecoveryCodeData, type VerifyRecoveryCodeError, type VerifyRecoveryCodeErrors, type VerifyRecoveryCodeResponse, type VerifyRecoveryCodeResponses, type VersionId, type World, type WorldId, type WorldId2, type WorldMetadata, type WorldPublishStatus, baseUrl };
